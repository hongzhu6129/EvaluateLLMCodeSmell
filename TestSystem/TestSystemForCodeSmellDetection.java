package TestSystem;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;
import morphy.annotations.Action;
import morphy.annotations.Analyser;
import morphy.annotations.Datamorphism;
import morphy.annotations.MakeSeed;
import morphy.annotations.Metamorphism;
import morphy.annotations.TestCase;
import morphy.annotations.TestCaseMetric;
import morphy.annotations.TestDataFeature;
import morphy.annotations.TestExecuter;
import morphy.annotations.TestPool;
import morphy.annotations.TestSetContainer;
import morphy.annotations.TestSetFilter;
import morphy.annotations.TestSetMetric;
import opennlp.tools.sentdetect.SentenceDetectorME;
import opennlp.tools.sentdetect.SentenceModel;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.RandomAccessFile;
import java.io.StringReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;
import java.util.UUID;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.CategoryLabelPositions;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.category.DefaultCategoryDataset;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TestSystemForCodeSmellDetection {
	
	@TestSetContainer(
			inputTypeName = "String",
			outputTypeName = "String"
			)
	public static TestPool<String, String> testSuite = new TestPool<String, String>();
	
	public static List<String> filePathForCodeAnalysis = new ArrayList<>(); // Storing the file paths for program codes of current execution.
	public static List<String> filePathForStatementAnalysis = new ArrayList<>(); // Storing the file paths of generated statements by language model.
	public static List<String> filePathForLastCodeAnalysis = new ArrayList<>();
	public static String currentClassFilePath = "";
	public static String currentPathToJSON = "";
	public static TestCase<String, String> currentTestCase = new TestCase<>();
	public static String givenSolutionOfCurrentTestCase = "";
	public static String currentProblemID = "";
	public static String currentClassName = "";
	public static String CurrentGivenCodeClassName = "";
	public static String outputOfCurrentTestCase = "";
	// Create a map to store solutions with problem IDs
    public static Map<String, String> solutionsMap = new HashMap<>();
    public static Map<String, String> versionProblemIDmap = new HashMap<>();
    public static String filePathToGivenSolution = "";
    public static String pathOfGeneratedProgram = ""; // Only considering one program path for now.
	public static StringBuilder programOutputOne  ;
	public static StringBuilder programOutputTwo  ;
	public static String version = "v1.0";
	public static int numberOfConversation = 1;
	public static int numberOfAttempts = 1;
	public static String promptForDialogue = "";
	public static String problemIDDialogue = "";
	public static String FilePathToGivenSolutionForEvosuitePurpose = "";
	public static String FilePathToGeneratedSolutionForEvosuitePurpose = "";
	public static Map<String, String> IDProblemSource = new HashMap<>();
	public static Map<String, String> IDProblemDescription = new HashMap<>();
	public static Map<String, String> IDSolution = new HashMap<>();
	public static Map<String, List<String>> IDIncludedTopics = new HashMap<>();
	public static Map<String, String> IDVersion = new HashMap<>();
	public static Map<String, String> IDBookName = new HashMap<>();
	public static Map<String, String> IDAuthors = new HashMap<>();
	public static Map<String, String> IDChapterName = new HashMap<>();
	public static Map<String, String> IDProblemNumber = new HashMap<>();
	public static Map<String, String> IDWebSourceName = new HashMap<>();
	public static Map<String, String> IDWebAddress = new HashMap<>();
	public static Map<String, String> IDYear = new HashMap<>();
	public static Map<String, String> IDProblemTitle = new HashMap<>();
	public static Map<String, String> IDComplexity = new HashMap<>();
	public static Map<String, List<String>> IDTestCases = new HashMap<>();
	public static Map<String, Double> paraphraseIdToEuclideanDistance = new HashMap<>();
	public static String currentClassNameForReferenceSolution = "";
	public static String currentClassNameForGeneratedSolution = "";
	public static String classNameToTestParaphrases = "";
	public static String MainClassNameOfGeneratedCode = "";
	
	public static String codeSnippet;
    public static Map<String, String> functionMap;
    public static String seedId = "";
    public static String nothingGenerated = "";
    
    public static ArrayNode problemsArray;
    public static ObjectMapper objectMapper = new ObjectMapper();
    public static String IDofproblemToModify = "";
    public static String VersionToModify = "";
    public static String modifiedDescription = "";
    public static String paraphraseDistanceCalculation = "";
    public static String sourcePathOfParaphraseDistance = "";
    public static List<String> paraphraseIds = new ArrayList<>();
    public static List<String> removedIds = new ArrayList<>();
    public static String maxId = null; // Find the ID of the paraphrase with the highest Euclidean distance   
    public static String maxIdinfo = null;
    public static String IdWithHighestSimilarity = null;
    public static double highestSimilarityScore = 0.0;
    public static HashMap<String, Double> uniqueDistanceMap = new HashMap<>();
    public static Map<String, Double> sortedParaphrasesByEuclidean = new LinkedHashMap<>();
    public static double lowestDistanceByEuclidean;
    public static String lowestParaphraseIdByEuclidean;
    public static double highestDistanceByEuclidean;
    public static String highestParaphraseIdByEuclidean;
    // HashMap to store the IDs of paraphrases and their euclidean distances
    //public static Map<String, Double> distanceMap = new HashMap<>();
    public static final Map<String, Double> distanceMap = new ConcurrentHashMap<>();
    public static final Map<String, String> paraphraseMutantMap = new ConcurrentHashMap<>();
    public static double semanticThreshold = 0.0;
    public static double euclideanThreshold = 0.0;
    public static final Map<String, Double> euclideanDistanceMap = new ConcurrentHashMap<>();
    public static final Map<String, Double> semanticDistanceMap = new ConcurrentHashMap<>();
    public static final Map<String, Double> ratioMap = new HashMap<>();
    
    public static long elapsedTime = 0;
    public static double memoryUsedInMB = 0;
    
    public static int Neighbourhood = 1;
    public static int NumberOfWords = 1;
    public static Map<String, Integer> neighbourhoodMap = new HashMap<>();
    public static Map<String, Integer> numberOfWordsMap = new HashMap<>();
    
    public static String evosuiteRunnerTextFilePathForGiven;
    public static String evosuiteRunnerTextFilePathForGenerated;
    public static final Pattern FAILURE_PATTERN = Pattern.compile("\\d+\\) (.+?)\\(");
    private static final String TARGET_FILE_NAME = "PMDViolationAnalysis.txt";
    private static int foldersWithMoreThan5Violations = 0;
    private static int totalSubfoldersWithPMD = 0;
	
	// Storing features of each problem
	private static void getFeaturesOfEachProblem(String filePath) {
		JsonNode problemParts = null; 
        JsonNode solutionParts = null;
        JsonNode includedTopicsNode = null;
        String problemLanguage = "";
        String probID = "";       
        String currentVersion = "";
        String source = "";
        String bookName = "";
        String authors = "";
        String chapterName = "";
        String problemNumber = "";
        String webSourceName = "";
        String webAddress = "";
        String yearOfPostingQuery = "";
        String problemTitle = "";
        String complexity = "";       
                
        try {
           ObjectMapper objectMapper = new ObjectMapper();
           
           // Read the JSON file and parse it into a JsonNode
           File jsonFile = new File(filePath);
           JsonNode jsonNode = objectMapper.readTree(jsonFile);
           
           //int i = 0;
           // Ensure jsonNode is an array
           if (jsonNode.isArray()) {
               for (JsonNode problem : jsonNode) {             	   
            	   
                // Initialize the prompt for each problem
                   StringBuilder prompt = new StringBuilder();
                   problemParts = problem.get("parts");
                   solutionParts = problem.get("solution");
                   problemLanguage = problem.get("programLanguage").asText();
                   probID = problem.get("problemID").asText();
                   //givenSolution = problem.get("givenSolution").asText();
                   currentVersion = problem.get("version").asText();
                   problemTitle = problem.get("problemTitle").asText();
                   //complexity = problem.get("complexity").asText();
                   
                   if (problem.has("cyclomaticComplexity")) {
                	    complexity = problem.get("cyclomaticComplexity").asText();
                	} else {
                	    complexity = problem.get("complexity").asText();
                	}
                   
                   source = problem.get("sourceType").asText();
                   if("Text Book".equals(source)) {
                	   bookName = problem.get("bookName").asText();
                	   authors = problem.get("authors").asText();
                	   chapterName = problem.get("chapterName").asText();
                	   problemNumber = problem.get("problemNumber").asText();    
                	   System.out.println("Book Name: " + bookName);
                       System.out.println("Authors: " + authors);
                       System.out.println("Chapter Name: " + chapterName);
                       System.out.println("Problem Number: " + problemNumber);
                   } else if ("Web Source".equals(source))                    {
                	   webSourceName = problem.get("WebSourceName").asText();
                	   webAddress = problem.get("WebAddress").asText();
                	   yearOfPostingQuery = problem.get("yearOfPostingQuery").asText();
                	   System.out.println("Web Source Name: " + webSourceName);
                       System.out.println("Web Address: " + webAddress);
                       System.out.println("Year of Posting Query: " + yearOfPostingQuery);
                   } else {
                	   // For others
                   }
                   String problemDescription = "";
                   for (JsonNode part : problemParts) {
                       String type = part.get("type").asText();
                       String content = part.get("content").asText();
                       if ("image path".equals(type)) {
                            problemDescription = problemDescription + "Fetch the image from the image path as part of the problem: ";
                             problemDescription = problemDescription + content;
                          } else {
                        	  problemDescription = problemDescription + content;
                          }                          
                       }                                      
                   String givenSolution = "";                   
                   for (JsonNode solutionPart : solutionParts) {
                	   if(givenSolution.equals("")) {
                	   givenSolution = givenSolution + "";
                       String soln = solutionPart.get("partsOfSolution").asText();
                       givenSolution = givenSolution + soln;
                       givenSolution = givenSolution + "\n";}
                	   else {
                		   String soln = solutionPart.get("partsOfSolution").asText();
                           givenSolution = givenSolution +  "// next part of solution" + "\n" + soln;
                           givenSolution = givenSolution + "\n";
                	   }
                	   }
                   // Extracting includedTopics
                   List<String> includedTopicsList = new ArrayList<>();
                   includedTopicsNode = problem.get("includedTopics");
                   if (includedTopicsNode.isArray()) {
                       for (JsonNode topic : includedTopicsNode) {
                    	   String topicToBeAdded = topic.asText();
                    	   includedTopicsList.add(topic.asText());
                       }
                   }                  
                   // Extracting testCases
                   List<String> testCasesList = new ArrayList<>();
                   JsonNode testCasesNode = problem.get("testCases");
                   if (testCasesNode.isArray()) {
                       for (JsonNode testCase : testCasesNode) {
                           String input = testCase.get("input").asText();
                           String output = testCase.get("output").asText();
                           String cases = "<" + input + "," + output + ">";
                           testCasesList.add(cases);
                       }
                   }
                   
                   System.out.println("Problem ID: " + probID);
                   System.out.println("Problem Description: " + problemDescription);
                   System.out.println("Given Solution: " + givenSolution);
                   System.out.println("Included Topics: " + includedTopicsList);
                   System.out.println("Version: " + currentVersion);
                   System.out.println("Problem Title: " + problemTitle);
                   System.out.println("Complexity: " + complexity);
                   System.out.println("Test Cases: " + testCasesList);
                   
                   IDProblemSource.put(probID, source);
                   IDProblemDescription.put(probID, problemDescription);
               	   IDSolution.put(probID, givenSolution);
               	   IDIncludedTopics.put(probID, includedTopicsList);
               	   IDVersion.put(probID, currentVersion);
               	   if("Text Book".equals(source)) {
               	   IDBookName.put(probID, bookName);
               	   IDAuthors.put(probID,  authors);
               	   IDChapterName.put(probID, chapterName);
               	   IDProblemNumber.put(probID,  problemNumber);
               	   } else if("Web Source".equals(source)) {
               	   IDWebSourceName.put(probID, webSourceName);
               	   IDWebAddress.put(probID, webAddress);
               	   IDYear.put(probID, yearOfPostingQuery);
               	   } else {
               		   // For Other problems
               	   }
               	   IDProblemTitle.put(probID, problemTitle);
               	   IDComplexity.put(probID, complexity);
               	   IDTestCases.put(probID, testCasesList);
               	   
               	   //i++;
               	   //System.out.println(i);
               }
           }
        }catch (IOException e) {
            e.printStackTrace();
        }               
	}
	
	// Fetching and storing features from w3resoueces problems
	private static void getFeaturesOfEachW3ResourceProblem(String filePath) {
		JsonNode problemParts = null; 
        JsonNode solutionParts = null;
        JsonNode includedTopicsNode = null;
        String problemLanguage = "";
        String probID = "";       
        String currentVersion = "";
        String source = "";
        String bookName = "";
        String authors = "";
        String chapterName = "";
        String problemNumber = "";
        String webSourceName = "";
        String webAddress = "";
        String yearOfPostingQuery = "";
        String problemTitle = "";
        String complexity = "";       
                
        try {
           ObjectMapper objectMapper = new ObjectMapper();
           
           // Read the JSON file and parse it into a JsonNode
           File jsonFile = new File(filePath);
           JsonNode jsonNode = objectMapper.readTree(jsonFile);
           
           //int i = 0;
           // Ensure jsonNode is an array
           if (jsonNode.isArray()) {
               for (JsonNode problem : jsonNode) {             	   
            	   
                // Initialize the prompt for each problem
                   StringBuilder prompt = new StringBuilder();
                   problemParts = problem.get("parts");
                   //solutionParts = problem.get("solution");
                   problemLanguage = problem.get("programLanguage").asText();
                   probID = problem.get("problemID").asText();
                   //givenSolution = problem.get("givenSolution").asText();
                   currentVersion = problem.get("version").asText();
                   problemTitle = problem.get("problemTitle").asText();
                   complexity = problem.get("complexity").asText();
                   source = problem.get("sourceType").asText();
                   webSourceName = problem.get("WebSourceName").asText();
                   webAddress = problem.get("WebAddress").asText();
                   //yearOfPostingQuery = problem.get("yearOfPostingQuery").asText();
                	   
                   String problemDescription = "";
                   for (JsonNode part : problemParts) {
                       String type = part.get("type").asText();
                       String content = part.get("content").asText();
                       if ("image path".equals(type)) {
                            problemDescription = problemDescription + "Fetch the image from the image path as part of the problem: ";
                             problemDescription = problemDescription + content;
                          } else {
                        	  problemDescription = problemDescription + content;
                          }                          
                       }                                      
                   String givenSolution = problem.get("givenSolution").asText();                   
                   
                   // Extracting includedTopics
                   List<String> includedTopicsList = new ArrayList<>();
                   String subject = problem.get("subject").asText();
                   
                   // Using contains to check if a substring is present
                   boolean isSubstringPresent = subject.contains("[");
                   
                   if (isSubstringPresent) {
                   int subjectStartIndex = subject.indexOf("[");
                   int subjectEndIndex = subject.indexOf("]");
                   String partToRemove = subject.substring(subjectStartIndex, subjectEndIndex + 1);
                   String topics = subject.replace(partToRemove, "");
                   includedTopicsList.add(topics); 
                   } else {
                	   includedTopicsList.add(subject);
                   }
                                    
                   // Extracting testCases
                   List<String> testCasesList = new ArrayList<>();
                   JsonNode testCasesNode = problem.get("testCases");
                   if (testCasesNode.isArray()) {
                       for (JsonNode testCase : testCasesNode) {
                           String input = testCase.get("input").asText();
                           String output = testCase.get("output").asText();
                           String cases = "<" + input + "," + output + ">";
                           testCasesList.add(cases);
                       }
                   }
                   
                   System.out.println("Problem ID: " + probID);
                   System.out.println("Problem Description: " + problemDescription);
                   System.out.println("Given Solution: " + givenSolution);
                   System.out.println("Included Topics: " + includedTopicsList);
                   System.out.println("Version: " + currentVersion);
                   System.out.println("Problem Title: " + problemTitle);
                   System.out.println("Complexity: " + complexity);
                   System.out.println("Test Cases: " + testCasesList);
                   
                   IDProblemSource.put(probID, webSourceName);
                   IDProblemDescription.put(probID, problemDescription);
               	   IDSolution.put(probID, givenSolution);
               	   IDIncludedTopics.put(probID, includedTopicsList);
               	   IDVersion.put(probID, currentVersion);
               	   if("Text Book".equals(source)) {
               	   IDBookName.put(probID, bookName);
               	   IDAuthors.put(probID,  authors);
               	   IDChapterName.put(probID, chapterName);
               	   IDProblemNumber.put(probID,  problemNumber);
               	   } else if("Web Source".equals(source)) {
               	   IDWebSourceName.put(probID, webSourceName);
               	   IDWebAddress.put(probID, webAddress);
               	   IDYear.put(probID, yearOfPostingQuery);
               	   } else {
               		   // For Other problems
               	   }
               	   IDProblemTitle.put(probID, problemTitle);
               	   IDComplexity.put(probID, complexity);
               	   IDTestCases.put(probID, testCasesList);
               	   
               	   //i++;
               	   //System.out.println(i);
               }
           }
        }catch (IOException e) {
            e.printStackTrace();
        }               
	}
	
	// Adding seed test cases to the testSuite from JSON
	private static void getSeedsFromJSON(String filePath)throws IOException {
		JsonNode problemParts = null; 
        JsonNode solutionParts = null;
        String problemLanguage = "";
        String probID = "";
        String givenSolution = "";
        String currentVersion = "";
        try {
           ObjectMapper objectMapper = new ObjectMapper();
           // Read the JSON file and parse it into a JsonNode
           // Read the JSON file and parse it into a JsonNode
           File jsonFile = new File(filePath);
           JsonNode jsonNode = objectMapper.readTree(jsonFile);
           
           // Ensure jsonNode is an array
           if (jsonNode.isArray()) {
               for (JsonNode problem : jsonNode) {  
            	   
            	   // Initialize the prompt for each problem
                   StringBuilder prompt = new StringBuilder();  
                   StringBuilder promptQuestion = new StringBuilder();
                   problemParts = problem.get("parts");
                   solutionParts = problem.get("solution");
                   problemLanguage = problem.get("programLanguage").asText();
                   probID = problem.get("problemID").asText();
                   //givenSolution = problem.get("givenSolution").asText();
                   currentVersion = problem.get("version").asText();
                   
                   prompt.append("Problem Description : ").append("\n");
                  
                   for (JsonNode part : problemParts) {
                       String type = part.get("type").asText();
                       String content = part.get("content").asText();
                       if ("image path".equals(type)) {
                           prompt.append("Fetch the image from the image path as part of the problem: ");
                           prompt.append(content);
                           promptQuestion.append("Fetch the image from the image path as part of the problem: ");
                           promptQuestion.append(content);
                       } else {
                           prompt.append(content);
                           promptQuestion.append(content);
                       }
                       prompt.append("\n");
                       promptQuestion.append("\n");
                   }                   
                                      
                   for (JsonNode solutionPart : solutionParts) {
                	   //prompt.append("Given Solution : ").append("\n");
                       String soln = solutionPart.get("partsOfSolution").asText();
                       givenSolution = givenSolution + "\n" + "//next part" + soln;
                       //prompt.append(soln);
                       //prompt.append("\n");
                       //promptQuestion.append("\n");
                   }
                   
                   // Store the solution in the map
                   solutionsMap.put(probID, givenSolution);
                   versionProblemIDmap.put(probID, currentVersion);

                   // Append the programming language to the end of the prompt
                   prompt.append("\n").append(" The programming language you need to use is: ").append(problemLanguage).append(".").append("\n");
                   prompt.append("\n").append(" Problem Id is : ").append(probID).append(".");
                   //prompt.append("\n").append(" Given Solution is : ").append("\n").append(givenSolution);
                   
                   promptQuestion.append("\n").append(" The programming language you need to use is: ").append(problemLanguage).append(".").append("\n");
                   //promptQuestion.append("\n").append(" Problem Id is : ").append(probID).append(".").append("\n");
                                     
               
                   // Create a new test case for each problem
                   TestCase<String, String> tc = new TestCase<>();
                   tc.input = prompt.toString().replace("\n", "\\n");
                   tc.feature = TestDataFeature.original;
                   tc.setType("ProgrammingProblem");
                   testSuite.addTestCase(tc);
                   tc.id = probID;
                   //tc.output = givenSolution;
                   System.out.println(tc.input);
                   System.out.println(tc.id);
                   
               }
           } else {
               System.err.println("JSON file does not contain an array of test cases.");
           }
       } catch (IOException e) {
           e.printStackTrace();
       }
	}
	
	//Adding w3reources java problems to the test suite
	@MakeSeed
	public void ExtractW3Resource() throws IOException {
		 String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkW3Resources.json";
		 getFeaturesOfEachW3ResourceProblem(filePath);
			        
	        JsonNode problemParts = null;   
	        String problemLanguage = "";
	        String probID = "";
	        String givenSolution = "";
	        String currentVersion = "";
	        try {
	           ObjectMapper objectMapper = new ObjectMapper();
	           // Read the JSON file and parse it into a JsonNode
	           // Read the JSON file and parse it into a JsonNode
	           File jsonFile = new File(filePath);
	           JsonNode jsonNode = objectMapper.readTree(jsonFile);
	           // Ensure jsonNode is an array
	           if (jsonNode.isArray()) {
	               for (JsonNode problem : jsonNode) {  
	            	   
	            	   // Initialize the prompt for each problem
	                   StringBuilder prompt = new StringBuilder();  
	                   StringBuilder promptQuestion = new StringBuilder();
	                   problemParts = problem.get("parts");
	                   problemLanguage = problem.get("programLanguage").asText();
	                   probID = problem.get("problemID").asText();
	                   givenSolution = problem.get("givenSolution").asText();
	                   currentVersion = problem.get("version").asText();
	                   
	                   prompt.append("Problem Description : ").append("\n");
	                  
	                   for (JsonNode part : problemParts) {
	                       String type = part.get("type").asText();
	                       String content = part.get("content").asText();
	                       if ("image path".equals(type)) {
	                           prompt.append("Fetch the image from the image path as part of the problem: ");
	                           prompt.append(content);
	                           promptQuestion.append("Fetch the image from the image path as part of the problem: ");
	                           promptQuestion.append(content);
	                       } else {
	                           prompt.append(content);
	                           promptQuestion.append(content);
	                       }
	                       prompt.append("\n");
	                       promptQuestion.append("\n");
	                   }
	                   
	                   // Store the solution in the map
	                   solutionsMap.put(probID, givenSolution);
	                   versionProblemIDmap.put(probID, currentVersion);

	                   // Append the programming language to the end of the prompt
	                   prompt.append("\n").append(" The programming language you need to use is: ").append(problemLanguage).append(".").append("\n");
	                   prompt.append("\n").append(" Problem Id is : ").append(probID).append(".").append("\n");
	                   //prompt.append("\n").append(" Given Solution is : ").append("\n").append(givenSolution);
	                   
	                   // Create a new test case for each problem
	                   TestCase<String, String> tc = new TestCase<>();
	                   tc.input = prompt.toString().replace("\n", "\\n");
	                   //tc.input = prompt.toString();
	                   tc.feature = TestDataFeature.original;
	                   tc.setType("ProgrammingProblem");
	                   testSuite.addTestCase(tc);
	                   tc.id = probID;
	                   //tc.output = givenSolution;
	                   System.out.println(tc.input);
	                   System.out.println(tc.id);
	               }
	           } else {
	               System.err.println("JSON file does not contain an array of test cases.");
	           }
	       } catch (IOException e) {
	           e.printStackTrace();
	       }      
	}
	
	// Adding StackOverflow code generation java problems to the test suite
		//@MakeSeed
		//public void StackOverflowProblemsSetOne() throws IOException {
			//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowCodeGeneration.json";   
			//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\outputThree.json";
			//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\output.json";
			//getFeaturesOfEachProblem(filePath);
			//getSeedsFromJSON(filePath);
		//}
	// Adding Absolute Java java problems to the test suite
				//@MakeSeed
				public void ManualTaskEntryTwo() throws IOException {
					//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmakTextBookAbsoluteJava.json";  
					String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\JSONBenchmakTextBookAbsoluteJavaNew.json";
					//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\New folder\\JSONBenchmakTextBookLiang.json";
					//String filePath = "D:\\JSONFilesForExperiments\\JSONBenchmakTextBookLiang.json";
					getFeaturesOfEachProblem(filePath);
					getSeedsFromJSON(filePath);
				}
				
				@MakeSeed
				public void ManualTaskEntry() throws IOException {
				 // Options for the user
		        String[] options = { "JavaByLiang", "Absolute Java"};
		        String[] filePaths = {
		            //"C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\JSONBenchmakTextBookLiang.json", // w3resources
		            "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\New folder\\JSONBenchmakTextBookLiang.json", // JavaByLiang
		            "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\JSONBenchmakTextBookAbsoluteJavaNew.json" // Absolute Java
		        };

		        // Create a JList for the options
		        JList<String> list = new JList<>(options);
		        list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		        JScrollPane scrollPane = new JScrollPane(list);

		        // Show the scrollable list inside a JOptionPane
		        int result = JOptionPane.showConfirmDialog(
		                null,
		                scrollPane,
		                "Select a JSON File",
		                JOptionPane.OK_CANCEL_OPTION,
		                JOptionPane.PLAIN_MESSAGE
		        );

		        if (result == JOptionPane.OK_OPTION) {
		            int selectedIndex = list.getSelectedIndex();
		            if (selectedIndex != -1) {
		                String selectedFilePath = filePaths[selectedIndex];
		                System.out.println("You selected: " + options[selectedIndex]);
		                System.out.println("Processing file: " + selectedFilePath);
		                //ManualTaskEntry(selectedFilePath);
		                
		                getFeaturesOfEachProblem(selectedFilePath);
						getSeedsFromJSON(selectedFilePath);
		            } else {
		                System.out.println("No option selected.");
		            }
		        } else {
		            System.out.println("Operation canceled.");
		        }
				}
	
	// Adding Stack Overflow java problems to the test suite
			@MakeSeed
			public void ExtractStackOverflow() throws IOException {
				//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVATwo.json";   
				//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVAFresh.json";
				//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\JSONBenchmarkStackOverflowWithSolutionDataStructure.json";
				String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONFilesForExperiments\\JSONBenchmarkStackOverflowWithSolutionRecursion.json";
				getFeaturesOfEachProblem(filePath);
				getSeedsFromJSON(filePath);
			}
			
			//@Analyser
			public void selectTestCasesBySemanticAndEuclideanRatio() {
			    // HashMap to hold test case IDs and their semantic/euclidean ratio
			    //Map<String, Double> ratioMap = new HashMap<>();

			    // Loop through each test case ID
			    for (int i = 1; i < testSuite.testSet.size(); i++) {
			        TestCase<String, String> x = testSuite.testSet.get(i);
			        String id = x.id;

			        // Retrieve the semantic similarity and Euclidean distance from the maps
			        Double semanticScore = semanticDistanceMap.get(id);
			        Double euclideanScore = euclideanDistanceMap.get(id);

			        // Ensure both values are not null and Euclidean distance is not zero (to avoid division by zero)
			        if (semanticScore != null && euclideanScore != null && euclideanScore != 0) {
			            // Calculate the ratio: higher semantic / lower euclidean
			            double ratio = semanticScore / euclideanScore;

			            // Store the ID and its ratio in the HashMap
			            ratioMap.put(id, ratio);
			        }
			    }
			    
			    double maxDistance = Double.NEGATIVE_INFINITY;

	            for (Map.Entry<String, Double> entry : ratioMap.entrySet()) {
	                if (entry.getValue() > maxDistance) {
	                    maxDistance = entry.getValue();
	                    IdWithHighestSimilarity = entry.getKey();
	                    highestSimilarityScore = entry.getValue();
	                }
	            }

	            double minDistance = Double.POSITIVE_INFINITY;

	            for (Map.Entry<String, Double> entry : ratioMap.entrySet()) {
	                if (entry.getValue() < minDistance) {
	                    minDistance = entry.getValue();
	                    maxId = entry.getKey(); // holding ID with minimum similarity or maximum dissimilarity
	                }
	            }

			    // Sort the HashMap by values (the ratios) in descending order
			    //List<Map.Entry<String, Double>> sortedEntries = new ArrayList<>(ratioMap.entrySet());
			    //sortedEntries.sort((entry1, entry2) -> Double.compare(entry2.getValue(), entry1.getValue()));

			    // Display or use the selected test cases
			    StringBuilder message = new StringBuilder("Selected Test Cases by Semantic/Euclidean Ratio:\n");
			    for (Map.Entry<String, Double> entry : ratioMap.entrySet()) {
			        message.append("ID: ").append(entry.getKey()).append(", Ratio: ").append(entry.getValue()).append("\n");
			    }

			    // Show the selected test cases
			    JOptionPane.showMessageDialog(null, message.toString());
			}

			
			@TestSetFilter
			public void selectTestCasesBySemanticAndEuclidean() {
			    // Create a panel to hold input fields
			    JPanel panel = new JPanel(new GridLayout(0, 2));

			    // Add input fields for semantic similarity thresholds
			    panel.add(new JLabel("Min Semantic Similarity:"));
			    JTextField minSemanticField = new JTextField();
			    panel.add(minSemanticField);

			    panel.add(new JLabel("Max Semantic Similarity:"));
			    JTextField maxSemanticField = new JTextField();
			    panel.add(maxSemanticField);

			    // Add input fields for Euclidean distance thresholds
			    panel.add(new JLabel("Min Euclidean Distance:"));
			    JTextField minEuclideanField = new JTextField();
			    panel.add(minEuclideanField);

			    panel.add(new JLabel("Max Euclidean Distance:"));
			    JTextField maxEuclideanField = new JTextField();
			    panel.add(maxEuclideanField);

			    // Show the dialog
			    int result = JOptionPane.showConfirmDialog(null, panel, "Enter Thresholds", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

			    if (result == JOptionPane.OK_OPTION) {
			        try {
			            // Parse inputs to double
			            double minSemantic = Double.parseDouble(minSemanticField.getText());
			            double maxSemantic = Double.parseDouble(maxSemanticField.getText());
			            double minEuclidean = Double.parseDouble(minEuclideanField.getText());
			            double maxEuclidean = Double.parseDouble(maxEuclideanField.getText());

			            // List to hold the IDs of selected test cases
			            List<String> selectedTestCaseIDs = new ArrayList<>();

			            // Filter test cases based on the provided thresholds
			            for (int i = 1; i < testSuite.testSet.size(); i++) {
			                TestCase<String, String> x = testSuite.testSet.get(i);
			                String id = x.id;
			                double semanticScore = semanticDistanceMap.get(id); // Assuming you have a map of scores
			                double euclideanScore = euclideanDistanceMap.get(id);

			                // Check if the scores fall within the specified ranges
			                if (semanticScore >= minSemantic && semanticScore <= maxSemantic &&
			                    euclideanScore >= minEuclidean && euclideanScore <= maxEuclidean) {
			                    // Add the ID to the list
			                    selectedTestCaseIDs.add(id);
			                }
			            }

			            // Display the selected test case IDs
			            if (!selectedTestCaseIDs.isEmpty()) {
			                StringBuilder message = new StringBuilder("Selected Test Case IDs:\n");
			                for (String testCaseID : selectedTestCaseIDs) {
			                    message.append(testCaseID).append("\n");
			                }
			                JOptionPane.showMessageDialog(null, message.toString());
			            } else {
			                JOptionPane.showMessageDialog(null, "No test cases matched the criteria.");
			            }

			        } catch (NumberFormatException e) {
			            JOptionPane.showMessageDialog(null, "Invalid input. Please enter numeric values.");
			        }
			    }
			}

			
			@TestSetFilter
			public void TaskManipulation() {
				//String userInput = JOptionPane.showInputDialog("Enter test case ID: ");
		        problemEditorTwo();			
				
		        for (int i = 0; i < testSuite.testSet.size(); i++) {
		            TestCase<String, String> x = testSuite.testSet.get(i);
		            String id = x.id;
		            if (IDofproblemToModify.equals(id)) {
		            	VersionToModify = versionProblemIDmap.get(id);
		            	//String description = IDProblemDescription.get(id);
		            	//String modifiedDescription = JOptionPane.showInputDialog("Do you want to modify description? " + description);
		            	x.input = modifiedDescription.toString().replace("\n", "\\n");
		            } 
		        }		        
			}
			
			public static void problemEditorTwo() {
				    // Load the JSON file
			        String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVAFresh.json";// Need to add all JSON files
			        try {
			            String content = new String(Files.readAllBytes(Paths.get(filePath)));
			            problemsArray = (ArrayNode) objectMapper.readTree(content);
			        } catch (IOException e) {
			            e.printStackTrace();
			            return;
			        }

			        // Prompt for Problem ID
			        String problemID = JOptionPane.showInputDialog(null, "Enter Problem ID:");
			        IDofproblemToModify = problemID;
			        if (problemID == null) {
			            // User canceled input
			            return;
			        }

			        // Find the problem by ID
			        JsonNode selectedProblem = null;
			        for (JsonNode problem : problemsArray) {
			            if (problem.get("problemID").asText().equals(problemID)) {
			                selectedProblem = problem;
			                break;
			            }
			        }

			        if (selectedProblem == null) {
			            JOptionPane.showMessageDialog(null, "Problem ID not found!");
			            return;
			        }

			        // Get the original description
			        String originalDescription = selectedProblem.get("parts").get(0).get("content").asText();

			        // Create input fields for original and modified descriptions
			        JTextArea originalDescriptionArea = new JTextArea(originalDescription);
			        originalDescriptionArea.setEditable(false);
			        originalDescriptionArea.setLineWrap(true);
			        originalDescriptionArea.setWrapStyleWord(true);

			        JTextArea newDescriptionArea = new JTextArea(originalDescription);
			        newDescriptionArea.setLineWrap(true);
			        newDescriptionArea.setWrapStyleWord(true);

			        // Wrap JTextArea in JScrollPane
			        JScrollPane originalDescriptionScrollPane = new JScrollPane(originalDescriptionArea);
			        originalDescriptionScrollPane.setPreferredSize(new Dimension(400, 200));

			        JScrollPane newDescriptionScrollPane = new JScrollPane(newDescriptionArea);
			        newDescriptionScrollPane.setPreferredSize(new Dimension(400, 200));

			        // Create a panel to hold the input fields
			        JPanel panel = new JPanel(new GridLayout(0, 1));
			        panel.add(new JLabel("Original Description:"));
			        panel.add(originalDescriptionScrollPane);
			        panel.add(new JLabel("Modify Description:"));
			        panel.add(newDescriptionScrollPane);

			        // Show the input dialog
			        int option = JOptionPane.showConfirmDialog(null, panel, "Modify Description", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);
			        if (option == JOptionPane.OK_OPTION) {
			            String newDescription = newDescriptionArea.getText();
			            modifiedDescription = newDescription;

			            // Update the problem description
			            ((ObjectNode) selectedProblem.get("parts").get(0)).put("content", newDescription);

			            // Save the updated JSON back to the file
			            try (FileWriter fileWriter = new FileWriter(new File(filePath))) {
			                fileWriter.write(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(problemsArray));
			                JOptionPane.showMessageDialog(null, "Description updated successfully!");
			            } catch (IOException ex) {
			                ex.printStackTrace();
			                JOptionPane.showMessageDialog(null, "Error saving the updated description!");
			            }
			        }
				}
		    			
			public static void problemEditor() {
		        // Load the JSON file
		        String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVAFresh.json";
		        try {
		            String content = new String(Files.readAllBytes(Paths.get(filePath)));
		            problemsArray = (ArrayNode) objectMapper.readTree(content);
		        } catch (IOException e) {
		            e.printStackTrace();
		            return;
		        }

		        // Create the main frame
		        JFrame frame = new JFrame("Problem Editor");
		        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		        frame.setSize(800, 600);

		        // Create components
		        JLabel idLabel = new JLabel("Enter Problem ID:");
		        JTextField idField = new JTextField(20);
		        JTextArea originalDescriptionArea = new JTextArea(10, 50);
		        originalDescriptionArea.setEditable(false);
		        JTextArea newDescriptionArea = new JTextArea(10, 50);
		        JButton loadButton = new JButton("Load Description");
		        JButton submitButton = new JButton("Submit");

		        // Set layout and add components using GridBagLayout
		        frame.setLayout(new GridBagLayout());
		        GridBagConstraints gbc = new GridBagConstraints();
		        gbc.insets = new Insets(5, 5, 5, 5); // Add padding between components

		        // First row - Problem ID input
		        gbc.gridx = 0;
		        gbc.gridy = 0;
		        gbc.anchor = GridBagConstraints.WEST;
		        frame.add(idLabel, gbc);

		        gbc.gridx = 1;
		        frame.add(idField, gbc);

		        gbc.gridx = 2;
		        frame.add(loadButton, gbc);

		        // Second row - Original Description label and text area
		        gbc.gridx = 0;
		        gbc.gridy = 1;
		        gbc.gridwidth = 3;
		        gbc.anchor = GridBagConstraints.CENTER;
		        frame.add(new JLabel("Original Description:"), gbc);

		        gbc.gridy = 2;
		        gbc.fill = GridBagConstraints.BOTH;
		        gbc.weightx = 1;
		        gbc.weighty = 0.5;
		        frame.add(new JScrollPane(originalDescriptionArea), gbc);

		        // Third row - Modify Description label and text area
		        gbc.gridy = 3;
		        gbc.weighty = 0;
		        frame.add(new JLabel("Modify Description:"), gbc);

		        gbc.gridy = 4;
		        gbc.weighty = 0.5;
		        frame.add(new JScrollPane(newDescriptionArea), gbc);

		        // Fourth row - Submit button
		        gbc.gridy = 5;
		        gbc.weighty = 0;
		        gbc.anchor = GridBagConstraints.CENTER;
		        frame.add(submitButton, gbc);

		        // Add action listener to the load button
		        loadButton.addActionListener(new ActionListener() {
		            @Override
		            public void actionPerformed(ActionEvent e) {
		                String problemID = idField.getText();
		                IDofproblemToModify = problemID;
		                boolean found = false;

		                // Find the problem by ID and display the original description
		                for (JsonNode problem : problemsArray) {
		                    if (problem.get("problemID").asText().equals(problemID)) {
		                        String originalDescription = problem.get("parts").get(0).get("content").asText();
		                        originalDescriptionArea.setText(originalDescription);
		                        newDescriptionArea.setText(originalDescription);
		                        found = true;
		                        break;
		                    }
		                }

		                if (!found) {
		                    JOptionPane.showMessageDialog(frame, "Problem ID not found!");
		                }
		            }
		        });

		        // Add action listener to the submit button
		        submitButton.addActionListener(new ActionListener() {
		            @Override
		            public void actionPerformed(ActionEvent e) {
		                String problemID = idField.getText();
		                String newDescription = newDescriptionArea.getText();
		                modifiedDescription = newDescription;

		                // Find the problem by ID and update the description
		                for (JsonNode problem : problemsArray) {
		                    if (problem.get("problemID").asText().equals(problemID)) {
		                        //((ArrayNode) problem.get("parts")).get(0).put("content", newDescription);
		                        ObjectNode description = (ObjectNode) problem.get("parts").get(0);
		                        description.put("content", newDescription);
		                        break;
		                    }
		                }

		                // Save the updated JSON back to the file
		                try (FileWriter fileWriter = new FileWriter(new File(filePath))) {
		                    fileWriter.write(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(problemsArray));
		                } catch (IOException ex) {
		                    ex.printStackTrace();
		                }

		                JOptionPane.showMessageDialog(frame, "Description updated successfully!");
		            }
		        });

		        // Show the frame
		        frame.setVisible(true);
		    }
		

	
	// Adding Nell Dale java problems to the test suite
		//@MakeSeed
		//public void JavaBookByNellDale() throws IOException {
		//	String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkNellDale.json";   
		//	getFeaturesOfEachProblem(filePath);
		//	getSeedsFromJSON(filePath);
		//}
	
	// Adding Herbert Schildt java problems to the test suite
	//@MakeSeed
	//public void JavaBookByHerbertSchildt() throws IOException {
		//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkHerbertSchildt.json";   
		//getFeaturesOfEachProblem(filePath);
		//getSeedsFromJSON(filePath);
	//}
		
	// Adding Liang java problems without solutions to the test suite
			//@MakeSeed
			//public void JavaBookByLiang() throws IOException {
				//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmakTextBookOnlyQuestions.json";   
				//getFeaturesOfEachProblem(filePath);
				//getSeedsFromJSON(filePath);
	//}	
		
	@MakeSeed
	public void EnterTestCases(){
		
		String promptTwo = "";
		TestCase<String, String> tc;
		String programLanguage;
	    List<String> problemSections = new ArrayList<>();
	    String problemSection;
	    String moreSection;
	    String programLanguageTwo;
	    String enterProblemID;
	    String problemSource;
	    String problemTopic;
	    String problemTitle;
	    
		while (true) {
			tc = new TestCase<String, String>();
			problemSection = JOptionPane.showInputDialog("Enter a problem section: ");
			problemSections.add(problemSection);
			promptTwo = promptTwo + " " + problemSection;
			
			moreSection = JOptionPane.showInputDialog("Do you have more problem sections (yes/no)? ");
			if (moreSection.equals("no")) {
                break; // User does not want to add more sections.
            }
		}
		programLanguageTwo = JOptionPane.showInputDialog("Enter the program language: ");
		//problemSource = JOptionPane.showInputDialog("Enter the source of the Problem: ");
		//problemTopic = JOptionPane.showInputDialog("Enter the topic of the Problem: ");
		//problemTitle = JOptionPane.showInputDialog("Enter the Problem Title: ");
		promptTwo = promptTwo + " The programming language is " + programLanguageTwo + ".";
		//enterProblemID = JOptionPane.showInputDialog("Enter the ID: ");
		UUID newId = UUID.randomUUID();
		enterProblemID = newId.toString();
		promptTwo = promptTwo + "." + " Problem Id is : " + enterProblemID + ".";
		
		String freshEntry = JOptionPane.showInputDialog("Is it a fresh entry? (yes/no): ");
		if (freshEntry.equalsIgnoreCase("yes")) {
			version = "v1.0";
		}
        if (freshEntry.equalsIgnoreCase("no")) {
            String lastVersion = JOptionPane.showInputDialog("Enter the last version : ");
                        
            String majorChanges = JOptionPane.showInputDialog("Are there major changes? (yes/no): ");

            if (majorChanges.equalsIgnoreCase("yes")) {
                version = incrementMajorVersion(lastVersion);
            } else {
                version = incrementMinorVersion(lastVersion);
            }
        }      
        
		tc.input = promptTwo;
	    tc.feature = TestDataFeature.original;
	    tc.setType("ProgrammingProblem");
	    tc.id = enterProblemID;
	    testSuite.addTestCase(tc);	
			
	}
	
	// Function to increment the major version (e.g., v1.1 to v2.0)
    private static String incrementMajorVersion(String version) {
        String[] parts = version.split("\\.");
        int major = Integer.parseInt(parts[0].substring(1)); // Extract major version
        return "v" + (major + 1) + ".0";
    }

    // Function to increment the minor version (e.g., v1.1 to v1.2)
    private static String incrementMinorVersion(String version) {
        String[] parts = version.split("\\.");
        int major = Integer.parseInt(parts[0].substring(1)); // Extract major version
        int minor = Integer.parseInt(parts[1]);
        return "v" + major + "." + (minor + 1);
    }
    
    @TestSetFilter
    public static void removeTestCases() {
        // List to store test cases to be removed
        List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
        
        // Ask for the number of test cases to remove using JOptionPane
        String noToRemove = JOptionPane.showInputDialog(null, "Enter number of test cases to remove from the beginning of the TestSuite (e.g., 3):", "Enter Number", JOptionPane.QUESTION_MESSAGE);

        // Parse the input to an integer
        int toRemove = 0;
        try {
            toRemove = Integer.parseInt(noToRemove);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input");            
        }

        // Iterate through the first 50 test cases in the test suite
        for (int i = 0; i < toRemove && i < testSuite.testSet.size(); i++) {
            // Add the test case to the list of test cases to be removed
            toBeRemovedTCs.add(testSuite.testSet.get(i));
        }

        // Remove all test cases that were added to the list of test cases to be removed
        testSuite.removeAllTestCases(toBeRemovedTCs);
    }   
    
    @TestSetFilter
    public static void filterLongTestCases() {
        // List to store test cases to be removed
        List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
        
        // Ask for the number of test cases to remove using JOptionPane
        String noToRemove = JOptionPane.showInputDialog(null, "Enter the size of test cases to remove from the TestSuite (e.g., 3):", "Enter Number", JOptionPane.QUESTION_MESSAGE);
        
        // Parse the input to an integer
        int toRemove = 0;
        if (noToRemove != null) {
            try {
                toRemove = Integer.parseInt(noToRemove);
            } catch (NumberFormatException e) {
                JOptionPane.showMessageDialog(null, "Invalid input. Please enter a valid number.", "Error", JOptionPane.ERROR_MESSAGE);
                return; // Exit the method on invalid input
            }
        } else {
            JOptionPane.showMessageDialog(null, "No input provided.", "Error", JOptionPane.ERROR_MESSAGE);
            return; // Exit the method if input is null
        }

        // Iterate through the first 'toRemove' test cases in the test suite
        for (int i = 0; i < testSuite.testSet.size(); i++) {
        	TestCase<String, String> x = testSuite.testSet.get(i);
        	String text = x.input;
        	String[] words = text.trim().split("\\s+");
            if(words.length > toRemove) {
            	// Add the test case to the list of test cases to be removed
                toBeRemovedTCs.add(testSuite.testSet.get(i));
            }            
        }
        // Remove all test cases that were added to the list of test cases to be removed
        testSuite.removeAllTestCases(toBeRemovedTCs);
    }

    
    @TestSetFilter
    public void filterBySource() {
        // Create a set to store all unique sources from the test suite
        Set<String> allFetchedSources = new HashSet<>();

        // Populate the set with unique sources from the test suite
        for (TestCase<String, String> testCase : testSuite.testSet) {
            String id = testCase.id;
            String sourceType = IDProblemSource.get(id);

            if (sourceType != null) {
                allFetchedSources.add(sourceType);  // Store unique sources
            }
        }

        // Show a dropdown (JComboBox) to select a source
        String selectedSource = showCustomInputDialogThree(allFetchedSources);

        if (selectedSource != null) {  // If a source was selected
            // Collect test cases that don't match the selected source
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
            for (TestCase<String, String> testCase : testSuite.testSet) {
                String id = testCase.id;
                String sourceType = IDProblemSource.get(id);

                if (!selectedSource.equals(sourceType)) {
                    toBeRemovedTCs.add(testCase);  // Mark for removal
                }
            }

            // Remove all test cases that don't match the selected source
            testSuite.removeAllTestCases(toBeRemovedTCs);
        }
    }

    private String showCustomInputDialogThree(Set<String> sources) {
        JPanel panel = new JPanel();
        panel.add(new JLabel("Select a source:"));

        // Create a JComboBox with the set of unique sources
        JComboBox<String> sourceComboBox = new JComboBox<>(sources.toArray(new String[0]));
        panel.add(sourceComboBox);

        // Display the input dialog with the JComboBox
        int result = JOptionPane.showConfirmDialog(null, panel, "Select Source",
                JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

        if (result == JOptionPane.OK_OPTION) {
            return (String) sourceComboBox.getSelectedItem();  // Return the selected source
        } else {
            return null;  // If user cancels or closes the dialog
        }
    }
    
    
    //@TestSetFilter
    public void filterBySourceTwo() {
    	List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();

        // Create JTextFields for user input
        JTextField source = new JTextField();
        //JTextField endingYearField = new JTextField();

        // Prompt the user for input using JOptionPane
        Object[] message = {
                "Enter Source Name:", source
        };

        int option = JOptionPane.showConfirmDialog(null, message, "Source Name", JOptionPane.OK_CANCEL_OPTION);

        if (option == JOptionPane.OK_OPTION) {
            String sourceGiven = source.getText();
            
            for (int i = 0; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> x = testSuite.testSet.get(i);
                String id = x.id;
                String sourceType = IDProblemSource.get(id);
                sourceGiven = sourceGiven.toLowerCase().replace(" ", "");
                sourceType = sourceType.toLowerCase().replace(" ", "");

                if (!sourceGiven.equals(sourceType)) {
                    toBeRemovedTCs.add(x);
                }
            }

            testSuite.removeAllTestCases(toBeRemovedTCs);
        }
    }
    
    @TestSetFilter
    public void filterByYears() {
        List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();

        // Create JTextFields for user input
        JTextField startingYearField = new JTextField();
        JTextField endingYearField = new JTextField();

        // Prompt the user for input using JOptionPane
        Object[] message = {
                "Enter starting year:", startingYearField,
                "Enter ending year:", endingYearField
        };

        int option = JOptionPane.showConfirmDialog(null, message, "Custom Year Range", JOptionPane.OK_CANCEL_OPTION);

        if (option == JOptionPane.OK_OPTION) {
            int startingYear = Integer.parseInt(startingYearField.getText());
            int endingYear = Integer.parseInt(endingYearField.getText());

            for (int i = 0; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> x = testSuite.testSet.get(i);
                String id = x.id;
                String year = IDYear.get(id);
                int currentYear = Integer.valueOf(year);

                if (currentYear < startingYear || currentYear > endingYear) {
                    toBeRemovedTCs.add(x);
                }
            }

            testSuite.removeAllTestCases(toBeRemovedTCs);
        }
    }
    
    // filter test cases based on year and topic///////////////////////
    //@TestSetFilter
    public void filterStackOverflowQueriesBetweenCustomYearsandTopic() {
        List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();

        // Create JTextFields for user input
        JTextField Year = new JTextField();
        JTextField topic = new JTextField();

        // Prompt the user for input using JOptionPane
        Object[] message = {
                "Enter year:", Year,
                "Enter topic:", topic
        };

        int option = JOptionPane.showConfirmDialog(null, message, "Custom Year Range", JOptionPane.OK_CANCEL_OPTION);

        if (option == JOptionPane.OK_OPTION) {
            int year = Integer.parseInt(Year.getText());
            String topi = topic.getText();

            for (int i = 0; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> x = testSuite.testSet.get(i);
                String id = x.id;
                String yearr = IDYear.get(id);
                List<String> topics = IDIncludedTopics.get(id);
                int currentYear = Integer.valueOf(yearr);

                // Concatenate all topics into one string with a delimiter
                String allTopics = String.join(" ", topics).toLowerCase();

                // Check if the user input topic is contained within the concatenated topics string
                if (currentYear != year && !allTopics.contains(topi)) {
                    toBeRemovedTCs.add(x);
                }
            }

            testSuite.removeAllTestCases(toBeRemovedTCs);
        }
    }
    
	// Filtering some specific test cases based on ids
    @TestSetFilter
    public static void removeTestCasesByIds() {
        // Create a JTextField for user input
        JTextField idsInput = new JTextField();

        // Prompt the user to enter IDs separated by commas using JOptionPane
        Object[] message = {
                "Enter IDs (separated by commas):", idsInput
        };

        int option = JOptionPane.showConfirmDialog(null, message, "Enter Test Case IDs", JOptionPane.OK_CANCEL_OPTION);

        if (option == JOptionPane.OK_OPTION) {
            // Parse user input to extract IDs separated by commas
            String input = idsInput.getText();
            String[] idArray = input.split(",");
            Set<String> idsToRemove = new HashSet<>();

            // Add each ID to the set of IDs to remove
            for (String id : idArray) {
                idsToRemove.add(id.trim()); // Trim to remove leading/trailing whitespaces
            }

            // List to store test cases to be removed
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();

            for (String id : idsToRemove) {
                // Iterate through the test cases in the test suite
                for (int i = 0; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> x = testSuite.testSet.get(i);

                    // Check if the current test case ID matches the ID to remove
                    if (x.id.equals(id)) {
                        // If there is a match, add the test case to the list of test cases to be removed
                        toBeRemovedTCs.add(x);
                        // No need to continue searching for this ID, move to the next ID
                        break;
                    }
                }
            }

            // Remove all test cases that were added to the list of test cases to be removed
            testSuite.removeAllTestCases(toBeRemovedTCs);
        }
    }  
    
    
    @TestSetFilter
    public static void keepTestCasesByIds() {
        // Create a JTextField for user input
        JTextField idsInput = new JTextField();

        // Prompt the user to enter IDs separated by commas using JOptionPane
        Object[] message = {
                "Enter IDs (separated by commas):", idsInput
        };

        int option = JOptionPane.showConfirmDialog(null, message, "Enter Test Case IDs", JOptionPane.OK_CANCEL_OPTION);

        if (option == JOptionPane.OK_OPTION) {
            // Parse user input to extract IDs separated by commas
            String input = idsInput.getText();
            String[] idArray = input.split(",");
            Set<String> idsToKeep = new HashSet<>();

            // Add each ID to the set of IDs to keep
            for (String id : idArray) {
                idsToKeep.add(id.trim()); // Trim to remove leading/trailing whitespaces
            }

            // List to store test cases to remove
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();

            // Iterate through the test cases in the test suite
            for (TestCase<String, String> testCase : testSuite.testSet) {
                if (!idsToKeep.contains(testCase.id)) {
                    // Add test cases not in idsToKeep to the list for removal
                    toBeRemovedTCs.add(testCase);
                }
            }

            // Remove all test cases that are not in the set of IDs to keep
            testSuite.removeAllTestCases(toBeRemovedTCs);

            System.out.println("Test suite updated. Retained test cases with IDs: " + idsToKeep);
        }
    }

    
    
 	
	// Filtering Stack Overflow java problems based on one topic given by users
		//@TestSetFilter
		public void filterQueriesOnOneTopic() {
		    Set<String> allFetchedTopics = new HashSet<>(); // Use a Set instead of a List

		    for (int i = 0; i < testSuite.testSet.size(); i++) {
		        TestCase<String, String> x = testSuite.testSet.get(i);
		        String id = x.id;

		        // Use the get method to fetch the included topics based on the ID
		        List<String> topics = IDIncludedTopics.get(id);

		        if (topics != null) {
		            // Add the fetched topics to the set (automatically ensures uniqueness)
		            allFetchedTopics.addAll(topics);
		        }

		        // Perform other actions based on topics if needed...
		    }

		    // Now, 'allFetchedTopics' contains all the distinct included topics for all test cases

		    // Convert the set to a string representation
		    String topicsString = String.join("\n", allFetchedTopics);

		    // Create and display the JFrame with JTextArea
		    JTextArea textArea = new JTextArea(topicsString);
		    JFrame frame = new JFrame("Topics covered by the test suite");
		    frame.add(new JScrollPane(textArea));
		    frame.setSize(700, 600);
		    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		    frame.setVisible(true);
		    // Show input dialog to select a topic
	        String selectedTopic = showCustomInputDialog(allFetchedTopics);

	        // Now 'selectedTopic' contains the topic selected by the user
	        System.out.println("Selected Topic: " + selectedTopic);
	        
	        // Keeping all the queries on selected topic while removing queries of all other topics
	        List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<TestCase<String, String>>();
	        for (int i = 0; i < testSuite.testSet.size(); i++) {
	            TestCase<String, String> x = testSuite.testSet.get(i);
	            String id = x.id;
	            // Use the get method to fetch the included topics based on the ID
		        List<String> topics = IDIncludedTopics.get(id);

		        if (topics != null) {
		            // Checking for a match between selected topic and includedTopics of each query
		        	if(!topics.contains(selectedTopic)) {
		        		toBeRemovedTCs.add(x);
		        	}
		        }                          
	    }
	        testSuite.removeAllTestCases(toBeRemovedTCs);
	    }

	    private String showCustomInputDialog(Set<String> topics) {
	        JPanel panel = new JPanel();
	        panel.add(new JLabel("Select a topic:"));

	        // Create a JComboBox with the topics
	        JComboBox<String> topicComboBox = new JComboBox<>(topics.toArray(new String[0]));
	        panel.add(topicComboBox);

	        // Show the input dialog
	        int result = JOptionPane.showConfirmDialog(null, panel, "Select Topic",
	                JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

	        // If the user clicked OK, return the selected topic; otherwise, return null
	        if (result == JOptionPane.OK_OPTION) {
	            return (String) topicComboBox.getSelectedItem();
	        } else {
	            return null;
	        }
	    }
	    
	 // Filtering Stack Overflow java problems based on multiple topics given by users
 		@TestSetFilter
 		public void filterByTopic() {
 	        Set<String> allFetchedTopics = new HashSet<>(); // Use a Set instead of a List

 	        for (int i = 0; i < testSuite.testSet.size(); i++) {
 	            TestCase<String, String> x = testSuite.testSet.get(i);
 	            String id = x.id;

 	            // Use the get method to fetch the included topics based on the ID
 	            List<String> topics = IDIncludedTopics.get(id);

 	            if (topics != null) {
 	                // Add the fetched topics to the set (automatically ensures uniqueness)
 	                allFetchedTopics.addAll(topics);
 	            }

 	        }

 	        // Now, 'allFetchedTopics' contains all the distinct included topics for all test cases

 	        // Create an array of topics for the JList
 	        String[] topicsArray = allFetchedTopics.toArray(new String[0]);

 	        // Create a JList with the topics array
 	        JList<String> topicsList = new JList<>(topicsArray);

 	        // Create a JScrollPane for the JList
 	        JScrollPane scrollPane = new JScrollPane(topicsList);

 	        // Show the input dialog with the JList
 	        int result = JOptionPane.showConfirmDialog(null, scrollPane, "Select Topics",
 	                JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

 	        // If the user clicked OK, get the selected topics from the JList and extract test cases for those topics
 	        if (result == JOptionPane.OK_OPTION) {
 	            // Get the selected indices from the JList
 	            int[] selectedIndices = topicsList.getSelectedIndices();
 	            Set<String> selectedTopics = new HashSet<>();
 	            // Add the selected topics to the set
 	            for (int index : selectedIndices) {
 	                selectedTopics.add(topicsArray[index]);
 	            }

 	            // Keeping all the queries on selected topics while removing queries of all other topics
 	            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
 	            for (TestCase<String, String> x : testSuite.testSet) {
 	                String id = x.id;
 	                // Use the get method to fetch the included topics based on the ID
 	                List<String> topics = IDIncludedTopics.get(id);

 	               String allTopics = String.join(", ", topics);
		            String selectedTopicss = String.join(",", selectedTopics);

		           if (topics != null) {
			            // Checking for a match between selected topic and includedTopics of each query
			        	if(!allTopics.contains(selectedTopicss)) {
			        		toBeRemovedTCs.add(x);
			        	}
			        } 
 	            }
 	            testSuite.removeAllTestCases(toBeRemovedTCs);
 	        }
 	    }

 		private Set<String> showCustomInputDialogThree() {
 		    JPanel panel = new JPanel();
 		    panel.setLayout(new BorderLayout());
 		    panel.add(new JLabel("Enter topics separated by commas:"), BorderLayout.NORTH);

 		    // Create a JTextArea for entering topics
 		    JTextArea topicsTextArea = new JTextArea(5, 20);
 		    JScrollPane scrollPane = new JScrollPane(topicsTextArea);
 		    panel.add(scrollPane, BorderLayout.CENTER);

 		    // Show the input dialog
 		    int result = JOptionPane.showConfirmDialog(null, panel, "Enter Topics",
 		            JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

 		    // If the user clicked OK, parse the topics from the JTextArea and return as a set; otherwise, return null
 		    if (result == JOptionPane.OK_OPTION) {
 		        String topicsString = topicsTextArea.getText();
 		        String[] topicsArray = topicsString.split(",");
 		        Set<String> topicsSet = new HashSet<>(Arrays.asList(topicsArray));
 		        return topicsSet;
 		    } else {
 		        return null;
 		    }
 		}
	    
	    // Filtering Stack Overflow java problems based on multiple topics given by users
	 		//@TestSetFilter
	 		public void filterQueriesOnMultipleTopicsTwo() {
	 		    // Show the custom input dialog to get topics from the user
	 		    Set<String> selectedTopics = showCustomInputDialog();

	 		    if (selectedTopics != null && !selectedTopics.isEmpty()) {
	 		        // List to keep track of test cases to be removed
	 		        List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();

	 		        // Iterate over the test cases and determine which to keep based on the selected topics
	 		        for (TestCase<String, String> testCase : testSuite.testSet) {
	 		            String id = testCase.id;
	 		            List<String> topics = IDIncludedTopics.get(id);
	 		            String allTopics = String.join(", ", topics);
	 		            String selectedTopicss = String.join(",", selectedTopics);

	 		           if (topics != null) {
	 			            // Checking for a match between selected topic and includedTopics of each query
	 			        	if(!allTopics.contains(selectedTopicss)) {
	 			        		toBeRemovedTCs.add(testCase);
	 			        	}
	 			        } 
	 		        }

	 		        // Remove the test cases that don't match any of the selected topics
	 		        testSuite.removeAllTestCases(toBeRemovedTCs);
	 		    } else {
	 		        JOptionPane.showMessageDialog(null, "No valid topics provided. Please try again.");
	 		    }
	 		}


	 	    // Custom input dialog to get topics from the user
	 	    private Set<String> showCustomInputDialog() {
	 	        JPanel panel = new JPanel();
	 	        panel.setLayout(new BorderLayout());

	 	        // Add a label and text area for entering topics
	 	        panel.add(new JLabel("Enter topics separated by commas:"), BorderLayout.NORTH);

	 	        JTextArea topicsTextArea = new JTextArea(5, 20);
	 	        JScrollPane scrollPane = new JScrollPane(topicsTextArea);
	 	        panel.add(scrollPane, BorderLayout.CENTER);

	 	        // Show the input dialog to get user input
	 	        int result = JOptionPane.showConfirmDialog(null, panel, "Enter Topics", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

	 	        if (result == JOptionPane.OK_OPTION) {
	 	            String topicsString = topicsTextArea.getText();

	 	            // Validate and extract topics
	 	            if (topicsString.trim().isEmpty()) {
	 	                return null; // No topics provided
	 	            }

	 	            // Split the topics by commas and trim whitespace
	 	            String[] topicsArray = topicsString.trim().split(",");
	 	            Set<String> topicsSet = new HashSet<>();

	 	            for (String topic : topicsArray) {
	 	                topicsSet.add(topic.trim()); // Add each topic to the set after trimming
	 	            }

	 	            return topicsSet; // Return the unique set of topics
	 	        }

	 	        return null; // Return null if the dialog was canceled or invalid input
	 	    }

	    
	        // Filtering w3resource java problems based on complexities
	 		@TestSetFilter
	 		public void filterByComplexity() {
	 		    Set<String> allFetchedComplexities = new HashSet<>();

	 		    for (int i = 0; i < testSuite.testSet.size(); i++) {
	 		        TestCase<String, String> x = testSuite.testSet.get(i);
	 		        String id = x.id;

	 		        // Use the get method to fetch the complexity based on the ID
	 		        String complexity = IDComplexity.get(id);

	 		        if (complexity != null) {
	 		            // Add the fetched complexity to the set (automatically ensures uniqueness)
	 		            allFetchedComplexities.add(complexity);
	 		        }

	 		        // Perform other actions based on complexity if needed...
	 		    }

	 		    // Now, 'allFetchedComplexities' contains all the distinct complexities for all test cases

	 		    // Convert the set to a string representation
	 		    String complexitiesString = String.join("\n", allFetchedComplexities);

	 		    // Create and display the JFrame with JTextArea
	 		    JTextArea textArea = new JTextArea(complexitiesString);
	 		    JFrame frame = new JFrame("Complexities covered by the test suite");
	 		    frame.add(new JScrollPane(textArea));
	 		    frame.setSize(700, 600);
	 		    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	 		    frame.setVisible(true);

	 		    // Show input dialog to select a complexity
	 		    String selectedComplexity = showCustomInputDialogTwo(allFetchedComplexities);

	 		    // Now 'selectedComplexity' contains the complexity selected by the user
	 		    System.out.println("Selected Complexity: " + selectedComplexity);

	 		    // Keeping all the queries on selected complexity while removing queries of all other complexities
	 		    List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
	 		    for (int i = 0; i < testSuite.testSet.size(); i++) {
	 		        TestCase<String, String> x = testSuite.testSet.get(i);
	 		        String id = x.id;

	 		        // Use the get method to fetch the complexity based on the ID
	 		        String complexity = IDComplexity.get(id);

	 		        if (complexity != null) {
	 		            // Checking for a match between selected complexity and the complexity of each query
	 		            if (!complexity.equals(selectedComplexity)) {
	 		                toBeRemovedTCs.add(x);
	 		            }
	 		        }
	 		    }

	 		    testSuite.removeAllTestCases(toBeRemovedTCs);
	 		}


	 		private String showCustomInputDialogTwo(Set<String> complexities) {
	 		    JPanel panel = new JPanel();
	 		    panel.add(new JLabel("Select a complexity:"));

	 		    // Create a JComboBox with the complexities
	 		    JComboBox<String> complexityComboBox = new JComboBox<>(complexities.toArray(new String[0]));
	 		    panel.add(complexityComboBox);

	 		    // Show the input dialog
	 		    int result = JOptionPane.showConfirmDialog(null, panel, "Select Complexity",
	 		            JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

	 		    // If the user clicked OK, return the selected complexity; otherwise, return null
	 		    if (result == JOptionPane.OK_OPTION) {
	 		        return (String) complexityComboBox.getSelectedItem();
	 		    } else {
	 		        return null;
	 		    }
	 		}
	 		
	 		@TestExecuter
	 		public static String LLama2(String problem) throws FileNotFoundException, IOException {
	 			String sentenceWithProblemID = "";
	 			String problemID = "";
	 			    
	 			// Load the sentence detection model
	 		    SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
	 		    SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

	 		    // Split the problem into sentences
	 		    String[] sentences = sentenceDetector.sentDetect(problem);

	 		    // Check if there are sentences
	 		    if (sentences.length > 0) {
	 		        // Extract the last sentence
	 		        sentenceWithProblemID = sentences[sentences.length - 1];
	 		            
	 		        // Use regular expression to extract "problemID"
	 		        problemID = extractProblemID(sentenceWithProblemID);
	 		        currentProblemID = problemID;
	 		        //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
	 		        givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
	 		    }
	 		    
	 		    if(givenSolutionOfCurrentTestCase == null) {
	 	        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
	 	        }
	 		    
	 			String url = "https://colab.research.google.com/drive/1hEoM-nPtycufABxKb0zO56WAtEFZ-7_x";
	 	        try {
	 	            openWebpage(url);
	 	        } catch (IOException e) {
	 	            e.printStackTrace();
	 	        }
	 	        
	 	        // Path to Code.exe on your system
	 	        String vsCodePath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe";

	 	        // Path with the actual path to Java file
	 	        String javaFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\copilotTest.java";

	 	        // Write the problem to a file before opening in the Github Copilot
	 	        try (BufferedWriter writer = new BufferedWriter(new FileWriter(javaFilePath, false))) {
	 	            writer.write(problem);            
	 	        } catch (IOException e) {
	 	            e.printStackTrace();
	 	        }
	 	        
	 	        try {
	 	            // Create a ProcessBuilder for Code.exe with the Java file path as an argument
	 	            ProcessBuilder processBuilder = new ProcessBuilder(vsCodePath, javaFilePath);

	 	            // Start the process
	 	            Process process = processBuilder.start();

	 	            // Wait for the process to finish
	 	            process.waitFor();

	 	            System.out.println("Visual Studio Code has been opened with the Java file.");
	 	            
	 	        } catch (IOException | InterruptedException e) {
	 	            e.printStackTrace();
	 	        }
	 	        
	 	        // Showing the problem in JTextArea
	 	        //JTextArea textArea = new JTextArea(10, 40);
	 	        //textArea.setText(problem);

	 	        // Make the JTextArea not editable
	 	        //textArea.setEditable(true);

	 	        // Wrap the JTextArea in a JScrollPane
	 	        //JScrollPane scrollPane = new JScrollPane(textArea);
	 	        
	 	        // Show the JTextArea inside a JOptionPane
	 	        //JOptionPane.showMessageDialog(null, scrollPane, "JTextArea in JOptionPane", JOptionPane.INFORMATION_MESSAGE);
	 	        
	 	        // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
	 	        if (!filePathForCodeAnalysis.isEmpty()) {
	 	        	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
	 	            filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
	 	            // Clear the list to make it empty.
	 	            filePathForCodeAnalysis.clear();
	 	        }
	 	        
	 	        String newVersion = version.replace(".", "_");
	 	        newVersion = newVersion.replace("v", "Version"); //
	 	        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
	 	    	folderPath = folderPath.concat(problemID);
	 	        String s = "generatedProgram";
	 	    	s = s.concat("1").concat("Of").concat(newVersion).concat(".java");
	 	    	String newFolderPath = folderPath.concat("\\");
	 	    	String filePath = newFolderPath.concat(s);
	 	    	
	 	    	filePathForCodeAnalysis.add(filePath);
	 	    	
	 	    	
	 	    	try {
	 	    	isGeneratedCodeCompilable();
	 	        PMDCodeAnalyzerForComplexityOnGeneratedCode();
	 	        PMDCodeAnalyzerForComplexityOnGivenSolution();
	 		    }catch (Exception e) {
	 	        // Handle the exception if needed
	 	        System.out.println("An exception occurred: " + e.getMessage());
	 	        }
	 			return null;
	 			
	 		}
	 		
	 		//@TestExecuter
	 		public static String LLama2Paraphrase(String problem) throws FileNotFoundException, IOException {
	 			String sentenceWithProblemID = "";
	 			String problemID = "";
	 			    
	 			// Load the sentence detection model
	 		    SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
	 		    SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

	 		    // Split the problem into sentences
	 		    String[] sentences = sentenceDetector.sentDetect(problem);

	 		    // Check if there are sentences
	 		    if (sentences.length > 0) {
	 		        // Extract the last sentence
	 		        sentenceWithProblemID = sentences[sentences.length - 1];
	 		            
	 		        // Use regular expression to extract "problemID"
	 		        problemID = extractProblemID(sentenceWithProblemID);
	 		        currentProblemID = problemID;
	 		        //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
	 		        givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
	 		    }
	 		    
	 		    if(givenSolutionOfCurrentTestCase == null) {
	 	        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
	 	        }
	 		    
	 			String url = "https://colab.research.google.com/drive/1hEoM-nPtycufABxKb0zO56WAtEFZ-7_x";
	 	        try {
	 	            openWebpage(url);
	 	        } catch (IOException e) {
	 	            e.printStackTrace();
	 	        }
	 	        
	 	        // Path to Code.exe on your system
	 	        String vsCodePath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe";

	 	        // Path with the actual path to Java file
	 	        String javaFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\copilotTest.java";

	 	        // Write the problem to a file before opening in the Github Copilot
	 	        try (BufferedWriter writer = new BufferedWriter(new FileWriter(javaFilePath, false))) {
	 	            writer.write(problem);            
	 	        } catch (IOException e) {
	 	            e.printStackTrace();
	 	        }
	 	        
	 	        try {
	 	            // Create a ProcessBuilder for Code.exe with the Java file path as an argument
	 	            ProcessBuilder processBuilder = new ProcessBuilder(vsCodePath, javaFilePath);

	 	            // Start the process
	 	            Process process = processBuilder.start();

	 	            // Wait for the process to finish
	 	            process.waitFor();

	 	            System.out.println("Visual Studio Code has been opened with the Java file.");
	 	            
	 	        } catch (IOException | InterruptedException e) {
	 	            e.printStackTrace();
	 	        }
	 	        
	 	        // Showing the problem in JTextArea
	 	        //JTextArea textArea = new JTextArea(10, 40);
	 	        //textArea.setText(problem);

	 	        // Make the JTextArea not editable
	 	        //textArea.setEditable(true);

	 	        // Wrap the JTextArea in a JScrollPane
	 	        //JScrollPane scrollPane = new JScrollPane(textArea);
	 	        
	 	        // Show the JTextArea inside a JOptionPane
	 	        //JOptionPane.showMessageDialog(null, scrollPane, "JTextArea in JOptionPane", JOptionPane.INFORMATION_MESSAGE);
	 	        
	 	        // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
	 	        if (!filePathForCodeAnalysis.isEmpty()) {
	 	        	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
	 	            filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
	 	            // Clear the list to make it empty.
	 	            filePathForCodeAnalysis.clear();
	 	        }
	 	        
	 	        String newVersion = version.replace(".", "_");
	 	        newVersion = newVersion.replace("v", "Version"); //
	 	        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
	 	    	folderPath = folderPath.concat(problemID);
	 	        String s = "generatedProgram";
	 	    	s = s.concat("1").concat("Of").concat(newVersion).concat(".java");
	 	    	String newFolderPath = folderPath.concat("\\");
	 	    	String filePath = newFolderPath.concat(s);
	 	    	
	 	    	filePathForCodeAnalysis.add(filePath);
	 			return null;
	 			
	 		}
	 		
	@TestExecuter
	public static String Falcon7B(String problem) throws FileNotFoundException, IOException {
		String sentenceWithProblemID = "";
		String problemID = "";
		    
		// Load the sentence detection model
	    SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
	    SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

	    // Split the problem into sentences
	    String[] sentences = sentenceDetector.sentDetect(problem);

	    // Check if there are sentences
	    if (sentences.length > 0) {
	        // Extract the last sentence
	        sentenceWithProblemID = sentences[sentences.length - 1];
	            
	        // Use regular expression to extract "problemID"
	        problemID = extractProblemID(sentenceWithProblemID);
	        currentProblemID = problemID;
	        //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
	        givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
	    }
	    
	    if(givenSolutionOfCurrentTestCase == null) {
        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
        }
	    
		String url = "https://colab.research.google.com/drive/1dT8_dYxx7HmJdshep9KWSYIEjhZqTnhR#scrollTo=0OCtROMBfgWV";
        try {
            openWebpage(url);
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // Path to Code.exe on your system
        String vsCodePath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe";

        // Path with the actual path to Java file
        String javaFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\copilotTest.java";

        // Write the problem to a file before opening in the Github Copilot
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(javaFilePath, false))) {
            writer.write(problem);            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        try {
            // Create a ProcessBuilder for Code.exe with the Java file path as an argument
            ProcessBuilder processBuilder = new ProcessBuilder(vsCodePath, javaFilePath);

            // Start the process
            Process process = processBuilder.start();

            // Wait for the process to finish
            process.waitFor();

            System.out.println("Visual Studio Code has been opened with the Java file.");
            
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
        
        // Showing the problem in JTextArea
        //JTextArea textArea = new JTextArea(10, 40);
        //textArea.setText(problem);

        // Make the JTextArea not editable
        //textArea.setEditable(true);

        // Wrap the JTextArea in a JScrollPane
        //JScrollPane scrollPane = new JScrollPane(textArea);
        
        // Show the JTextArea inside a JOptionPane
        //JOptionPane.showMessageDialog(null, scrollPane, "JTextArea in JOptionPane", JOptionPane.INFORMATION_MESSAGE);
        
        // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
        if (!filePathForCodeAnalysis.isEmpty()) {
        	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
            filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
            // Clear the list to make it empty.
            filePathForCodeAnalysis.clear();
        }
        
        String newVersion = version.replace(".", "_");
        newVersion = newVersion.replace("v", "Version"); //
        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
    	folderPath = folderPath.concat(problemID);
        String s = "generatedProgram";
    	s = s.concat("1").concat("Of").concat(newVersion).concat(".java");
    	String newFolderPath = folderPath.concat("\\");
    	String filePath = newFolderPath.concat(s);
    	
    	filePathForCodeAnalysis.add(filePath);
    	
    	
    	try {
    	isGeneratedCodeCompilable();
        PMDCodeAnalyzerForComplexityOnGeneratedCode();
        PMDCodeAnalyzerForComplexityOnGivenSolution();
	    }catch (Exception e) {
        // Handle the exception if needed
        System.out.println("An exception occurred: " + e.getMessage());
        }
		return null;
		
	}
	
	public static String Falcon7BParaphrase(String problem) throws FileNotFoundException, IOException {
		String sentenceWithProblemID = "";
		String problemID = "";
		    
		// Load the sentence detection model
	    SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
	    SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

	    // Split the problem into sentences
	    String[] sentences = sentenceDetector.sentDetect(problem);

	    // Check if there are sentences
	    if (sentences.length > 0) {
	        // Extract the last sentence
	        sentenceWithProblemID = sentences[sentences.length - 1];
	            
	        // Use regular expression to extract "problemID"
	        problemID = extractProblemID(sentenceWithProblemID);
	        currentProblemID = problemID;
	        //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
	        givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
	    }
	    
	    if(givenSolutionOfCurrentTestCase == null) {
        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
        }
	    
		String url = "https://colab.research.google.com/drive/1dT8_dYxx7HmJdshep9KWSYIEjhZqTnhR#scrollTo=0OCtROMBfgWV";
        try {
            openWebpage(url);
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // Path to Code.exe on your system
        String vsCodePath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe";

        // Path with the actual path to Java file
        String javaFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\copilotTest.java";

        // Write the problem to a file before opening in the Github Copilot
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(javaFilePath, false))) {
            writer.write(problem);            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        try {
            // Create a ProcessBuilder for Code.exe with the Java file path as an argument
            ProcessBuilder processBuilder = new ProcessBuilder(vsCodePath, javaFilePath);

            // Start the process
            Process process = processBuilder.start();

            // Wait for the process to finish
            process.waitFor();

            System.out.println("Visual Studio Code has been opened with the Java file.");
            
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
        
        // Showing the problem in JTextArea
        //JTextArea textArea = new JTextArea(10, 40);
        //textArea.setText(problem);

        // Make the JTextArea not editable
        //textArea.setEditable(true);

        // Wrap the JTextArea in a JScrollPane
        //JScrollPane scrollPane = new JScrollPane(textArea);
        
        // Show the JTextArea inside a JOptionPane
        //JOptionPane.showMessageDialog(null, scrollPane, "JTextArea in JOptionPane", JOptionPane.INFORMATION_MESSAGE);
        
        // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
        if (!filePathForCodeAnalysis.isEmpty()) {
        	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
            filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
            // Clear the list to make it empty.
            filePathForCodeAnalysis.clear();
        }
        
        String newVersion = version.replace(".", "_");
        newVersion = newVersion.replace("v", "Version"); //
        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
    	folderPath = folderPath.concat(problemID);
        String s = "generatedProgram";
    	s = s.concat("1").concat("Of").concat(newVersion).concat(".java");
    	String newFolderPath = folderPath.concat("\\");
    	String filePath = newFolderPath.concat(s);
    	
    	filePathForCodeAnalysis.add(filePath);
    	
		return null;
		
	}
	
	public static void openWebpage(String url) throws IOException {
        String os = System.getProperty("os.name").toLowerCase();
        Runtime runtime = Runtime.getRuntime();
        if (os.contains("win")) {
            // Windows
            runtime.exec("rundll32 url.dll,FileProtocolHandler " + url);
        } else if (os.contains("mac")) {
            // macOS
            runtime.exec("open " + url);
        } else if (os.contains("nix") || os.contains("nux")) {
            // Unix or Linux
            runtime.exec("xdg-open " + url);
        } else {
            throw new UnsupportedOperationException("Unsupported operating system: " + os);
        }
    }
	    
	@TestExecuter
	public static String openCoPilot(String problem) throws FileNotFoundException, IOException {
		
		String sentenceWithProblemID = "";
		String problemID = "";
		    
		// Load the sentence detection model
	    SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
	    SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

	    // Split the problem into sentences
	    String[] sentences = sentenceDetector.sentDetect(problem);

	    // Check if there are sentences
	    if (sentences.length > 0) {
	        // Extract the last sentence
	        sentenceWithProblemID = sentences[sentences.length - 1];
	            
	        // Use regular expression to extract "problemID"
	        problemID = extractProblemID(sentenceWithProblemID);
	        currentProblemID = problemID;
	        //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
	        givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
	    }
	    
	    if(givenSolutionOfCurrentTestCase == null) {
        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
        }
		
        // Path to Code.exe on your system
        String vsCodePath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe";

        // Path with the actual path to Java file
        String javaFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\copilotTest.java";

        // Write the problem to a file before opening in the Github Copilot
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(javaFilePath, false))) {
            writer.write(problem);            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        try {
            // Create a ProcessBuilder for Code.exe with the Java file path as an argument
            ProcessBuilder processBuilder = new ProcessBuilder(vsCodePath, javaFilePath);

            // Start the process
            Process process = processBuilder.start();

            // Wait for the process to finish
            process.waitFor();

            System.out.println("Visual Studio Code has been opened with the Java file.");
            
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
        
        // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
        if (!filePathForCodeAnalysis.isEmpty()) {
        	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
            filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
            // Clear the list to make it empty.
            filePathForCodeAnalysis.clear();
        }
        
        String newVersion = version.replace(".", "_");
        newVersion = newVersion.replace("v", "Version"); //
        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
    	folderPath = folderPath.concat(problemID);
        String s = "generatedProgram";
    	s = s.concat("1").concat("Of").concat(newVersion).concat(".java");
    	String newFolderPath = folderPath.concat("\\");
    	String filePath = newFolderPath.concat(s);
    	
    	filePathForCodeAnalysis.add(filePath);
    	
    	
    	try {
    	isGeneratedCodeCompilable();
        PMDCodeAnalyzerForComplexityOnGeneratedCode();
        PMDCodeAnalyzerForComplexityOnGivenSolution();
	    }catch (Exception e) {
        // Handle the exception if needed
        System.out.println("An exception occurred: " + e.getMessage());
        }
        
        return null;
	}
	
	//@TestExecuter
	public static String openCoPilotParaphrase(String problem) throws FileNotFoundException, IOException {
		
		String sentenceWithProblemID = "";
		String problemID = "";
		    
		// Load the sentence detection model
	    SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
	    SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

	    // Split the problem into sentences
	    String[] sentences = sentenceDetector.sentDetect(problem);

	    // Check if there are sentences
	    if (sentences.length > 0) {
	        // Extract the last sentence
	        sentenceWithProblemID = sentences[sentences.length - 1];
	            
	        // Use regular expression to extract "problemID"
	        problemID = extractProblemID(sentenceWithProblemID);
	        currentProblemID = problemID;
	        //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
	        givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
	    }
	    
	    if(givenSolutionOfCurrentTestCase == null) {
        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
        }
		
        // Path to Code.exe on your system
        String vsCodePath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe";

        // Path with the actual path to Java file
        String javaFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\copilotTest.java";

        // Write the problem to a file before opening in the Github Copilot
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(javaFilePath, false))) {
            writer.write(problem);            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        try {
            // Create a ProcessBuilder for Code.exe with the Java file path as an argument
            ProcessBuilder processBuilder = new ProcessBuilder(vsCodePath, javaFilePath);

            // Start the process
            Process process = processBuilder.start();

            // Wait for the process to finish
            process.waitFor();

            System.out.println("Visual Studio Code has been opened with the Java file.");
            
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
        
        // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
        if (!filePathForCodeAnalysis.isEmpty()) {
        	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
            filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
            // Clear the list to make it empty.
            filePathForCodeAnalysis.clear();
        }
        
        String newVersion = version.replace(".", "_");
        newVersion = newVersion.replace("v", "Version"); //
        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
    	folderPath = folderPath.concat(problemID);
        String s = "generatedProgram";
    	s = s.concat("1").concat("Of").concat(newVersion).concat(".java");
    	String newFolderPath = folderPath.concat("\\");
    	String filePath = newFolderPath.concat(s);
    	
    	filePathForCodeAnalysis.add(filePath);        
        return null;
	}
	
	@TestExecuter
	public static String GeminiPro(String problem) throws FileNotFoundException, IOException, InterruptedException {
		String problemDescription = "";
	    String sentenceWithProblemID = "";
	    String problemID = "";
	    String output = null;
	    List<String> statement = new ArrayList<>();
        List<String> programCode = new ArrayList<>();
	    
		// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the problem into sentences
        String[] sentences = sentenceDetector.sentDetect(problem);

        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Use regular expression to extract "problemID"
            problemID = extractProblemID(sentenceWithProblemID);
            currentProblemID = problemID;
            //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
            givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = problem.substring(0, problem.lastIndexOf(sentenceWithProblemID));
        }
	    
        if(givenSolutionOfCurrentTestCase == null) {
        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
        }
        String query = problemDescription + "Can you also generate test cases including corner cases to test the program?";;
        
        // Absolute path to the Python interpreter
        String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe";

        // Absolute path to the Python script
        String pythonScriptPath = "C:\\Users\\debal\\Downloads\\code_generation_geminipro_2 (8).py";

        // Command to execute the Python script
        List<String> command = new ArrayList<>();
        command.add(pythonInterpreterPath);
        command.add(pythonScriptPath);
        command.add(query);

        try {
            // Build and start the process
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the Python script
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            StringBuilder response = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                response.append(line).append("\n");
            }

            // Display the response
            if (response.length() > 0) {
            	output = response.toString();
            	outputOfCurrentTestCase = output;
            	System.out.println(output);
                //JOptionPane.showMessageDialog(null, response.toString(), "Response", JOptionPane.INFORMATION_MESSAGE);
            } else {
                System.err.println("Error: No response generated.");
            }

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                System.err.println("Error: Python script exited with code " + exitCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        ///////////////////////////////////////
        // Now saving the code in right folder
        String[] parts = output.split("```");
        
        for(int i = 0; i < parts.length; i++) {
        	//if (parts[i].startsWith("java")) {
        	if (parts[i].startsWith("java") || parts[i].startsWith("import") || parts[i].startsWith("public")) {
        		String code = parts[i];
                // Find the index of the first newline character
                int indexOfNewline = code.indexOf('\n');
                code = code.substring(indexOfNewline + 1);
        		programCode.add(code);
        		System.out.println("Generated program code :" + parts[i]);
        	} else {
        		statement.add(parts[i]);
        		System.out.println("Comments :" + parts[i]);
        	}
        }
        
        // Create a folder with current problemID
        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
    	folderPath = folderPath.concat(problemID);
        File folder = new File(folderPath);
        if (!folder.exists()) {
            boolean created = folder.mkdirs();
            if (created) {
                System.out.println("Folder created successfully.");
            } else {
                System.out.println("Failed to create the folder.");
            }
        } else {
            System.out.println("The folder already exists.");
        }
                    
        // creating java files based on number of code snippets within the folder
        int k = 1, l = 0;
        String newVersion = version.replace(".", "_");
        newVersion = newVersion.replace("v", "Version"); //
        	            
        // Creating a text file with prettyJson
        String textFileName = newVersion.concat(".txt");
        String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
            // Write the prettyJSON to the file
            writer2.write(output);                    
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
        if (!filePathForCodeAnalysis.isEmpty()) {
        	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
            filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
            // Clear the list to make it empty.
            filePathForCodeAnalysis.clear();
        }
        
        
        for (int j = programCode.size(); j > 0; j--) {
        	String s = "generatedProgram";
        	String trail = Integer.toString(k);
        	s = s.concat(trail).concat("Of").concat(newVersion).concat(".java");
        	String newFolderPath = folderPath.concat("\\");
        	String filePath = newFolderPath.concat(s);
        	filePathForCodeAnalysis.add(filePath);
        	//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
        	//filePath = filePath.concat(s);
        	try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(filePath))) {
                // Write the code to the file
                writer2.write(programCode.get(l));
                System.out.println('\n' + "Code saved to " + filePath);
                l++;
                k++;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        // Showing the paths of filePathForCodeAnalysis
        //for (String path : filePathForCodeAnalysis) {
        //	JOptionPane.showMessageDialog(null, "Generated Code Snippet saved in " + path, "Information", JOptionPane.INFORMATION_MESSAGE);
        //   }
        
        // creating text files based on the number of comments
        int m = 1, n = 0;
        filePathForStatementAnalysis.clear();
        for (int j = statement.size(); j > 0; j--) {
        	String s = "generatedStatement";
        	String trail = Integer.toString(m);
        	s = s.concat(trail).concat("Of").concat(newVersion).concat(".txt");
        	String newFolderPath = folderPath.concat("\\");
        	String filePath = newFolderPath.concat(s);
        	filePathForStatementAnalysis.add(filePath);
        	//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
        	//filePath = filePath.concat(s);
        	try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(filePath))) {
                // Write the ChatGPT generated statement to the file
                writer2.write(statement.get(n));
                System.out.println('\n' + "Statement saved to " + filePath);
                m++;
                n++;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        // Showing the paths of filePathForStatementAnalysis
        //for (String path : filePathForStatementAnalysis) {
        //	JOptionPane.showMessageDialog(null, "Generated Statements saved in " + path, "Information", JOptionPane.INFORMATION_MESSAGE);
        //   }
        	            
        try {
        isGeneratedCodeCompilable();
        PMDCodeAnalyzerForComplexityOnGeneratedCode();
        PMDCodeAnalyzerForComplexityOnGivenSolution();   
        }catch (Exception e) {
            // Handle the exception if needed
            System.out.println("An exception occurred: " + e.getMessage());
        }
                    
        //JTextArea textArea = new JTextArea(prettyJson);
    	//JFrame frame = new JFrame("Message");
    	//frame.add(new JScrollPane(textArea));
    	//frame.setSize(700, 600);
    	//frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    	//frame.setVisible(true); 
       
        
		return output;	
	}
	
	//@TestExecuter
	public static String GeminiProParaphrase(String problem) throws FileNotFoundException, IOException, InterruptedException {
		String problemDescription = "";
	    String sentenceWithProblemID = "";
	    String problemID = "";
	    String output = null;
	    List<String> statement = new ArrayList<>();
        List<String> programCode = new ArrayList<>();
	    
		// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the problem into sentences
        String[] sentences = sentenceDetector.sentDetect(problem);

        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Use regular expression to extract "problemID"
            problemID = extractProblemID(sentenceWithProblemID);
            currentProblemID = problemID;
            //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
            givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = problem.substring(0, problem.lastIndexOf(sentenceWithProblemID));
        }
	    
        if(givenSolutionOfCurrentTestCase == null) {
        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
        }
        String query = problemDescription + "Can you also generate test cases including corner cases to test the program?";;
        
        // Absolute path to the Python interpreter
        String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe";

        // Absolute path to the Python script
        String pythonScriptPath = "C:\\Users\\debal\\Downloads\\code_generation_geminipro_2 (8).py";

        // Command to execute the Python script
        List<String> command = new ArrayList<>();
        command.add(pythonInterpreterPath);
        command.add(pythonScriptPath);
        command.add(query);

        try {
            // Build and start the process
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the Python script
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            StringBuilder response = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                response.append(line).append("\n");
            }

            // Display the response
            if (response.length() > 0) {
            	output = response.toString();
            	System.out.println(output);
                //JOptionPane.showMessageDialog(null, response.toString(), "Response", JOptionPane.INFORMATION_MESSAGE);
            } else {
                System.err.println("Error: No response generated.");
            }

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                System.err.println("Error: Python script exited with code " + exitCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        ///////////////////////////////////////
        // Now saving the code in right folder
        String[] parts = output.split("```");
        
        for(int i = 0; i < parts.length; i++) {
        	//if (parts[i].startsWith("java")) {
        	if (parts[i].startsWith("java") || parts[i].startsWith("import") || parts[i].startsWith("public")) {
        		String code = parts[i];
                // Find the index of the first newline character
                int indexOfNewline = code.indexOf('\n');
                code = code.substring(indexOfNewline + 1);
        		programCode.add(code);
        		System.out.println("Generated program code :" + parts[i]);
        	} else {
        		statement.add(parts[i]);
        		System.out.println("Comments :" + parts[i]);
        	}
        }
        
        // Create a folder with current problemID
        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
    	folderPath = folderPath.concat(problemID);
        File folder = new File(folderPath);
        if (!folder.exists()) {
            boolean created = folder.mkdirs();
            if (created) {
                System.out.println("Folder created successfully.");
            } else {
                System.out.println("Failed to create the folder.");
            }
        } else {
            System.out.println("The folder already exists.");
        }
                    
        // creating java files based on number of code snippets within the folder
        int k = 1, l = 0;
        String newVersion = version.replace(".", "_");
        newVersion = newVersion.replace("v", "Version"); //
        	            
        // Creating a text file with prettyJson
        String textFileName = newVersion.concat(".txt");
        String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
            // Write the prettyJSON to the file
            writer2.write(output);                    
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
        if (!filePathForCodeAnalysis.isEmpty()) {
        	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
            filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
            // Clear the list to make it empty.
            filePathForCodeAnalysis.clear();
        }
        
        
        for (int j = programCode.size(); j > 0; j--) {
        	String s = "generatedProgram";
        	String trail = Integer.toString(k);
        	s = s.concat(trail).concat("Of").concat(newVersion).concat(".java");
        	String newFolderPath = folderPath.concat("\\");
        	String filePath = newFolderPath.concat(s);
        	filePathForCodeAnalysis.add(filePath);
        	//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
        	//filePath = filePath.concat(s);
        	try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(filePath))) {
                // Write the code to the file
                writer2.write(programCode.get(l));
                System.out.println('\n' + "Code saved to " + filePath);
                l++;
                k++;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        // Showing the paths of filePathForCodeAnalysis
        //for (String path : filePathForCodeAnalysis) {
        //	JOptionPane.showMessageDialog(null, "Generated Code Snippet saved in " + path, "Information", JOptionPane.INFORMATION_MESSAGE);
        //   }
        
        // creating text files based on the number of comments
        int m = 1, n = 0;
        filePathForStatementAnalysis.clear();
        for (int j = statement.size(); j > 0; j--) {
        	String s = "generatedStatement";
        	String trail = Integer.toString(m);
        	s = s.concat(trail).concat("Of").concat(newVersion).concat(".txt");
        	String newFolderPath = folderPath.concat("\\");
        	String filePath = newFolderPath.concat(s);
        	filePathForStatementAnalysis.add(filePath);
        	//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
        	//filePath = filePath.concat(s);
        	try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(filePath))) {
                // Write the ChatGPT generated statement to the file
                writer2.write(statement.get(n));
                System.out.println('\n' + "Statement saved to " + filePath);
                m++;
                n++;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        // Showing the paths of filePathForStatementAnalysis
        //for (String path : filePathForStatementAnalysis) {
        //	JOptionPane.showMessageDialog(null, "Generated Statements saved in " + path, "Information", JOptionPane.INFORMATION_MESSAGE);
        //   }    	            
        
                    
        //JTextArea textArea = new JTextArea(prettyJson);
    	//JFrame frame = new JFrame("Message");
    	//frame.add(new JScrollPane(textArea));
    	//frame.setSize(700, 600);
    	//frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    	//frame.setVisible(true); 
       
        
		return output;	
	}
	 
    @TestExecuter
	public static String ChatGPT(String problem) throws FileNotFoundException, IOException, InterruptedException {
		String url = "https://api.openai.com/v1/chat/completions";
		String apiKey = "Your-API-Key";		
	    String model = "gpt-3.5-turbo";
	    
	    List<String> statement = new ArrayList<>();
        List<String> programCode = new ArrayList<>();
        
        String problemDescription = "";
	    String sentenceWithProblemID = "";
	    String problemID = "";
	    
	    // Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the problem into sentences
        String[] sentences = sentenceDetector.sentDetect(problem);

        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Use regular expression to extract "problemID"
            problemID = extractProblemID(sentenceWithProblemID);
            currentProblemID = problemID;
            //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
            givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = problem.substring(0, problem.lastIndexOf(sentenceWithProblemID));
        }
	    
        if(givenSolutionOfCurrentTestCase == null) {
        	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
        }
        
	    try {
	           URL obj = new URL(url);
	           HttpURLConnection connection = (HttpURLConnection) obj.openConnection();
	           connection.setRequestMethod("POST");
	           connection.setRequestProperty("Authorization", "Bearer " + apiKey);
	           connection.setRequestProperty("Content-Type", "application/json");

	           // The request body
	           String body = "{\"model\": \"" + model + "\", \"messages\": [{\"role\": \"user\", \"content\": \"" + problem + "\"}]}";
	           connection.setDoOutput(true);
	           OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
	           writer.write(body);
	           writer.flush();
	           writer.close();

	           // Response from ChatGPT
	           BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));
	           String line;

	           StringBuffer response = new StringBuffer();

	           while ((line = br.readLine()) != null) {
	               response.append(line);
	           }
	           br.close();
	           
	           // Parse the JSON response using Jackson
	           ObjectMapper objectMapper = new ObjectMapper();
	           JsonNode jsonResponse = objectMapper.readTree(response.toString());

	           String prettyJson = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonResponse);
	           
	        // Extract the content from the JSON response
	            String content = jsonResponse.get("choices").get(0).get("message").get("content").asText();
	            
	            String[] parts = content.split("```");
	                        
	            for(int i = 0; i < parts.length; i++) {
	            	//if (parts[i].startsWith("java")) {
	            	if (parts[i].startsWith("java") || parts[i].startsWith("import") || parts[i].startsWith("public")) {
	            		String code = parts[i];
	                    // Find the index of the first newline character
	                    int indexOfNewline = code.indexOf('\n');
	                    code = code.substring(indexOfNewline + 1);
	            		programCode.add(code);
	            		System.out.println("Generated program code :" + parts[i]);
	            	} else {
	            		statement.add(parts[i]);
	            		System.out.println("Comments :" + parts[i]);
	            	}
	            }
	            
	            // Create a folder with current problemID
	            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(problemID);
	            File folder = new File(folderPath);
	            if (!folder.exists()) {
	                boolean created = folder.mkdirs();
	                if (created) {
	                    System.out.println("Folder created successfully.");
	                } else {
	                    System.out.println("Failed to create the folder.");
	                }
	            } else {
	                System.out.println("The folder already exists.");
	            }
	                        
	            // creating java files based on number of code snippets within the folder
	            int k = 1, l = 0;
	            String newVersion = version.replace(".", "_");
	            newVersion = newVersion.replace("v", "Version"); //
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = newVersion.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(prettyJson);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
	            
	            // If File path for code analysis not empty then add the contents in filePathForLastCodeAnalysis and make the file path for current code analysis empty
	            if (!filePathForCodeAnalysis.isEmpty()) {
	            	// Save the content of filePathForCodeAnalysis to filePathForLastCodeAnalysis
	                filePathForLastCodeAnalysis.addAll(filePathForCodeAnalysis);
	                // Clear the list to make it empty.
		            filePathForCodeAnalysis.clear();
	            }
	            
	            
	            for (int j = programCode.size(); j > 0; j--) {
	            	String s = "generatedProgram";
	            	String trail = Integer.toString(k);
	            	s = s.concat(trail).concat("Of").concat(newVersion).concat(".java");
	            	String newFolderPath = folderPath.concat("\\");
	            	String filePath = newFolderPath.concat(s);
	            	filePathForCodeAnalysis.add(filePath);
	            	//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
	            	//filePath = filePath.concat(s);
	            	try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(filePath))) {
	                    // Write the code to the file
	                    writer2.write(programCode.get(l));
	                    System.out.println('\n' + "Code saved to " + filePath);
	                    l++;
	                    k++;
	                } catch (IOException e) {
	                    e.printStackTrace();
	                }
	            }
	            
	            // Showing the paths of filePathForCodeAnalysis
	            //for (String path : filePathForCodeAnalysis) {
	            //	JOptionPane.showMessageDialog(null, "Generated Code Snippet saved in " + path, "Information", JOptionPane.INFORMATION_MESSAGE);
	            //   }
	            
	            // creating text files based on the number of comments
	            int m = 1, n = 0;
	            filePathForStatementAnalysis.clear();
	            for (int j = statement.size(); j > 0; j--) {
	            	String s = "generatedStatement";
	            	String trail = Integer.toString(m);
	            	s = s.concat(trail).concat("Of").concat(newVersion).concat(".txt");
	            	String newFolderPath = folderPath.concat("\\");
	            	String filePath = newFolderPath.concat(s);
	            	filePathForStatementAnalysis.add(filePath);
	            	//String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
	            	//filePath = filePath.concat(s);
	            	try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(filePath))) {
	                    // Write the ChatGPT generated statement to the file
	                    writer2.write(statement.get(n));
	                    System.out.println('\n' + "Statement saved to " + filePath);
	                    m++;
	                    n++;
	                } catch (IOException e) {
	                    e.printStackTrace();
	                }
	            }
	            
	            // Showing the paths of filePathForStatementAnalysis
	            //for (String path : filePathForStatementAnalysis) {
	            //	JOptionPane.showMessageDialog(null, "Generated Statements saved in " + path, "Information", JOptionPane.INFORMATION_MESSAGE);
	            //   }
	            	            
	            try {
	            isGeneratedCodeCompilable();
	            PMDCodeAnalyzerForComplexityOnGeneratedCode();
                PMDCodeAnalyzerForComplexityOnGivenSolution();   
	            }catch (Exception e) {
	                // Handle the exception if needed
	                System.out.println("An exception occurred: " + e.getMessage());
	            }
	                        
	            //JTextArea textArea = new JTextArea(prettyJson);
	        	//JFrame frame = new JFrame("Message");
	        	//frame.add(new JScrollPane(textArea));
	        	//frame.setSize(700, 600);
	        	//frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        	//frame.setVisible(true); 
	           
		       return prettyJson;
	       }
	    catch (IOException e) {
	           throw new RuntimeException(e);
	       }
	}
    
    //public static String extractProblemID(String text) {
      //  Pattern pattern = Pattern.compile("Problem Id is : (\\d+\\.\\d+)");
      //  Matcher matcher = pattern.matcher(text);
      //  if (matcher.find()) {
      //      return matcher.group(1);
      //  }
      //  return "";
    //}
    
    public static String extractProblemID(String text) {
        Pattern pattern = Pattern.compile("Problem Id is : ([a-fA-F0-9\\-]+)");
        Matcher matcher = pattern.matcher(text);
        if (matcher.find()) {
            return matcher.group(1);
        }
        return "";
    }
    
    @TestSetFilter
    public void filterByID() {
        String userInput = JOptionPane.showInputDialog("Enter test case ID to execute: ");
        
        List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<TestCase<String, String>>();
        List<String> matchingIds = new ArrayList<String>();
        numberOfConversation = 0;

        for (int i = 0; i < testSuite.testSet.size(); i++) {
            TestCase<String, String> x = testSuite.testSet.get(i);
            String id = x.id;
            if (userInput.equals(id)) {
                matchingIds.add(id);
                currentTestCase = x;
                version = versionProblemIDmap.get(id);
                
            } else {
                toBeRemovedTCs.add(x);
            }
        }

        testSuite.removeAllTestCases(toBeRemovedTCs);
    }
    
    @TestSetFilter
    public void reverseTestCases() {
        Collections.reverse(testSuite.testSet);
    }
    @TestSetFilter
    public static void reverseTestCasesSkippingFirst() {
        if (testSuite.testSet.size() > 1) {
            List<TestCase<String, String>> sublist = testSuite.testSet.subList(1, testSuite.testSet.size());
            Collections.reverse(sublist);
        }
    }
    
    @Datamorphism
    public TestPool<String,String> ParaphraseGeneratorUsingtopnAndUnchangedCountUpToTextLength (TestCase<String,String> seed) throws FileNotFoundException, IOException{
    	TestCase<String, String> x = testSuite.testSet.get(0);
    	
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        //String input = seed.input;
        String input = x.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            String uptoProgLanguage = sentences[sentences.length - 2];
            
            // Extract the main problem description part (excluding the last two sentence)
            problemDescription = input.substring(0, input.lastIndexOf(uptoProgLanguage));
        }
        //String sentenceToParaphrase = "Problem Description : \n12.10 (Fraction) Create a class Fraction with two integer final fields:\nnumerator and denominator. Its constructor creates fractions when given values\nfor both, but it has to avoid fractions with null denominators by throwing a\nNullDenominatorException of Programming Exercise 12.7.\n\n The programming language you need to use is: Java.";
        
        String sentenceToParaphrase = problemDescription;
        sentenceToParaphrase = sentenceToParaphrase.replace("\r\n", "").replace("Problem Description :", "");
        
       // Ask user for the topn value using JOptionPane
        String topnInput = JOptionPane.showInputDialog(null, "Enter topn value (e.g., 3):", "Enter topn", JOptionPane.QUESTION_MESSAGE);
        int topn;
        try {
            topn = Integer.parseInt(topnInput);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for topn. Defaulting to 1.");
            topn = 1;
        } Neighbourhood = topn;

        // Ask user for the number of words to keep unchanged using JOptionPane
        //String unchangedCountInput = JOptionPane.showInputDialog(null, "Enter the number of words to keep unchanged (e.g., 2):", "Enter unchanged count", JOptionPane.QUESTION_MESSAGE);
        //int unchangedCount;
        //try {
        //    unchangedCount = Integer.parseInt(unchangedCountInput);
        //} catch (NumberFormatException e) {
        //    System.err.println("Invalid input for unchanged count. Defaulting to 1.");
        //    unchangedCount = 1;
        //}

        // Absolute path to the Python interpreter
        String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe";

        // Absolute path to the Python script
        String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words_glove_three.py";
        //String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words_word2vec.py";
        //String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words_elmo.py";

        // Command to execute the Python script
        List<String> command = new ArrayList<>();
        command.add(pythonInterpreterPath);
        command.add(pythonScriptPath);
        command.add(sentenceToParaphrase);
        command.add(String.valueOf(topn));
        //command.add(String.valueOf(unchangedCount));  // Add unchanged count parameter
        
        try {
            // Build and start the process
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the Python script
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            List<String> paraphrases = new ArrayList<>();
            while ((line = reader.readLine()) != null) {
                paraphrases.add(line.trim());
            }

            // Print paraphrases
            if (!paraphrases.isEmpty()) {
                for (int i = 0; i < paraphrases.size(); i++) {
                    System.out.println("Paraphrase " + (i + 1) + ": " + paraphrases.get(i));
                    UUID newId = UUID.randomUUID();
                    String ID = newId.toString();        
                       	
                	String paraphrasedSentence = paraphrases.get(i) + "\n" + "The programming language is Java." + "\n" + " Problem Id is : " + ID + "." + "\n";
            	    TestCase<String,String> mutant = new TestCase<String,String>();
                    mutant.input = paraphrasedSentence;	            
                    mutant.feature = TestDataFeature.mutant;
            	    mutant.setType("ProgrammingProblem");
            	    mutant.id = ID;
            	    testSuite.addTestCase(mutant);
                }
            } else {
                System.err.println("Error: No paraphrases generated.");
            }

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                System.err.println("Error: Python script exited with code " + exitCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
     
	    return testSuite;
    	
    }  
    
    @Datamorphism
    public TestPool<String,String> ParaphraseGeneratorUsingtopnAndUnchangedCount (TestCase<String,String> seed) throws FileNotFoundException, IOException{
    	TestCase<String, String> x = testSuite.testSet.get(0);
    	
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        //String input = seed.input;
        String input = x.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            String uptoProgLanguage = sentences[sentences.length - 2];
            
            // Extract the main problem description part (excluding the last two sentence)
            problemDescription = input.substring(0, input.lastIndexOf(uptoProgLanguage));
        }
        //String sentenceToParaphrase = "Problem Description : \n12.10 (Fraction) Create a class Fraction with two integer final fields:\nnumerator and denominator. Its constructor creates fractions when given values\nfor both, but it has to avoid fractions with null denominators by throwing a\nNullDenominatorException of Programming Exercise 12.7.\n\n The programming language you need to use is: Java.";
        
        String sentenceToParaphrase = problemDescription;
        sentenceToParaphrase = sentenceToParaphrase.replace("\r\n", "").replace("Problem Description :", "");
        
       // Ask user for the topn value using JOptionPane
        String topnInput = JOptionPane.showInputDialog(null, "Enter topn value (e.g., 3):", "Enter topn", JOptionPane.QUESTION_MESSAGE);
        int topn;
        try {
            topn = Integer.parseInt(topnInput);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for topn. Defaulting to 1.");
            topn = 1;
        }

        // Ask user for the number of words to keep unchanged using JOptionPane
        String unchangedCountInput = JOptionPane.showInputDialog(null, "Enter the number of words to keep unchanged (e.g., 2):", "Enter unchanged count", JOptionPane.QUESTION_MESSAGE);
        int unchangedCount;
        try {
            unchangedCount = Integer.parseInt(unchangedCountInput);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for unchanged count. Defaulting to 1.");
            unchangedCount = 1;
        }

        // Absolute path to the Python interpreter
        String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe";

        // Absolute path to the Python script
        String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words_glove_two.py";
        //String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words_word2vec.py";
        //String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words_elmo.py";

        // Command to execute the Python script
        List<String> command = new ArrayList<>();
        command.add(pythonInterpreterPath);
        command.add(pythonScriptPath);
        command.add(sentenceToParaphrase);
        command.add(String.valueOf(topn));
        command.add(String.valueOf(unchangedCount));  // Add unchanged count parameter
        
        try {
            // Build and start the process
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the Python script
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            List<String> paraphrases = new ArrayList<>();
            while ((line = reader.readLine()) != null) {
                paraphrases.add(line.trim());
            }

            // Print paraphrases
            if (!paraphrases.isEmpty()) {
                for (int i = 0; i < paraphrases.size(); i++) {
                    System.out.println("Paraphrase " + (i + 1) + ": " + paraphrases.get(i));
                    UUID newId = UUID.randomUUID();
                    String ID = newId.toString();        
                       	
                	String paraphrasedSentence = paraphrases.get(i) + "\n" + "The programming language is Java." + "\n" + " Problem Id is : " + ID + "." + "\n";
            	    TestCase<String,String> mutant = new TestCase<String,String>();
                    mutant.input = paraphrasedSentence;	            
                    mutant.feature = TestDataFeature.mutant;
            	    mutant.setType("ProgrammingProblem");
            	    mutant.id = ID;
            	    testSuite.addTestCase(mutant);
                }
            } else {
                System.err.println("Error: No paraphrases generated.");
            }

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                System.err.println("Error: Python script exited with code " + exitCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
     
	    return testSuite;
    	
    }  
    
    @Datamorphism
    public TestPool<String,String> ParaphraseGeneratorReplacingOneWordAtATime (TestCase<String,String> seed) throws FileNotFoundException, IOException{
    	//for (int i = 0; i < testSuite.testSet.size(); i++) {
            //TestCase<String, String> x = testSuite.testSet.get(0);
    	//}
    	
    	TestCase<String, String> x = testSuite.testSet.get(0);
    	
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        String input = x.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            String uptoProgLanguage = sentences[sentences.length - 2];
            
            // Extract the main problem description part (excluding the last two sentence)
            problemDescription = input.substring(0, input.lastIndexOf(uptoProgLanguage));
        }
        //String sentenceToParaphrase = "Problem Description : \n12.10 (Fraction) Create a class Fraction with two integer final fields:\nnumerator and denominator. Its constructor creates fractions when given values\nfor both, but it has to avoid fractions with null denominators by throwing a\nNullDenominatorException of Programming Exercise 12.7.\n\n The programming language you need to use is: Java.";
        
        String sentenceToParaphrase = problemDescription;
        sentenceToParaphrase = sentenceToParaphrase.replace("\r\n", "").replace("Problem Description :", "");
        
       // Ask user for the topn value using JOptionPane
        String topnInput = JOptionPane.showInputDialog(null, "Enter topn value (e.g., 3):", "Enter topn", JOptionPane.QUESTION_MESSAGE);
        int topn;
        try {
            topn = Integer.parseInt(topnInput);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for topn. Defaulting to 1.");
            topn = 1;
        }

        // Absolute path to the Python interpreter
        String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe";

        // Absolute path to the Python script
        //String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words.py";
        String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words_two.py";

        // Command to execute the Python script
        List<String> command = new ArrayList<>();
        command.add(pythonInterpreterPath);
        command.add(pythonScriptPath);
        command.add(sentenceToParaphrase);
        command.add(String.valueOf(topn));
        
        try {
            // Build and start the process
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the Python script
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            List<String> paraphrases = new ArrayList<>();
            while ((line = reader.readLine()) != null) {
                paraphrases.add(line.trim());
            }

            // Print paraphrases
            if (!paraphrases.isEmpty()) {
                for (int i = 0; i < paraphrases.size(); i++) {
                    System.out.println("Paraphrase " + (i + 1) + ": " + paraphrases.get(i));
                    UUID newId = UUID.randomUUID();
                    String ID = newId.toString();        
                       	
                	String paraphrasedSentence = paraphrases.get(i) + "\n" + "The programming language is Java." + "\n" + " Problem Id is : " + ID + "." + "\n";
            	    TestCase<String,String> mutant = new TestCase<String,String>();
                    mutant.input = paraphrasedSentence;	            
                    mutant.feature = TestDataFeature.mutant;
            	    mutant.setType("ProgrammingProblem");
            	    mutant.id = ID;
            	    testSuite.addTestCase(mutant);
                }
            } else {
                System.err.println("Error: No paraphrases generated.");
            }

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                System.err.println("Error: Python script exited with code " + exitCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
     
	    return testSuite;
    	
    }  
    
    @Datamorphism
    public TestPool<String,String> ParaphraseGeneratorUsingKthOrderMutants (TestCase<String,String> seed) throws FileNotFoundException, IOException{
    	//for (int i = 0; i < testSuite.testSet.size(); i++) {
            //TestCase<String, String> x = testSuite.testSet.get(0);
    	//}
    	
    	TestCase<String, String> x = testSuite.testSet.get(0);
    	
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        String input = x.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            String uptoProgLanguage = sentences[sentences.length - 2];
            
            // Extract the main problem description part (excluding the last two sentence)
            problemDescription = input.substring(0, input.lastIndexOf(uptoProgLanguage));
        }
        //String sentenceToParaphrase = "Problem Description : \n12.10 (Fraction) Create a class Fraction with two integer final fields:\nnumerator and denominator. Its constructor creates fractions when given values\nfor both, but it has to avoid fractions with null denominators by throwing a\nNullDenominatorException of Programming Exercise 12.7.\n\n The programming language you need to use is: Java.";
        
        String sentenceToParaphrase = problemDescription;
        sentenceToParaphrase = sentenceToParaphrase.replace("\r\n", "").replace("Problem Description :", "");
        sentenceToParaphrase = sentenceToParaphrase.toLowerCase();
        
       // Ask user for the topn value using JOptionPane
        String topnInput = JOptionPane.showInputDialog(null, "Enter topn value (e.g., 3):", "Enter topn", JOptionPane.QUESTION_MESSAGE);
        int topn;
        try {
            topn = Integer.parseInt(topnInput);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for topn. Defaulting to 1.");
            topn = 1;
        }
        Neighbourhood = topn;
        
        // Ask user for the number of words to replace at a time using JOptionPane
        String numWordsInput = JOptionPane.showInputDialog(null, 
                "Enter the number of words to replace at a time (e.g., 2):", "Input Words to Replace", JOptionPane.QUESTION_MESSAGE);
        int numWordsToReplace;
        try {
            numWordsToReplace = Integer.parseInt(numWordsInput);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for number of words. Defaulting to 1.");
            numWordsToReplace = 1;
        }
        NumberOfWords = numWordsToReplace;

        // Absolute path to the Python interpreter
        String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe";

        // Absolute path to the Python script
        //String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_replacing_words.py";
        //String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrasegeneratorusingtopnandnumberofwordstwo.py";
        String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrasegeneratorusingtopnandnumberofwordsfour.py";

        // Command to execute the Python script
        List<String> command = new ArrayList<>();
        command.add(pythonInterpreterPath);
        command.add(pythonScriptPath);
        command.add(sentenceToParaphrase);
        command.add(String.valueOf(topn));
        command.add(String.valueOf(numWordsToReplace));
        
        try {
            // Build and start the process
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the Python script
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            List<String> paraphrases = new ArrayList<>();
            while ((line = reader.readLine()) != null) {
                paraphrases.add(line.trim());
            }

            // Print paraphrases
            if (!paraphrases.isEmpty()) {
                for (int i = 0; i < paraphrases.size(); i++) {
                    System.out.println("Paraphrase " + (i + 1) + ": " + paraphrases.get(i));
                    UUID newId = UUID.randomUUID();
                    String ID = newId.toString();        
                       	
                	String paraphrasedSentence = paraphrases.get(i) + "\n" + "The programming language is Java." + "\n" + " Problem Id is : " + ID + "." + "\n";
            	    TestCase<String,String> mutant = new TestCase<String,String>();
                    mutant.input = paraphrasedSentence;	            
                    mutant.feature = TestDataFeature.mutant;
            	    mutant.setType("ProgrammingProblem");
            	    mutant.id = ID;
            	    testSuite.addTestCase(mutant);
            	    
            	    // Add Neighbourhood and NumberOfWords to the HashMaps
            	    neighbourhoodMap.put(ID, Neighbourhood);
            	    numberOfWordsMap.put(ID, NumberOfWords);
                }
            } else {
                System.err.println("Error: No paraphrases generated.");
            }

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                System.err.println("Error: Python script exited with code " + exitCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
     
	    return testSuite;
    	
    }  
    
    
    @Datamorphism
    public TestPool<String,String> ParaphraseGeneratorByPegasusParaphraser (TestCase<String,String> seed) throws FileNotFoundException, IOException{
    	
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        String input = seed.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = input.substring(0, input.lastIndexOf(sentenceWithProblemID));
        }
        //String sentenceToParaphrase = "Problem Description : \n12.10 (Fraction) Create a class Fraction with two integer final fields:\nnumerator and denominator. Its constructor creates fractions when given values\nfor both, but it has to avoid fractions with null denominators by throwing a\nNullDenominatorException of Programming Exercise 12.7.\n\n The programming language you need to use is: Java.";
        
        String sentenceToParaphrase = problemDescription;
        // Ask user for the sentence to paraphrase using JOptionPane
        //String sentenceToParaphrase = JOptionPane.showInputDialog(null, "Enter the sentence to paraphrase:", "Enter Sentence", JOptionPane.QUESTION_MESSAGE);
        
        // Ask user for the similarity threshold using JOptionPane
        String thresholdInput = JOptionPane.showInputDialog(null, "Enter the similarity threshold (e.g., 0.85):", "Enter Threshold", JOptionPane.QUESTION_MESSAGE);
        
        // Parse the threshold input to a float
        float similarityThreshold;
        try {
            similarityThreshold = Float.parseFloat(thresholdInput);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for similarity threshold. Defaulting to 0.8.");
            similarityThreshold = 0.8f; // Default to 0.8 if input is invalid
        }

        // Absolute path to the Python interpreter
        String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe"; // Update with your Python interpreter path

        // Absolute path to the Python script
        String pythonScriptPath = "C:\\Users\\debal\\Downloads\\paraphrase_generator_contextawaremodel_3.py"; // Update with the actual path to your Python script

        // Command to execute the Python script
        List<String> command = new ArrayList<>();
        command.add(pythonInterpreterPath);
        command.add(pythonScriptPath);
        command.add(sentenceToParaphrase);
        command.add(String.valueOf(similarityThreshold)); // Add the similarity threshold as an argument

        try {
            // Build and start the process
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the Python script
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            String allLinesTogether = null;
            List<String> paraphrases = new ArrayList<>();
            StringBuilder currentParaphrase = new StringBuilder();
            while ((line = reader.readLine()) != null) {
            	allLinesTogether = allLinesTogether + line;
                //System.out.println(line);
            	// Check if the line starts with a number followed by a dot (indicating a new paraphrase)
                if (line.trim().length() > 2 && Character.isDigit(line.trim().charAt(0)) && line.trim().charAt(1) == '.') {
                    // If a new paraphrase is detected, save the previous one if it exists
                    if (currentParaphrase.length() > 0) {
                        paraphrases.add(currentParaphrase.toString().trim());
                        currentParaphrase.setLength(0); // Clear the StringBuilder for the next paraphrase
                    }
                    // Add the new paraphrase line, remove the number and dot
                    currentParaphrase.append(line.replaceFirst("^\\d+\\. ", "").trim());
                } else {
                    // Continue appending to the current paraphrase
                    currentParaphrase.append(" ").append(line.trim());
                }
            }

            // Add the last paraphrase if it exists
            if (currentParaphrase.length() > 0) {
                paraphrases.add(currentParaphrase.toString().trim());
            }
            
            // Create a JFrame with JTextArea to display the output
            JFrame frame = new JFrame("Paraphrases");
            JTextArea textArea = new JTextArea(allLinesTogether);
            textArea.setEditable(false);

            JScrollPane scrollPane = new JScrollPane(textArea);
            frame.add(scrollPane);

            frame.setSize(1000, 800);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setVisible(true);

            // Print the paraphrases to verify
            int i;
            //if (paraphrases.size() > 0) {
            	for (i = 0; i < paraphrases.size(); i++) {
                    System.out.println("Paraphrase " + (i + 1) + ": " + paraphrases.get(i));
                    UUID newId = UUID.randomUUID();
                    String ID = newId.toString();        
                       	
                	String paraphrasedSentence = paraphrases.get(i) + "\n" + " Problem Id is : " + ID + "." + "\n";
            	    TestCase<String,String> mutant = new TestCase<String,String>();
                    mutant.input = paraphrasedSentence;	            
                    mutant.feature = TestDataFeature.mutant;
            	    mutant.setType("ProgrammingProblem");
            	    mutant.id = ID;
            	    testSuite.addTestCase(mutant);
                }
            //} else {
            //    System.err.println("Error: Less than 5 paraphrases generated.");
            //}

            // Wait for the process to complete
            int exitCode = process.waitFor();
            if (exitCode != 0) {
                System.err.println("Error: Python script exited with code " + exitCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }            
	    return testSuite;
    	
    }
    
    @Datamorphism
	public TestPool<String,String> ParaphraseGeneratorByWordEmbedding (TestCase<String,String> seed) throws FileNotFoundException, IOException{
    	TestCase<String, String> x = null;
    	for (int i = 0; i < testSuite.testSet.size(); i++) {
        x = testSuite.testSet.get(0);
	    }
    	
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        String input = x.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = input.substring(0, input.lastIndexOf(sentenceWithProblemID));
        }
        //String sentenceToParaphrase = "Problem Description : \n12.10 (Fraction) Create a class Fraction with two integer final fields:\nnumerator and denominator. Its constructor creates fractions when given values\nfor both, but it has to avoid fractions with null denominators by throwing a\nNullDenominatorException of Programming Exercise 12.7.\n\n The programming language you need to use is: Java.";
        
        String sentenceToParaphrase = problemDescription;
        
        // topn value
        //int topn = 3;
        
        // Ask user for the topn value using JOptionPane
        String topnInput = JOptionPane.showInputDialog(null, "Enter topn value (e.g., 3):", "Enter topn", JOptionPane.QUESTION_MESSAGE);

        // Parse the input to an integer
        int topn;
        try {
            topn = Integer.parseInt(topnInput);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for topn. Defaulting to 1.");
            topn = 1; // Default to 1 if input is invalid
        }

        // Absolute path to the Python interpreter
        String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe"; // Update with your Python interpreter path

        // Absolute path to the Python script
        String pythonScriptPath = "C:\\Users\\debal\\Downloads\\generate_paraphrases_2.py"; // Update with the actual path to your Python script

        // Command to execute the Python script
        List<String> command = new ArrayList<>();
        command.add(pythonInterpreterPath);
        command.add(pythonScriptPath);
        command.add(sentenceToParaphrase);
        command.add(String.valueOf(topn)); // Add the topn value as an argument

        try {
            // Build and start the process
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the Python script
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            List<String> paraphrases = new ArrayList<>();
            StringBuilder currentParaphrase = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                //System.out.println(line);
            	// Check if the line starts with a number followed by a dot (indicating a new paraphrase)
                if (line.trim().length() > 2 && Character.isDigit(line.trim().charAt(0)) && line.trim().charAt(1) == '.') {
                    // If a new paraphrase is detected, save the previous one if it exists
                    if (currentParaphrase.length() > 0) {
                        paraphrases.add(currentParaphrase.toString().trim());
                        currentParaphrase.setLength(0); // Clear the StringBuilder for the next paraphrase
                    }
                    // Add the new paraphrase line, remove the number and dot
                    currentParaphrase.append(line.replaceFirst("^\\d+\\. ", "").trim());
                } else {
                    // Continue appending to the current paraphrase
                    currentParaphrase.append(" ").append(line.trim());
                }
            }

            // Add the last paraphrase if it exists
            if (currentParaphrase.length() > 0) {
                paraphrases.add(currentParaphrase.toString().trim());
            }
            int count = 0;
            // Print the paraphrases to verify
            if (paraphrases.size() >= 5) {
                for (int i = 0; i < paraphrases.size(); i++) {
                	if(count < 5) {
                    System.out.println("Paraphrase " + (i + 1) + ": " + paraphrases.get(i));
                    
                    UUID newId = UUID.randomUUID();
                    String ID = newId.toString();        
                       	
                	String paraphrasedSentence = paraphrases.get(i) + "\n" + " Problem Id is : " + ID + "." + "\n";
            	    TestCase<String,String> mutant = new TestCase<String,String>();
                    mutant.input = paraphrasedSentence;	            
                    mutant.feature = TestDataFeature.mutant;
            	    mutant.setType("ProgrammingProblem");
            	    mutant.id = ID;
            	    testSuite.addTestCase(mutant);   
            	    count +=1;
                	}
                }
            } else {
                System.err.println("Error: Less than 5 paraphrases generated.");
            }

            // Wait for the process to complete
            int exitCode = process.waitFor();
            if (exitCode != 0) {
                System.err.println("Error: Python script exited with code " + exitCode);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }       
     
	    return testSuite;    	
    }

    @Datamorphism
	public TestPool<String,String> ParaphraseGeneratorBySpinnerChief (TestCase<String,String> seed) throws FileNotFoundException, IOException{
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        String input = seed.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";
        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = input.substring(0, input.lastIndexOf(sentenceWithProblemID));
        }
        
        String apiKey = "Your-API-Key";  // Replace with your SpinnerChief API key
        //String text = "Write a Java program to convert temperature from Fahrenheit to Celsius degrees.";
        String text = problemDescription;

        // Define the API endpoint
        URL url = new URL("https://spinnerchief.com/api/paraphraser");
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        connection.setDoOutput(true);

        // Construct the request body
        String requestBody = "dev_key=DeveloperKey&api_key=" + apiKey + "&text=" + text;

        try (OutputStream os = connection.getOutputStream()) {
            byte[] inputBytes = requestBody.getBytes("utf-8");
            os.write(inputBytes, 0, inputBytes.length);
        }

        StringBuilder response = new StringBuilder();
        try (Scanner scanner = new Scanner(connection.getInputStream())) {
            while (scanner.hasNext()) {
                response.append(scanner.nextLine());
            }
        }

        // Parse the JSON response using Jackson
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode jsonResponse = objectMapper.readTree(response.toString());

        // Print the paraphrased text or handle errors
        if (jsonResponse.has("paraphrase")) {
            String paraphrasedText = jsonResponse.get("paraphrase").asText();
            //System.out.println("Original Text: " + text);
            //System.out.println("Paraphrased Text: " + paraphrasedText);
        } else {
            //System.out.println("Error: " + jsonResponse.toString());
        }
        
        // Extract the paraphrased text from the JSON response
        String paraphrasedText = jsonResponse.get("text").asText();

        // Print the paraphrased text
        System.out.println(paraphrasedText);
        
        UUID newId = UUID.randomUUID();
        String ID = newId.toString();        
           	
    	String paraphrasedSentence = paraphrasedText + "\n" + " Problem Id is : " + ID + "." + "\n";
	    TestCase<String,String> mutant = new TestCase<String,String>();
        mutant.input = paraphrasedSentence;	            
        mutant.feature = TestDataFeature.mutant;
	    mutant.setType("ProgrammingProblem");
	    mutant.id = ID;
	    testSuite.addTestCase(mutant);
	    return testSuite;
    	
    }
    
    // Only modifying in TestSuite
    @TestSetFilter
	public void ManualModification() {
    	String userInput = JOptionPane.showInputDialog("Enter test case ID to paraphrase: ");
    	List<String> matchingIds = new ArrayList<String>();
    	
    	for (int i = 0; i < testSuite.testSet.size(); i++) {
            TestCase<String, String> x = testSuite.testSet.get(i);
            String id = x.id;
            if (userInput.equals(id)) {
                matchingIds.add(id);
                currentTestCase = x;
                problemEditorThree(x.input);
                x.input = modifiedDescription.toString().replace("\n", "\\n");
            }
    	}		        
	}
    
    public static void problemEditorThree(String originalDescription) {
    	// Create input fields for original and modified descriptions
        JTextArea originalDescriptionArea = new JTextArea(originalDescription);
        originalDescriptionArea.setEditable(false);
        originalDescriptionArea.setLineWrap(true);
        originalDescriptionArea.setWrapStyleWord(true);

        JTextArea newDescriptionArea = new JTextArea(originalDescription);
        newDescriptionArea.setLineWrap(true);
        newDescriptionArea.setWrapStyleWord(true);

        // Wrap JTextArea in JScrollPane
        JScrollPane originalDescriptionScrollPane = new JScrollPane(originalDescriptionArea);
        originalDescriptionScrollPane.setPreferredSize(new Dimension(400, 200));

        JScrollPane newDescriptionScrollPane = new JScrollPane(newDescriptionArea);
        newDescriptionScrollPane.setPreferredSize(new Dimension(400, 200));

        // Create a panel to hold the input fields
        JPanel panel = new JPanel(new GridLayout(0, 1));
        panel.add(new JLabel("Original Description:"));
        panel.add(originalDescriptionScrollPane);
        panel.add(new JLabel("Modify Description:"));
        panel.add(newDescriptionScrollPane);

        // Show the input dialog
        int option = JOptionPane.showConfirmDialog(null, panel, "Modify Description", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);
        if (option == JOptionPane.OK_OPTION) {
            modifiedDescription = newDescriptionArea.getText();
        }
    }
        
    @Datamorphism
	public TestPool<String,String> SentenceModifierByGPT(TestCase<String,String> seed) throws FileNotFoundException, IOException{
    	
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        String input = seed.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";
        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = input.substring(0, input.lastIndexOf(sentenceWithProblemID));
        }
		
		//String apiKey = "Your-API-Key"; //API using rediffmail
		String prompt = "Generate alternative phrasings for the task: '" + problemDescription + "' without including any code. Provide serial numbers before the generated alternative phrasings.";
		String url = "https://api.openai.com/v1/chat/completions";
    	String apiKey = "Your-API-Key";
    	String model = "gpt-3.5-turbo";
    	
    	try {
    	    URL obj = new URL(url);
    	    HttpURLConnection connection = (HttpURLConnection) obj.openConnection();
    	    connection.setRequestMethod("POST");
    	    connection.setRequestProperty("Authorization", "Bearer " + apiKey);
    	    connection.setRequestProperty("Content-Type", "application/json");

    	    // The request body
    	    String requestBody = "{\"model\": \"" + model + "\", \"messages\": [{\"role\": \"user\", \"content\": \"" + prompt + "\"}]}";
    	    connection.setDoOutput(true);
    	    OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
    	    writer.write(requestBody);
    	    writer.flush();
    	    writer.close();

    	    // Response from ChatGPT
    	    BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    	    StringBuilder response = new StringBuilder();
    	    String line;

    	    while ((line = br.readLine()) != null) {
    	        response.append(line);
    	    }
    	    br.close();
    	    
    	    // Parse the JSON response using Jackson
    	    ObjectMapper objectMapper = new ObjectMapper();
    	    JsonNode jsonResponse = objectMapper.readTree(response.toString());

    	    String prettyJson = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonResponse);
    	    
    	    // Extract the content from the JSON response
    	    String content = jsonResponse.get("choices").get(0).get("message").get("content").asText();
    	    List<String> newSentences = splitSentences(content);
    	    	        
	        // Start from index 1 to skip the first empty string
	        for (String sentence : newSentences) {
	        	if (!sentence.equals("")) {
	            TestCase<String,String> mutant = new TestCase<String,String>();
	            sentence = sentence + sentenceWithProblemID;
	            mutant.input = sentence;	            
	            mutant.feature = TestDataFeature.mutant;
	    	    mutant.setType("ProgrammingProblem");
	    	    testSuite.addTestCase(mutant);}
	        }
		
    	} catch (IOException e) {
    	    e.printStackTrace();
    	}
    	System.out.println(testSuite);
    	return testSuite;
        
    }
    
    public static List<String> splitSentences(String input) {
        List<String> sentences = new ArrayList<>();
        //String[] sentenceArray = input.split("- ");

        // Define a regular expression pattern to match numbers followed by dots or hyphens
        Pattern pattern = Pattern.compile("\\d+\\.|\\-");

        // Use the pattern to split the text into sentences
        String[] sentenceArray = pattern.split(input);
        
        // Start from index 1 to skip the first empty string
        for (String sentence : sentenceArray) {
        	String cleanedSentence = removeSerialNumber(sentence);
            sentences.add(cleanedSentence);
        }

        return sentences;
    }
    
    public static String removeSerialNumber(String input) {
        // Define a regular expression pattern to match serial numbers (e.g., "1.", "2.", etc.)
        Pattern pattern = Pattern.compile("\\d+\\.");

        // Use a Matcher to find and remove the serial number from the input
        Matcher matcher = pattern.matcher(input);
        if (matcher.find()) {
            return input.replaceFirst(pattern.pattern(), "");
        }

        // If no serial number is found, return the input unchanged
        return input;
    }
    
    @Datamorphism
    public TestPool<String,String> ParaphraseGeneratorWithGloveCosineSimilarity(TestCase<String,String> seed) throws IOException{    
    	
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        String input = seed.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";
        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = input.substring(0, input.lastIndexOf(sentenceWithProblemID));
        }
    	
    	    // Create a Stanford NLP pipeline for part-of-speech tagging
    	    Properties props = new Properties();
    	    props.setProperty("annotators", "tokenize, ssplit, pos");
    	    props.setProperty("pos.model", "C:\\Users\\debal\\Downloads\\english-left3words-distsim.tagger");
    	    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);

    	    // Input sentence for paraphrasing
    	    String inputSentence = problemDescription;

    	    // Annotate the input sentence for part-of-speech tagging
    	    Annotation annotation = new Annotation(inputSentence);
    	    pipeline.annotate(annotation);

    	    List<CoreLabel> tokens = annotation.get(CoreAnnotations.TokensAnnotation.class);

    	    // Replace adjectives and verbs with their nearest neighbors
    	    StringBuilder paraphrase = new StringBuilder();
    	    // Path to the GloVe word embedding file
    	    String gloveFilePath = "C:\\Users\\debal\\Downloads\\archive (3)\\glove.6B.50d.txt";
    	    // Load the word embeddings into a map
    	    Map<String, double[]> wordEmbeddings = loadWordEmbeddings(gloveFilePath);
    	    for (CoreLabel token : tokens) {
    	        String word = token.word();
    	        String pos = token.get(CoreAnnotations.PartOfSpeechAnnotation.class);

    	        //if (pos.startsWith("JJ") || pos.startsWith("VB") || pos.startsWith("NN") || pos.startsWith("RB") || pos.startsWith("IN") || pos.startsWith("PRP") || pos.startsWith("CC") || pos.startsWith("DT") || pos.startsWith("UH") || pos.startsWith("RP") || pos.startsWith("CD") || pos.startsWith("MD") || pos.startsWith("FW")) 
    	        if (pos.startsWith("JJ") || pos.startsWith("VB") || pos.startsWith("RB") || pos.startsWith("IN") || pos.startsWith("PRP") || pos.startsWith("CC") || pos.startsWith("DT") || pos.startsWith("UH") || pos.startsWith("RP") || pos.startsWith("CD") || pos.startsWith("MD") || pos.startsWith("FW")) {
    	            // Include logic to find and replace the word with its nearest neighbor
    	            // It's an adjective or a verb, so find its nearest neighbor
    	            String nearestWord = findNearestWordUsingDistance(word, wordEmbeddings);
    	            paraphrase.append(nearestWord).append(" ");
    	        } else {
    	            // It's not an adjective or a verb, so keep it as is
    	            paraphrase.append(word).append(" ");
    	        }
    	    }

    	    String paraphrasedSentence = paraphrase.toString().trim(); // Remove leading and trailing whitespace
    	    //System.out.println("Original Sentence: " + inputSentence);
    	    //System.out.println("Paraphrased Sentence: " + paraphrasedSentence);
    	    paraphrasedSentence = paraphrasedSentence + sentenceWithProblemID;
    	    TestCase<String,String> mutant = new TestCase<String,String>();
            mutant.input = paraphrasedSentence;	            
            mutant.feature = TestDataFeature.mutant;
    	    mutant.setType("ProgrammingProblem");
    	    testSuite.addTestCase(mutant);
    	    return testSuite;
    	}
    
    
    @Datamorphism
    public TestPool<String,String> ParaphraseGeneratorWithGloveEuclideanDistance(TestCase<String,String> seed) throws IOException{    
    	// Load the sentence detection model
        SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
        SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

        // Split the paragraph into sentences
        String input = seed.input;
        String[] sentences = sentenceDetector.sentDetect(input);
        String sentenceWithProblemID = "";
        String problemDescription = "";
        
        
        // Check if there are sentences
        if (sentences.length > 0) {
            // Extract the last sentence
            sentenceWithProblemID = sentences[sentences.length - 1];
            
            // Extract the main problem description part (excluding the last sentence)
            problemDescription = input.substring(0, input.lastIndexOf(sentenceWithProblemID));
        }
    	
    	    // Create a Stanford NLP pipeline for part-of-speech tagging
    	    Properties props = new Properties();
    	    props.setProperty("annotators", "tokenize, ssplit, pos");
    	    props.setProperty("pos.model", "C:\\Users\\debal\\Downloads\\english-left3words-distsim.tagger");
    	    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);

    	    // Input sentence for paraphrasing
    	    String inputSentence = problemDescription;

    	    // Annotate the input sentence for part-of-speech tagging
    	    Annotation annotation = new Annotation(inputSentence);
    	    pipeline.annotate(annotation);

    	    List<CoreLabel> tokens = annotation.get(CoreAnnotations.TokensAnnotation.class);

    	    // Replace adjectives and verbs with their nearest neighbors
    	    StringBuilder paraphrase = new StringBuilder();
    	    // Path to the GloVe word embedding file
    	    String gloveFilePath = "C:\\Users\\debal\\Downloads\\archive (3)\\glove.6B.50d.txt";
    	    // Load the word embeddings into a map
    	    Map<String, double[]> wordEmbeddings = loadWordEmbeddings(gloveFilePath);
    	    for (CoreLabel token : tokens) {
    	        String word = token.word();
    	        String pos = token.get(CoreAnnotations.PartOfSpeechAnnotation.class);

    	        //if (pos.startsWith("JJ") || pos.startsWith("VB") || pos.startsWith("NN") || pos.startsWith("RB") || pos.startsWith("IN") || pos.startsWith("PRP") || pos.startsWith("CC") || pos.startsWith("DT") || pos.startsWith("UH") || pos.startsWith("RP") || pos.startsWith("CD") || pos.startsWith("MD") || pos.startsWith("FW")) 
    	        if (pos.startsWith("JJ") || pos.startsWith("VB") || pos.startsWith("RB") || pos.startsWith("IN") || pos.startsWith("PRP") || pos.startsWith("CC") || pos.startsWith("DT") || pos.startsWith("UH") || pos.startsWith("RP") || pos.startsWith("CD") || pos.startsWith("MD") || pos.startsWith("FW")) {
    	            // Include logic to find and replace the word with its nearest neighbor
    	            // It's an adjective or a verb, so find its nearest neighbor
    	            String nearestWord = findNearestWordUsingDistance(word, wordEmbeddings);
    	            paraphrase.append(nearestWord).append(" ");
    	        } else {
    	            // It's not an adjective or a verb, so keep it as is
    	            paraphrase.append(word).append(" ");
    	        }
    	    }

    	    String paraphrasedSentence = paraphrase.toString().trim(); // Remove leading and trailing whitespace
    	    //System.out.println("Original Sentence: " + inputSentence);
    	    //System.out.println("Paraphrased Sentence: " + paraphrasedSentence);
    	    paraphrasedSentence = paraphrasedSentence + sentenceWithProblemID;
    	    TestCase<String,String> mutant = new TestCase<String,String>();
            mutant.input = paraphrasedSentence;	            
            mutant.feature = TestDataFeature.mutant;
    	    mutant.setType("ProgrammingProblem");
    	    testSuite.addTestCase(mutant);
    	    return testSuite;
    	}


    
    	
    	
    	// Load pre-trained GloVe word embeddings into a map
        public static Map<String, double[]> loadWordEmbeddings(String gloveFilePath) throws IOException {
            Map<String, double[]> wordEmbeddings = new HashMap<>();
            BufferedReader reader = new BufferedReader(new FileReader(gloveFilePath));
            String line;

            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(" ");
                String word = parts[0];
                double[] vector = new double[parts.length - 1];

                for (int i = 1; i < parts.length; i++) {
                    vector[i - 1] = Double.parseDouble(parts[i]);
                }

                wordEmbeddings.put(word, vector);
            }

            reader.close();
            return wordEmbeddings;
        }


        // Method to find the nearest word in the embedding space
        public static String findNearestWord(String inputWord, Map<String, double[]> wordEmbeddings) {
            if (wordEmbeddings.containsKey(inputWord)) {
                // The input word is in the embeddings, so let's find the nearest word
                double[] inputVector = wordEmbeddings.get(inputWord);

                String nearestWord = null;
                double maxSimilarity = Double.NEGATIVE_INFINITY;

                for (Map.Entry<String, double[]> entry : wordEmbeddings.entrySet()) {
                    if (!entry.getKey().equals(inputWord)) {
                        double[] vector = entry.getValue();
                        double similarity = cosineSimilarity(inputVector, vector);

                        if (similarity > maxSimilarity) {
                            maxSimilarity = similarity;
                            nearestWord = entry.getKey();
                        }
                    }
                }

                return nearestWord;
            } else {
                // If the input word is not in the embeddings, you can return a placeholder or handle it as needed
                return inputWord;
            }
        }
        
        public static String findNearestWordUsingDistance(String inputWord, Map<String, double[]> wordEmbeddings) {
            if (wordEmbeddings.containsKey(inputWord)) {
                double[] inputVector = wordEmbeddings.get(inputWord);

                String nearestWord = null;
                double minDistance = Double.POSITIVE_INFINITY;
                //System.out.println(minDistance);

                for (Map.Entry<String, double[]> entry : wordEmbeddings.entrySet()) {
                    if (!entry.getKey().equals(inputWord)) {
                        double[] vector = entry.getValue();
                        double distance = euclideanDistance(inputVector, vector);

                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestWord = entry.getKey();
                        }
                    }
                }

                return nearestWord;
            } else {
                // If the input word is not in the embeddings, you can return a placeholder or handle it as needed
                return inputWord;
            }
        }
        
        public static double euclideanDistance(double[] vector1, double[] vector2) {
            double squaredDistance = 0.0;

            for (int i = 0; i < vector1.length; i++) {
                double difference = vector1[i] - vector2[i];
                squaredDistance += difference * difference;
            }

            return Math.sqrt(squaredDistance);
        }

        
        
         // Calculate cosine similarity between two vectors
            public static double cosineSimilarity(double[] vector1, double[] vector2) {
                double dotProduct = 0.0;
                double magnitude1 = 0.0;
                double magnitude2 = 0.0;

                for (int i = 0; i < vector1.length; i++) {
                    dotProduct += vector1[i] * vector2[i];
                    magnitude1 += Math.pow(vector1[i], 2);
                    magnitude2 += Math.pow(vector2[i], 2);
                }

                magnitude1 = Math.sqrt(magnitude1);
                magnitude2 = Math.sqrt(magnitude2);

                if (magnitude1 == 0 || magnitude2 == 0) {
                    // Handle the case where one of the vectors has zero magnitude
                    return 0.0;
                }

                return dotProduct / (magnitude1 * magnitude2);
            }
            
            // Testing the generated code snippet is executable or not.
            @Analyser
        	public void isGeneratedCodeExecutable() {
            	List<String> CodeAnalysis = new ArrayList<>();
            	if (!filePathForCodeAnalysis.isEmpty()) {
            		CodeAnalysis.addAll(filePathForCodeAnalysis);
            	} else {
            		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
            	}
       		  for(String filePath : CodeAnalysis) {
       			File file = new File(filePath);
       		    if (!file.exists()) {
       	            System.err.println("File not found: ");
       	            //return "Not found";
       	            JOptionPane.showMessageDialog(null, "File Not found", "Error", JOptionPane.ERROR_MESSAGE);
       	        }

       	        if (!file.getName().endsWith(".java")) {
       	            System.err.println("Not a Java source file: " );
       	            //return "Not a Java file";
       	            JOptionPane.showMessageDialog(null, "Not a Java file", "Error", JOptionPane.ERROR_MESSAGE);
       	        }

       	        String javaCode = readJavaFile(file);

       	        String mainClassExists = findMainClassName(javaCode);

       	        if (mainClassExists.isEmpty()) {
       	        	JOptionPane.showMessageDialog(null, "Code in the file path : " + file + " is not Executable", "information", JOptionPane.INFORMATION_MESSAGE);
       	        } else {
       	        	JOptionPane.showMessageDialog(null, "Code in the file path : " + file + " is Executable", "Information", JOptionPane.INFORMATION_MESSAGE);
       	        }
       		  }  
       		try {
				ExecutingGeneratedCode();
			} catch (IOException | InterruptedException e) {
				e.printStackTrace();
			}
       	  	}
       	public static String readJavaFile(File file) {
               StringBuilder content = new StringBuilder();
               try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                   String line;
                   while ((line = reader.readLine()) != null) {
                       content.append(line).append("\n");
                   }
               } catch (IOException e) {
                   e.printStackTrace();
                   System.err.println("Error reading Java source code file.");
               }
               return content.toString();
           }
       	
       	public static String findMainClassName(String javaCode) {
               //Pattern pattern = Pattern.compile("public\\s+class\\s+(\\w+)\\s*\\{");
       		   Pattern pattern = Pattern.compile("class\\s+(\\w+)\\s*\\{[^}]*public\\s+static\\s+void\\s+main\\s*\\(");            
               Matcher matcher = pattern.matcher(javaCode);
               if (matcher.find()) {
                   return matcher.group(1);
               }
               return "";
           }
        
       	@Datamorphism
       	public TestPool<String,String> TestCaseForCodeSummarisation (TestCase<String,String> seed) throws IOException {
            
       		codeSnippet = IDSolution.get(currentTestCase.id);
       		            
            TestCase<String,String> mutant = new TestCase<String,String>();
             
            String testcase = " Summarise the code." +"\n"+ codeSnippet;
            
            // Generate a new UUID
            UUID newId = UUID.randomUUID();

            // Convert the UUID to a String
            String idString = newId.toString();
            testcase = testcase + "\n" + "//." + " Problem Id is : " + idString + ".";
            
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<TestCase<String, String>>();
            toBeRemovedTCs.add(currentTestCase);
            testSuite.removeAllTestCases(toBeRemovedTCs);
            
            //mutant.input = testcase.replace("\n", "\\n");
            mutant.input = testcase.replace("\\n", " \n").replace("\r\n", "\\n").replace("\n", "\\n");;
            mutant.feature = TestDataFeature.mutant;
            mutant.id = newId.toString();
            mutant.setType("Code Infilling problem");
            testSuite.addTestCase(mutant);
    	    return testSuite;
       	}       	
       	
       	@Datamorphism
       	public TestPool<String,String> TestCaseForUncommentedCode (TestCase<String,String> seed) throws IOException {
       		codeSnippet = IDSolution.get(currentTestCase.id);
       		
       	    // Remove comments from the Java code.
            String codeWithoutComments = removeComments(codeSnippet);
            
            TestCase<String,String> mutant = new TestCase<String,String>();
            
            String docstring = currentTestCase.input;
            // Load the sentence detection model
            SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
            SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);
            // Split the paragraph into sentences
            String[] sentences = sentenceDetector.sentDetect(docstring);
            String sentenceWithProblemID = "";
            String problemDescription = "";
            // Check if there are sentences
            if (sentences.length > 0) {
                // Extract the last sentence
                sentenceWithProblemID = sentences[sentences.length - 2];
                
                // Extract the main problem description part (excluding the last sentence)
                problemDescription = docstring.substring(0, docstring.lastIndexOf(sentenceWithProblemID));
            }
            
            docstring = problemDescription; // Currently not adding docString to the test case
            
            String testcase = " Add comments to the code." +"\n"+ codeWithoutComments;
            
            // Generate a new UUID
            UUID newId = UUID.randomUUID();

            // Convert the UUID to a String
            String idString = newId.toString();
            testcase = testcase + "\n" + "//." + " Problem Id is : " + idString + ".";
            
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<TestCase<String, String>>();
            toBeRemovedTCs.add(currentTestCase);
            testSuite.removeAllTestCases(toBeRemovedTCs);
            
            //mutant.input = testcase.replace("\n", "\\n");
            //mutant.input = testcase.replace("\\n", " \n").replace("\r\n", "\\n").replace("\n", "\\n");;
            mutant.input = testcase.replace("\\n", " \n").replace("\r\n", "\\n").replace("\n", "\\n");
            mutant.feature = TestDataFeature.mutant;
            mutant.id = newId.toString();
            mutant.setType("Uncommented code problem");
            testSuite.addTestCase(mutant);
    	    return testSuite;
       	}
       	
        // Method to remove comments from Java code.
        private static String removeComments(String code) {
            // Use regular expression to remove both single-line and multi-line comments.
            return code.replaceAll("//.*|/\\*(.|[\\r\\n])*?\\*/", "");
        } 
       	
       	@Datamorphism
       	public TestPool<String,String> TestCaseForCodeInfilling (TestCase<String,String> seed) throws IOException {
       		//List<String> CodeAnalysis = new ArrayList<>();
        	//if (!filePathForCodeAnalysis.isEmpty()) {
        		//CodeAnalysis.addAll(filePathForCodeAnalysis);
        	//} else {
        		//CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	//}
       	 //for(String filePath : CodeAnalysis) {
       	//		File javaFile = new File(filePath);
    		
    		//if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			//JOptionPane.showMessageDialog(null, "Invalid File", "Error", JOptionPane.ERROR_MESSAGE);
                ////return "";
            //}

            //codeSnippet = readJavaFile(javaFile);
       	 //}
       		
       		codeSnippet = IDSolution.get(currentTestCase.id);
       	    // Find function names and bodies
            functionMap = findFunctionNamesAndBodies(codeSnippet);

            // Prompt user to select a function using input dialog
            String modifiedString = selectFunction();
            
            TestCase<String,String> mutant = new TestCase<String,String>();
            
            String docstring = currentTestCase.input;
            seedId = currentTestCase.id;
            // Load the sentence detection model
            SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
            SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);
            // Split the paragraph into sentences
            String[] sentences = sentenceDetector.sentDetect(docstring);
            String sentenceWithProblemID = "";
            String problemDescription = "";
            // Check if there are sentences
            if (sentences.length > 0) {
                // Extract the last sentence
                sentenceWithProblemID = sentences[sentences.length - 2];
                
                // Extract the main problem description part (excluding the last sentence)
                problemDescription = docstring.substring(0, docstring.lastIndexOf(sentenceWithProblemID));
            }
            
            docstring = problemDescription;
            
            String testcase = docstring + " Complete the function where function body is empty." +"\n"+ modifiedString;
            
            // Generate a new UUID
            UUID newId = UUID.randomUUID();

            // Convert the UUID to a String
            String idString = newId.toString();
            testcase = testcase + "\n" + "//." + " Problem Id is : " + idString + ".";
            
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<TestCase<String, String>>();
            toBeRemovedTCs.add(currentTestCase);
            testSuite.removeAllTestCases(toBeRemovedTCs);
            
            //mutant.input = testcase.replace("\n", "\\n");
            mutant.input = testcase.replace("\\n", " \n").replace("\r\n", "\\n").replace("\n", "\\n");;
            mutant.feature = TestDataFeature.mutant;
            mutant.id = newId.toString();
            mutant.setType("Code Infilling problem");
            testSuite.addTestCase(mutant);
    	    return testSuite;
    	    
       	}
       	
       	private static Map<String, String> findFunctionNamesAndBodies(String code) {
            Map<String, String> functionMapTwo = new HashMap<>();
            String pattern = "\\b\\w+\\s+\\w+\\([^\\)]*\\)\\s*(\\{(?:[^{}]|\\{(?:[^{}]|\\{[^{}]*\\})*\\})*\\})";
            Pattern r = Pattern.compile(pattern, Pattern.DOTALL);

            Matcher matcher = r.matcher(code);

            while (matcher.find()) {
                String match = matcher.group(0).trim();
                String functionName = match.split("\\{")[0].trim();
                //functionMapOne.put(functionName, match);
                String functionBody = match.substring(functionName.length() + 1, match.length()).trim();
                functionMapTwo.put(functionName, functionBody);

                System.out.println("Found method: " + functionName);
            }

            return functionMapTwo;
        }

        private static String selectFunction() {
            String[] options = functionMap.keySet().toArray(new String[0]);
            String functionBody = "";
            String selectedFunction = (String) JOptionPane.showInputDialog(
                    null,
                    "Select a function:",
                    "Function Selection",
                    JOptionPane.QUESTION_MESSAGE,
                    null,
                    options,
                    options[0]);

            if (selectedFunction != null) {
                functionBody = functionMap.get(selectedFunction);
                System.out.println("Selected function body:\n" + functionBody);
            } else {
                System.out.println("No function selected.");
            }

            //Printing the code snippet with the selected function signature but without its body
            String replacementString = "{}";
            // Perform the replacement
            String modifiedString = codeSnippet.replace(functionBody, replacementString);

            // Print the modified string
            System.out.println(modifiedString);
            return modifiedString;            
          }
       	
        @Analyser
       	public static void DetectCompilingGivenCode() {
        	// Save given solution
        	String GivenClassName = "GivenSolution";
    		CurrentGivenCodeClassName = GivenClassName;
        	String directoryPathToGiven = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID ;
        	filePathToGivenSolution = directoryPathToGiven + File.separator + GivenClassName + ".java";
        	try {
        	    File newJavaFile = new File(filePathToGivenSolution);
        	    FileWriter writer = new FileWriter(newJavaFile);
        	    writer.write(givenSolutionOfCurrentTestCase);
        	    writer.close();
        	    } catch (IOException e) {
        	    e.printStackTrace();
        	    System.err.println("Error creating the Java file.");
        	}
        	
        	// fetch javafile
       		List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	 for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			JOptionPane.showMessageDialog(null, "Invalid File", "Error", JOptionPane.ERROR_MESSAGE);
                //return "";
            }

    		// compiling process starts
            String javaCode = givenSolutionOfCurrentTestCase;

            String mainClassName = findMainClassName(javaCode);

            if (mainClassName.isEmpty()) {
            	if (mainClassName.isEmpty()) {
                    // If the main class name is not found, select any class name from the code
                    mainClassName = selectRandomClassName(javaCode);

                }
            }

            String directoryPath = javaFile.getParent();
            String newJavaFilePath = directoryPath + File.separator + mainClassName + ".java";
            String newJavaFilePathTwo = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + mainClassName + ".java";
            // The EvoSuite test cases that generated on Given solution needs to be executed on generated code
            // For this purpose in the path to Test_ChatGPT_java project I have to replace the given solution be the generated code by keeping the class name same of the Given solution
            FilePathToGivenSolutionForEvosuitePurpose = newJavaFilePathTwo;
            
            try {
                File newJavaFile = new File(newJavaFilePath);

               // if (!newJavaFile.exists() && newJavaFile.createNewFile()) {
                    FileWriter writer = new FileWriter(newJavaFile);
                    writer.write(javaCode);
                    writer.close();
                    System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
               // } else {
               //     System.err.println("Failed to create main class file.");
               // }
            } catch (IOException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
            }
            String st = generateClassFile(newJavaFilePath);
            System.out.println(st);            
            
            // Generating java file inside java project Test_ChatGPT_Java for Evosuite
            System.out.println(newJavaFilePathTwo);
            
            try {
                File newJavaFile = new File(newJavaFilePathTwo);

                // Check if the file exists
                if (newJavaFile.exists()) {
                    // If the file exists, delete it to overwrite
                    newJavaFile.delete();
                }

                // Create a new file
                if (newJavaFile.createNewFile()) {
                    // Add the package declaration at the top of the file
                    String packageDeclaration = "package testing_ChatGPT_on_java;\n";

                    FileWriter writer = new FileWriter(newJavaFile);
                    writer.write(packageDeclaration);
                    writer.write(javaCode);
                    writer.close();
                    System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
                } else {
                    System.err.println("Failed to create main class file.");
                }
            } catch (IOException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
            }

            String st2 = generateClassFileTwo(newJavaFilePathTwo);
            System.out.println(st2);
        }
       	}       	
       	
    ////////////////////////////
	// For Paraphrases only //
	public static void isGeneratedCodeForParaphrasesCompilable() {
		//String javaCode = "";
		String paraphraseMainClassName = null;
   		List<String> CodeAnalysis = new ArrayList<>();
    	if (!filePathForCodeAnalysis.isEmpty()) {
    		CodeAnalysis.addAll(filePathForCodeAnalysis);
    	} else {
    		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
    	}
    	int count = 0;
   	 for(String filePath : CodeAnalysis) {
   		 if(count < 1) {
   			 count = count + 1;
   			 File javaFile = new File(filePath);
   			
   			String javaCode = readJavaFile(javaFile);
   			
   			if(javaCode == null || javaCode.equals("")) {
   			    nothingGenerated = "nothingGenerated";
   			} else {    
   			    nothingGenerated = "Generated";
   			}

		
		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
			JOptionPane.showMessageDialog(null, "Invalid File", "Error", JOptionPane.ERROR_MESSAGE);
			nothingGenerated = "nothingGenerated";
            //return "";			
        }	else {	
		nothingGenerated = "Generated";
        }
		paraphraseMainClassName = findMainClassName(javaCode);
        // Need to replace paraphraseMainClassName with the main class name of generated code in the java code
        javaCode = javaCode.replace(paraphraseMainClassName, MainClassNameOfGeneratedCode);
        
        if(paraphraseMainClassName.equals(null)) {
        	paraphraseMainClassName = selectRandomClassName(javaCode);
        	javaCode = javaCode.replace(paraphraseMainClassName, MainClassNameOfGeneratedCode);
        }
  //Adding given code in FilePathToGeneratedSolutionForEvosuitePurpose
		// Generating java file inside java project Test_ChatGPT_Java for Evosuite            
 // Generate java file inside java project Test_ChatGPT_Java for Evosuite            
    try {
        Path newJavaFilePath = Paths.get(FilePathToGeneratedSolutionForEvosuitePurpose);
        File newJavaFile = newJavaFilePath.toFile();

        // Check if the file exists
        if (Files.exists(newJavaFilePath)) {
            // If the file exists, delete it to overwrite
            Files.delete(newJavaFilePath);
        }

        // Create a new file
        if (newJavaFile.createNewFile()) {
            // Add the package declaration at the top of the file
            String packageDeclaration = "package testing_ChatGPT_on_java;\n";

            try (FileWriter writer = new FileWriter(newJavaFile)) {
                writer.write(packageDeclaration);
                writer.write(javaCode);
            }
            System.out.println("Main class file created successfully.");
        } else {
            System.err.println("Failed to create main class file.");
        }
    } catch (IOException e) {
        e.printStackTrace();
        System.err.println("Error creating the Java file.");
    }
    String st2 = generateClassFileTwo(FilePathToGeneratedSolutionForEvosuitePurpose);
    System.out.println(st2);   
   		 }//if-count
   	 }
	} 	
       	
       	////////////////////////////
       	// For Paraphrases only //
       	public static void isGeneratedCodeForParaphrasesCompilableTwo() {
       		String paraphraseMainClassName = null;
       		List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	 for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			JOptionPane.showMessageDialog(null, "Invalid File", "Error", JOptionPane.ERROR_MESSAGE);
                //return "";
            }

            String javaCode = readJavaFile(javaFile);
            paraphraseMainClassName = findMainClassName(javaCode);
            // Need to replace paraphraseMainClassName with the main class name of generated code in the java code
            javaCode = javaCode.replace(paraphraseMainClassName, MainClassNameOfGeneratedCode);
            
            if(paraphraseMainClassName.equals(null)) {
            	paraphraseMainClassName = selectRandomClassName(javaCode);
            	javaCode = javaCode.replace(paraphraseMainClassName, MainClassNameOfGeneratedCode);
            }

            //Adding generated code in FilePathToGeneratedSolutionForEvosuitePurpose
       		// Generating java file inside java project Test_ChatGPT_Java for Evosuite            
            try {
                File newJavaFile = new File(FilePathToGeneratedSolutionForEvosuitePurpose);

                // Check if the file exists
                if (newJavaFile.exists()) {
                    // If the file exists, delete it to overwrite
                    newJavaFile.delete();
                }               

                // Create a new file
                if (newJavaFile.createNewFile()) {
                    // Add the package declaration at the top of the file
                    String packageDeclaration = "package testing_ChatGPT_on_java;\n";

                    FileWriter writer = new FileWriter(newJavaFile);
                    writer.write(packageDeclaration);
                    writer.write(javaCode);
                    writer.close();
                    //System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
                } else {
                    System.err.println("Failed to create main class file.");
                }
            } catch (IOException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
            }

            String st2 = generateClassFileTwo(FilePathToGeneratedSolutionForEvosuitePurpose);
            System.out.println(st2);         
        }
       	}
       	
     // For Paraphrases only
    	public static void EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(int i) throws InterruptedException {
    		try {
                // Get the program name from the user
                //BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                //System.out.print("Enter the program name: ");
                //String programName = consoleReader.readLine();
    			String programName = classNameToTestParaphrases;   			
    	        
    	        Thread.sleep(20000);

                // Combine the command with the provided program name
                String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes && \"C:\\Program Files\\Java\\jdk1.8.0_202\\bin\\java\" -cp .;C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes;C:\\Users\\debal\\Downloads\\junit-4.13.jar;C:\\Users\\debal\\Downloads\\hamcrest-core-1.3.jar;C:\\Users\\debal\\Downloads\\evosuite-standalone-runtime-1.0.6.jar org.junit.runner.JUnitCore testing_ChatGPT_on_java." + programName + "_ESTest";

                // Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }

                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("Evosuite Test Case Runner Output");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(800, 600);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteRunner = "EvosuiteTestcaseRunnerOnParaphrase" + Integer.toString(i);
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteRunner.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
	            
	            //saving the question
	            TestCase<String, String> x = testSuite.testSet.get(i);
	            String questionPath = folderPath.concat("\\").concat("task.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(x.input);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        }      	       	
       	
        // For Paraphrases only
    	public static void EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolutionTwo(int i) throws InterruptedException {
    		try {
                // Get the program name from the user
                //BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                //System.out.print("Enter the program name: ");
                //String programName = consoleReader.readLine();
    			String programName = classNameToTestParaphrases;
    			
    			// Adding the test files to the respective java project
    			File fileOne = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java");
    	        File fileTwo = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java");
    	        
    	        String javaCodeOne = readJavaFile(fileOne);
    	        String javaCodeTwo = readJavaFile(fileTwo);
    	                
    	        try {
    	            String destinationDirectoryOne = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java";
    	            String destinationDirectoryTwo = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java";
    	            
    	            File newJavaFileOne = new File(destinationDirectoryOne);
    	            FileWriter writerOne = new FileWriter(newJavaFileOne);
    	            writerOne.write(javaCodeOne);
    	            writerOne.close();
    	            System.out.println("Main class file .java created in the same directory.");

    	            File newJavaFileTwo = new File(destinationDirectoryTwo);
    	            FileWriter writerTwo = new FileWriter(newJavaFileTwo);
    	            writerTwo.write(javaCodeTwo);
    	            writerTwo.close();
    	            System.out.println("Main class file .java created in the same directory.");

    	        } catch (IOException e) {
    	            e.printStackTrace();
    	            System.err.println("Error creating the Java file.");
    	        }

    	        
    	        Thread.sleep(20000);

                // Combine the command with the provided program name
                String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes && \"C:\\Program Files\\Java\\jdk1.8.0_202\\bin\\java\" -cp .;C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes;C:\\Users\\debal\\Downloads\\junit-4.13.jar;C:\\Users\\debal\\Downloads\\hamcrest-core-1.3.jar;C:\\Users\\debal\\Downloads\\evosuite-standalone-runtime-1.0.6.jar org.junit.runner.JUnitCore testing_ChatGPT_on_java." + programName + "_ESTest";

                // Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }

                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("Evosuite Test Case Runner Output");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(800, 600);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteRunner = "EvosuiteTestcaseRunnerOnParaphrase" + Integer.toString(i);
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteRunner.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
	            
	            //saving the question
	            TestCase<String, String> x = testSuite.testSet.get(i);
	            String questionPath = folderPath.concat("\\").concat("task.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(x.input);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        }      	
       	
       	
       	//Testing generated code snippet compiles successfully or not.
       	// DetectCompiling has been changed to isGeneratedCodeCompilable
       	@Analyser
       	public static void isGeneratedCodeCompilable() {
       		List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	 for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			JOptionPane.showMessageDialog(null, "Invalid File", "Error", JOptionPane.ERROR_MESSAGE);
                //return "";
            }

            String javaCode = readJavaFile(javaFile);

            String mainClassName = findMainClassName(javaCode);
            MainClassNameOfGeneratedCode = mainClassName;

            if (mainClassName.isEmpty()) {
            	if (mainClassName.isEmpty()) {
                    // If the main class name is not found, select any class name from the code
                    mainClassName = selectRandomClassName(javaCode);
                    MainClassNameOfGeneratedCode = mainClassName;

                }
            }

            String directoryPath = javaFile.getParent();
            String newJavaFilePath = directoryPath + File.separator + mainClassName + ".java";
            String newJavaFilePathTwo = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + mainClassName + ".java";
            FilePathToGeneratedSolutionForEvosuitePurpose = newJavaFilePathTwo;
            
            try {
                File newJavaFile = new File(newJavaFilePath);

                if (!newJavaFile.exists() && newJavaFile.createNewFile()) {
                    FileWriter writer = new FileWriter(newJavaFile);
                    writer.write(javaCode);
                    writer.close();
                    System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
                } else {
                    System.err.println("Failed to create main class file.");
                }
            } catch (IOException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
            }
            String st = generateClassFile(newJavaFilePath);
            System.out.println(st);            
            
            // Generating java file inside java project Test_ChatGPT_Java for Evosuite
            System.out.println(newJavaFilePathTwo);
            
            try {
                File newJavaFile = new File(newJavaFilePathTwo);

                // Check if the file exists
                if (newJavaFile.exists()) {
                    // If the file exists, delete it to overwrite
                    newJavaFile.delete();
                }

                // Create a new file
                if (newJavaFile.createNewFile()) {
                    // Add the package declaration at the top of the file
                    String packageDeclaration = "package testing_ChatGPT_on_java;\n";

                    FileWriter writer = new FileWriter(newJavaFile);
                    writer.write(packageDeclaration);
                    writer.write(javaCode);
                    writer.close();
                    System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
                } else {
                    System.err.println("Failed to create main class file.");
                }
            } catch (IOException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
            }

            String st2 = generateClassFileTwo(newJavaFilePathTwo);
            System.out.println(st2);
        }
       	}
       	
       	public static void detectCompilingOfGeneratedSolutionGeneratedTestCasesOnGivenSolution(){
       	    // Fetching given code
       		String javaCode = givenSolutionOfCurrentTestCase;      
       		
       		//Adding given code in FilePathToGeneratedSolutionForEvosuitePurpose
       		// Generating java file inside java project Test_ChatGPT_Java for Evosuite            
            try {
                File newJavaFile = new File(FilePathToGeneratedSolutionForEvosuitePurpose);

                // Check if the file exists
                if (newJavaFile.exists()) {
                    // If the file exists, delete it to overwrite
                    newJavaFile.delete();
                }

                // Create a new file
                if (newJavaFile.createNewFile()) {
                    // Add the package declaration at the top of the file
                    String packageDeclaration = "package testing_ChatGPT_on_java;\n";

                    FileWriter writer = new FileWriter(newJavaFile);
                    writer.write(packageDeclaration);
                    writer.write(javaCode);
                    writer.close();
                    //System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
                } else {
                    System.err.println("Failed to create main class file.");
                }
            } catch (IOException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
            }

            String st2 = generateClassFileTwo(FilePathToGeneratedSolutionForEvosuitePurpose);
            System.out.println(st2);
       	}
       	
       	//@Analyser
       	public static void detectCompilingOfGivenSolutionGeneratedTestCasesOnGeneratedCode() {
       		String javaCode = "";
       		// Fetching generated code from the file
       		List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	 for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			JOptionPane.showMessageDialog(null, "Invalid File", "Error", JOptionPane.ERROR_MESSAGE);
                //return "";
            }

            javaCode = readJavaFile(javaFile);
       	 }
       	 
       	 // Adding generated code in FilePathToGivenSolutionForEvosuitePurpose
         // Generating java file inside java project Test_ChatGPT_Java for Evosuite            
            try {
                File newJavaFile = new File(FilePathToGivenSolutionForEvosuitePurpose);

                // Check if the file exists
                if (newJavaFile.exists()) {
                    // If the file exists, delete it to overwrite
                    newJavaFile.delete();
                }

                // Create a new file
                if (newJavaFile.createNewFile()) {
                    // Add the package declaration at the top of the file
                    String packageDeclaration = "package testing_ChatGPT_on_java;\n";

                    FileWriter writer = new FileWriter(newJavaFile);
                    writer.write(packageDeclaration);
                    writer.write(javaCode);
                    writer.close();
                    //System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
                } else {
                    System.err.println("Failed to create main class file.");
                }
            } catch (IOException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
            }

            String st2 = generateClassFileTwo(FilePathToGivenSolutionForEvosuitePurpose);
            System.out.println(st2);
        }      	  	 	
       	
       	
    	public static String generateClassFile(String filePath) {
    		String classFilePath = "";
            try {
                // Create a ProcessBuilder to run the Java program
                ProcessBuilder compileProcessBuilder = new ProcessBuilder("javac", filePath);

                // Redirect the standard error stream
                compileProcessBuilder.redirectErrorStream(true);

                // Set the classpath environment variable to include the directory of the compiled class file
                File sourceFile = new File(filePath);
                String classDirPath = sourceFile.getParent();
                compileProcessBuilder.environment().put("CLASSPATH", classDirPath);

                // Start the compilation process
                Process compileProcess = compileProcessBuilder.start();

                // Wait for the compilation process to finish
                int compileExitCode = compileProcess.waitFor();

                // Check the exit code of the compilation process
                if (compileExitCode == 0) {
                    System.out.println("Java source code compilation successful.");
                    String className = sourceFile.getName().replace(".java", "");
                    classFilePath = classDirPath + File.separator + className + ".class";
                    currentClassFilePath = classFilePath;
                    currentClassName = className;
                    ////JOptionPane.showMessageDialog(null, "Java source code compilation successful for : " + filePath, "information", JOptionPane.INFORMATION_MESSAGE);
                    ////JOptionPane.showMessageDialog(null, "Path to the class file : " + classFilePath , "information", JOptionPane.INFORMATION_MESSAGE);
                    return classFilePath;
                } else {
                    //throw new RuntimeException("Java source code compilation failed.");
                    ////JOptionPane.showMessageDialog(null, "Java source code compilation failed", "information", JOptionPane.INFORMATION_MESSAGE);
                }
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
                return null;
            }
            return classFilePath;
    		
        }
    	
    	public static String generateClassFileTwo(String filePath) {
            try {
                // Create a ProcessBuilder to run the Java program
                ProcessBuilder compileProcessBuilder = new ProcessBuilder("javac", filePath);

                // Redirect the standard error stream
                compileProcessBuilder.redirectErrorStream(true);

                // Set the classpath environment variable to include the directory of the compiled class file
                File sourceFile = new File(filePath);
                String classDirPath = sourceFile.getParent();
                compileProcessBuilder.environment().put("CLASSPATH", classDirPath);

                // Specify the target directory where the compiled class file will be saved
                String classTargetDirectory = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes\\testing_ChatGPT_on_java";

                // Redirect the output (compiled class file) to the target directory
                compileProcessBuilder.directory(new File(classTargetDirectory));

                // Start the compilation process
                Process compileProcess = compileProcessBuilder.start();

                // Wait for the compilation process to finish
                int compileExitCode = compileProcess.waitFor();

                // Check the exit code of the compilation process
                if (compileExitCode == 0) {
                    System.out.println("Java source code compilation successful.");
                    String className = sourceFile.getName().replace(".java", "");
                    String classFilePath = classTargetDirectory + File.separator + className + ".class";
                    currentClassName = className;
                    return classFilePath;
                } else {
                    throw new RuntimeException("Java source code compilation failed.");
                }
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
                return null;
            }
        }
    	
    	
    	//@Analyser
    	public static void SimianCodeSimilarityAnalyzer() {
    		String mainClassName = findMainClassName(givenSolutionOfCurrentTestCase);

            if (mainClassName.isEmpty()) {
            	if (mainClassName.isEmpty()) {
                    // If the main class name is not found, select any class name from the code
                    mainClassName = selectRandomClassName(givenSolutionOfCurrentTestCase);
                }
            }
            String newJavaFilePathTwo = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + mainClassName + ".java";
                   
            // Generating java file inside java project Test_ChatGPT_Java for Simian
            System.out.println(newJavaFilePathTwo);
            
            try {
                File newJavaFile = new File(newJavaFilePathTwo);

                if (!newJavaFile.exists() && newJavaFile.createNewFile()) {
                    // Add the package declaration at the top of the file
                    String packageDeclaration = "package testing_ChatGPT_on_java;\n";

                    FileWriter writer = new FileWriter(newJavaFile);
                    writer.write(packageDeclaration);
                    writer.write(givenSolutionOfCurrentTestCase);
                    writer.close();
                    System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
                } else {
                    System.err.println("Failed to create main class file.");
                }
            } catch (IOException e) {
                e.printStackTrace();
                System.err.println("Error creating the Java file.");
            }
            String st2 = generateClassFileTwo(newJavaFilePathTwo);
            System.out.println(st2);
            
           try {  
        	String generatedProgram = currentClassName;
        	String givenSolution = mainClassName;
        	   
           // Update the command with the new one
            String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java && \"C:\\Program Files\\Java\\jdk-21\\bin\\java\" -jar simian-4.0.0.jar "+ generatedProgram + ".java "+ givenSolution +".java";

            // Run the combined command
            Process process = Runtime.getRuntime().exec(command);

            // Read and accumulate the output
            StringBuilder outputBuilder = new StringBuilder();
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
                outputBuilder.append(line).append("\n");
            }

            // Create a JFrame with JTextArea to display the output
            JFrame frame = new JFrame("Simian Code Similarity Checker Output");
            JTextArea textArea = new JTextArea(outputBuilder.toString());
            textArea.setEditable(false);

            JScrollPane scrollPane = new JScrollPane(textArea);
            frame.add(scrollPane);

            frame.setSize(800, 600);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setVisible(true);
            
            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
        	folderPath = folderPath.concat(currentProblemID);
            String simian = "SimianSimilarityAnalyzer";
            	            
            // Creating a text file with prettyJson
            String textFileName = simian.concat(".txt");
            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                // Write the prettyJSON to the file
                writer2.write(outputBuilder.toString());                    
            } catch (IOException e) {
                e.printStackTrace();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    	}
    	
    	@Analyser
    	public static void GenerateTestCode() throws InterruptedException {
    		EvosuiteTestCaseGenerator();
    		EvosuiteTestCaseRunner();
    		EvosuiteTestCaseGeneratorOnGivenSolution();
    		EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution();    		
    	}    	
    	   	
    	@Analyser
    	public static void purifyReferenceTestCode() throws IOException {
    		String inputFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGivenCode" + File.separator + currentClassNameForReferenceSolution + "_ESTest.java";
    		String outputFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGivenCode" + File.separator + currentClassNameForReferenceSolution + "_ESTestTwo.java";
    		String outputFilePathTwo = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGivenCode" + File.separator + currentClassNameForReferenceSolution + "_ESTestThree.java";
    		
    		copyOriginalFileToNewFile(inputFilePath, outputFilePath);
    		
    		String lastLine = getLastNonEmptyLine(evosuiteRunnerTextFilePathForGiven);
			System.out.println("Last Line: " + lastLine);

			// Check if the last line indicates a test failure
			if (lastLine.contains("Failures:")) {
			    System.out.println("The test suite encountered failures.");
			    try {
                    List<String> failedTestCases = extractFailedTestCases(evosuiteRunnerTextFilePathForGiven);

                    if (failedTestCases.isEmpty()) {
                        System.out.println("No failed test cases found.");
                    } else {
                        System.out.println("Failed Test Cases:");
                        for (String testCase : failedTestCases) {
                            System.out.println(testCase);
                            JOptionPane.showMessageDialog(null, "Failed Test Case : " + testCase, "information", JOptionPane.INFORMATION_MESSAGE);
                        }
                    }
                    try {
                        removeTestCases(inputFilePath, failedTestCases, outputFilePathTwo);
                        removeExtraTestAnnotations(outputFilePathTwo, outputFilePathTwo);
                        System.out.println("Updated Java file created at: " + outputFilePathTwo);
                    } catch (IOException e) {
                        System.err.println("An error occurred while updating the Java file: " + e.getMessage());
                    }
                } catch (IOException e) {
                    System.err.println("An error occurred while reading the file: " + e.getMessage());
                }
			} else if (lastLine.contains("OK (")) {
			    System.out.println("The test suite passed, no actions needed.");
			} else {
			    System.out.println("The last line does not indicate a specific result.");
			}
			copyOriginalFileToNewFile(outputFilePathTwo, inputFilePath);
			JOptionPane.showMessageDialog(null, "Evosuite test file updated after purification at : " + inputFilePath, "information", JOptionPane.INFORMATION_MESSAGE);
    	}
    	
    	public static List<String> extractFailedTestCases(String filePath) throws IOException {
            List<String> failedTestCases = new ArrayList<>();

            try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
                String line;

                // Iterate through the file to find failure patterns
                while ((line = br.readLine()) != null) {
                    Matcher matcher = FAILURE_PATTERN.matcher(line);

                    // If the line matches the failure pattern, extract the test case name
                    if (matcher.find()) {
                        String testCase = matcher.group(1).trim(); // Extract the test case name
                        failedTestCases.add(testCase); // Add to the list
                    }
                }
            }

            return failedTestCases;
        }
    	
    	public static String getLastNonEmptyLine(String filePath) {
            String lastNonEmptyLine = null;

            try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
                String line;

                // Read through the file, keep track of the last non-empty line
                while ((line = br.readLine()) != null) {
                    if (!line.trim().isEmpty()) {
                        lastNonEmptyLine = line.trim();
                    }
                }
            } catch (IOException e) {
                System.err.println("Error reading file: " + e.getMessage());
            }

            return lastNonEmptyLine;
        }
    	
    	public static void removeTestCases(String inputFilePath, List<String> testCasesToRemove, String outputFilePath) throws IOException {
            File inputFile = new File(inputFilePath);
            File outputFile = new File(outputFilePath);

            List<String> linesToRemove = new ArrayList<>();
            for (String testCase : testCasesToRemove) {
                //linesToRemove.add("@Test(timeout = 4000)");
                linesToRemove.add("public void " + testCase + "()  throws Throwable  {");
            }

            try (BufferedReader reader = new BufferedReader(new FileReader(inputFile));
                 BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile))) {

                String line;
                boolean withinTestMethod = false;
                boolean removeNextClosingBrace = false;

                while ((line = reader.readLine()) != null) {
                    if (!withinTestMethod) {
                        for (String lineToRemove : linesToRemove) {
                            if (line.contains(lineToRemove)) {
                                withinTestMethod = true;
                                break;
                            }
                        }
                    }

                    if (!withinTestMethod && !removeNextClosingBrace) {
                        writer.write(line);
                        writer.newLine();
                    }

                    if (line.trim().equals("}")) {
                        if (withinTestMethod) {
                            withinTestMethod = false;
                            removeNextClosingBrace = true;
                        } else {
                            removeNextClosingBrace = false;
                        }
                    }
                }
            }
        }

        public static void removeExtraTestAnnotations(String originalFilePath, String modifiedFilePath) throws IOException {
        	try {
                // Open the original file for reading
                BufferedReader reader = new BufferedReader(new FileReader(originalFilePath));

                // Create a StringBuilder to store the modified content
                StringBuilder modifiedContent = new StringBuilder();

                // Read the original file line by line
                String line;
                
                while ((line = reader.readLine()) != null) {
                    // Modify the content as needed
                    if (!line.trim().startsWith("@Test") && !line.trim().startsWith("public void")) {
                        modifiedContent.append(line).append("\n");
                    }
                    
                    if (line.trim().startsWith("public void")) {
                    	modifiedContent.append("@Test(timeout = 4000)").append("\n").append(line).append("\n");
                    }
                }

                // Close the reader
                reader.close();

                // Write the modified content to a new file
                BufferedWriter writer = new BufferedWriter(new FileWriter(modifiedFilePath));
                writer.write(modifiedContent.toString());
                writer.close();

                System.out.println("Modification complete. New file saved at: " + modifiedFilePath);
            } catch (IOException e) {
                System.err.println("Error: " + e.getMessage());
            }
        }
        
        public static void copyOriginalFileToNewFile(String inputFilePath, String outputFilePath) {
        	try {
                // Create input and output streams
                FileInputStream inputStream = new FileInputStream(inputFilePath);
                FileOutputStream outputStream = new FileOutputStream(outputFilePath);
                
                // Create buffer for efficient copying
                byte[] buffer = new byte[1024];
                int length;
                
                // Read from input stream and write to output stream until the end of file
                while ((length = inputStream.read(buffer)) > 0) {
                    outputStream.write(buffer, 0, length);
                }
                
                // Close streams
                inputStream.close();
                outputStream.close();
                
                System.out.println("File copied successfully.");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    	
    	@Analyser
    	public static void purifySolutionTestCode() throws IOException {
    		    		
    		String inputFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGeneratedCode" + File.separator + currentClassNameForGeneratedSolution + "_ESTest.java";
    		String outputFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGeneratedCode" + File.separator + currentClassNameForGeneratedSolution + "_ESTestTwo.java";
    		String outputFilePathTwo = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGeneratedCode" + File.separator + currentClassNameForGeneratedSolution + "_ESTestThree.java";
    		
    		copyOriginalFileToNewFile(inputFilePath, outputFilePath);
    		
    		String lastLine = getLastNonEmptyLine(evosuiteRunnerTextFilePathForGenerated);
			System.out.println("Last Line: " + lastLine);

			// Check if the last line indicates a test failure
			if (lastLine.contains("Failures:")) {
			    System.out.println("The test suite encountered failures.");
			    try {
                    List<String> failedTestCases = extractFailedTestCases(evosuiteRunnerTextFilePathForGenerated);

                    if (failedTestCases.isEmpty()) {
                        System.out.println("No failed test cases found.");
                    } else {
                        System.out.println("Failed Test Cases:");
                        for (String testCase : failedTestCases) {
                            System.out.println(testCase);
                            JOptionPane.showMessageDialog(null, "Failed Test Case : " + testCase, "information", JOptionPane.INFORMATION_MESSAGE);
                        }
                    }
                    try {
                        removeTestCases(inputFilePath, failedTestCases, outputFilePathTwo);
                        removeExtraTestAnnotations(outputFilePathTwo, outputFilePathTwo);
                        System.out.println("Updated Java file created at: " + outputFilePathTwo);
                    } catch (IOException e) {
                        System.err.println("An error occurred while updating the Java file: " + e.getMessage());
                    }
                } catch (IOException e) {
                    System.err.println("An error occurred while reading the file: " + e.getMessage());
                }
			} else if (lastLine.contains("OK (")) {
			    System.out.println("The test suite passed, no actions needed.");
			} else {
			    System.out.println("The last line does not indicate a specific result.");
			}
			copyOriginalFileToNewFile(outputFilePathTwo, inputFilePath);
			JOptionPane.showMessageDialog(null, "Evosuite test file updated after purification at : " + inputFilePath, "information", JOptionPane.INFORMATION_MESSAGE);
    	}    	
    	
    	@Analyser
    	public static void EvosuiteTestCaseGeneratorOnGivenSolution() throws InterruptedException{
    		try {
                // Get the program name from the user
                //BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                //System.out.print("Enter the program name: ");
                //String programName = consoleReader.readLine();
            	Thread.sleep(20000);
            	String programName = currentClassName;

                // Combine the command with the provided program name
                String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace && \"C:\\Program Files\\Java\\jdk1.8.0_202\\bin\\java\" -jar evosuite-1.0.6.jar -class testing_ChatGPT_on_java." + programName + " -projectCP \"C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes\"";

                // Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and print the output
                //BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                //String line;
                //while ((line = reader.readLine()) != null) {
                //    System.out.println(line);
                    
                //}  
                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }
                
                
                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("Evosuite Test Case Generator Output");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(1000, 800);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteGenerate = "EvosuiteTestCaseGenerationOnGivenSolution";
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteGenerate.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                

            } catch (IOException e) {
                e.printStackTrace();
            }
        	
    	}
    	
    	@Analyser
    	public static void EvosuiteTestCaseGenerator() throws InterruptedException {
            try {
                // Get the program name from the user
                //BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                //System.out.print("Enter the program name: ");
                //String programName = consoleReader.readLine();
            	Thread.sleep(20000);
            	String programName = currentClassName;

                // Combine the command with the provided program name
                String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace && \"C:\\Program Files\\Java\\jdk1.8.0_202\\bin\\java\" -jar evosuite-1.0.6.jar -class testing_ChatGPT_on_java." + programName + " -projectCP \"C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes\"";

                // Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and print the output
                //BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                //String line;
                //while ((line = reader.readLine()) != null) {
                //    System.out.println(line);
                    
                //}  
                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }   
                
                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("Evosuite Test Case Generator Output");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(1000, 800);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteGenerate = "EvosuiteTestCaseGeneration";
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteGenerate.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    	
    	@Analyser
    	public static void EvosuiteTestCaseRunner() throws InterruptedException {
    		try {
                // Get the program name from the user
                //BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                //System.out.print("Enter the program name: ");
                //String programName = consoleReader.readLine();
    			String programName = currentClassName;
    			classNameToTestParaphrases = programName;
    			currentClassNameForGeneratedSolution = currentClassName;
    			
    			// Adding the test files to the respective java project
    			File fileOne = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java");
    	        File fileTwo = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java");
    	        
    	        String javaCodeOne = readJavaFile(fileOne);
    	        String javaCodeTwo = readJavaFile(fileTwo);
    	        
    	        String EvosuiteOnGeneratedCodeFolder = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + "\\EvosuiteOnGeneratedCode";
    	        File folder = new File(EvosuiteOnGeneratedCodeFolder);

    	        if (!folder.exists()) {
    	            folder.mkdirs(); // creates parent folders if they don't exist
    	        }

    	                
    	        try {
    	            String destinationDirectoryOne = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java";
    	            String destinationDirectoryTwo = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java";
    	            
    	            String EvosuiteOnGeneratedCodeFileOne = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGeneratedCode" + File.separator + programName + "_ESTest.java";
    	            String EvosuiteOnGeneratedCodeFileTwo = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGeneratedCode" + File.separator + programName + "_ESTest_scaffolding.java";
    	            
    	            
    	            File newJavaFileOne = new File(destinationDirectoryOne);
    	            FileWriter writerOne = new FileWriter(newJavaFileOne);
    	            writerOne.write(javaCodeOne);
    	            writerOne.close();
    	            System.out.println("Main class file .java created in the same directory.");
    	            
    	            File newJavaFileEvosuiteOne = new File(EvosuiteOnGeneratedCodeFileOne);
    	            FileWriter writerEvosuiteOne = new FileWriter(newJavaFileEvosuiteOne);
    	            writerEvosuiteOne.write(javaCodeOne);
    	            writerEvosuiteOne.close();
    	            System.out.println("Main class file .java created in the folder directory.");

    	            File newJavaFileTwo = new File(destinationDirectoryTwo);
    	            FileWriter writerTwo = new FileWriter(newJavaFileTwo);
    	            writerTwo.write(javaCodeTwo);
    	            writerTwo.close();
    	            System.out.println("Main class file .java created in the same directory.");
    	            
    	            File newJavaFileEvosuiteTwo = new File(EvosuiteOnGeneratedCodeFileTwo);
    	            FileWriter writerEvosuiteTwo = new FileWriter(newJavaFileEvosuiteTwo);
    	            writerEvosuiteTwo.write(javaCodeTwo);
    	            writerEvosuiteTwo.close();
    	            System.out.println("Main class file .java created in the folder directory.");

    	        } catch (IOException e) {
    	            e.printStackTrace();
    	            System.err.println("Error creating the Java file.");
    	        }

    	        
    	        Thread.sleep(20000);

                // Combine the command with the provided program name
                String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes && \"C:\\Program Files\\Java\\jdk1.8.0_202\\bin\\java\" -cp .;C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes;C:\\Users\\debal\\Downloads\\junit-4.13.jar;C:\\Users\\debal\\Downloads\\hamcrest-core-1.3.jar;C:\\Users\\debal\\Downloads\\evosuite-standalone-runtime-1.0.6.jar org.junit.runner.JUnitCore testing_ChatGPT_on_java." + programName + "_ESTest";

                // Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }

                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("Evosuite Test Case Runner Output");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(800, 600);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteRunner = "EvosuiteTestcaseRunner";
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteRunner.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            evosuiteRunnerTextFilePathForGiven = folderPathToTextFile;
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    	
    	@Analyser
    	public static void EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution() throws InterruptedException {
    		try {
                // Get the program name from the user
                //BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                //System.out.print("Enter the program name: ");
                //String programName = consoleReader.readLine();
    			String programName = currentClassName;
    			currentClassNameForReferenceSolution = currentClassName;
    			
    			// Adding the test files to the respective java project
    			File fileOne = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java");
    	        File fileTwo = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java");
    	        
    	        String javaCodeOne = readJavaFile(fileOne);
    	        String javaCodeTwo = readJavaFile(fileTwo);
    	        
    	        String EvosuiteOnGeneratedCodeFolder = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + "\\EvosuiteOnGivenCode";
    	        File folder = new File(EvosuiteOnGeneratedCodeFolder);

    	        if (!folder.exists()) {
    	            folder.mkdirs(); // creates parent folders if they don't exist
    	        }
    	                
    	        try {
    	            String destinationDirectoryOne = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java";
    	            String destinationDirectoryTwo = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java";
    	            
    	            File newJavaFileOne = new File(destinationDirectoryOne);
    	            FileWriter writerOne = new FileWriter(newJavaFileOne);
    	            writerOne.write(javaCodeOne);
    	            writerOne.close();
    	            System.out.println("Main class file .java created in the same directory.");

    	            File newJavaFileTwo = new File(destinationDirectoryTwo);
    	            FileWriter writerTwo = new FileWriter(newJavaFileTwo);
    	            writerTwo.write(javaCodeTwo);
    	            writerTwo.close();
    	            System.out.println("Main class file .java created in the same directory.");
    	            
    	            String EvosuiteOnGivenCodeFileOne = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGivenCode" + File.separator + programName + "_ESTest.java";
    	            String EvosuiteOnGivenCodeFileTwo = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID + File.separator + "EvosuiteOnGivenCode" + File.separator + programName + "_ESTest_scaffolding.java";
    	               	            
    	            File newJavaFileEvosuiteOne = new File(EvosuiteOnGivenCodeFileOne);
    	            FileWriter writerEvosuiteOne = new FileWriter(newJavaFileEvosuiteOne);
    	            writerEvosuiteOne.write(javaCodeOne);
    	            writerEvosuiteOne.close();
    	            System.out.println("Main class file .java created in the folder directory.");
    	            
    	            File newJavaFileEvosuiteTwo = new File(EvosuiteOnGivenCodeFileTwo);
    	            FileWriter writerEvosuiteTwo = new FileWriter(newJavaFileEvosuiteTwo);
    	            writerEvosuiteTwo.write(javaCodeTwo);
    	            writerEvosuiteTwo.close();
    	            System.out.println("Main class file .java created in the folder directory.");

    	        } catch (IOException e) {
    	            e.printStackTrace();
    	            System.err.println("Error creating the Java file.");
    	        }

    	        
    	        Thread.sleep(20000);

                // Combine the command with the provided program name
                String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes && \"C:\\Program Files\\Java\\jdk1.8.0_202\\bin\\java\" -cp .;C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes;C:\\Users\\debal\\Downloads\\junit-4.13.jar;C:\\Users\\debal\\Downloads\\hamcrest-core-1.3.jar;C:\\Users\\debal\\Downloads\\evosuite-standalone-runtime-1.0.6.jar org.junit.runner.JUnitCore testing_ChatGPT_on_java." + programName + "_ESTest";

                // Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }

                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("Evosuite Test Case Runner Output");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(800, 600);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteRunner = "EvosuiteTestcaseRunnerOnGivenCode";
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteRunner.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            evosuiteRunnerTextFilePathForGenerated = folderPathToTextFile;
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    	
    	
    	@Analyser
    	public static void EvosuiteTestCaseRunnerOnGivenCodeForGeneratedSolution() throws InterruptedException {
    		try {
                // Get the program name from the user
                //BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                //System.out.print("Enter the program name: ");
                //String programName = consoleReader.readLine();
    			String programName = currentClassName;
    			
    			// Adding the test files to the respective java project
    			File fileOne = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java");
    	        File fileTwo = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java");
    	        
    	        String javaCodeOne = readJavaFile(fileOne);
    	        String javaCodeTwo = readJavaFile(fileTwo);
    	                
    	        try {
    	            String destinationDirectoryOne = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java";
    	            String destinationDirectoryTwo = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java";
    	            
    	            File newJavaFileOne = new File(destinationDirectoryOne);
    	            FileWriter writerOne = new FileWriter(newJavaFileOne);
    	            writerOne.write(javaCodeOne);
    	            writerOne.close();
    	            System.out.println("Main class file .java created in the same directory.");

    	            File newJavaFileTwo = new File(destinationDirectoryTwo);
    	            FileWriter writerTwo = new FileWriter(newJavaFileTwo);
    	            writerTwo.write(javaCodeTwo);
    	            writerTwo.close();
    	            System.out.println("Main class file .java created in the same directory.");

    	        } catch (IOException e) {
    	            e.printStackTrace();
    	            System.err.println("Error creating the Java file.");
    	        }

    	        
    	        Thread.sleep(20000);

                // Combine the command with the provided program name
                String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes && \"C:\\Program Files\\Java\\jdk1.8.0_202\\bin\\java\" -cp .;C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes;C:\\Users\\debal\\Downloads\\junit-4.13.jar;C:\\Users\\debal\\Downloads\\hamcrest-core-1.3.jar;C:\\Users\\debal\\Downloads\\evosuite-standalone-runtime-1.0.6.jar org.junit.runner.JUnitCore testing_ChatGPT_on_java." + programName + "_ESTest";

                // Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }

                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("Evosuite Test Case Runner Output");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(800, 600);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteRunner = "EvosuiteTestcaseRunnerOnGivenCodeWithTestCasesOfGeneratedCode";
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteRunner.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    	
    	@Analyser
    	public static void EvosuiteTestCaseRunnerOnGeneratedCodeForGivenSolution() throws InterruptedException {
    		try {
                // Get the program name from the user
                //BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                //System.out.print("Enter the program name: ");
                //String programName = consoleReader.readLine();
    			String programName = currentClassName;
    			
    			// Adding the test files to the respective java project
    			File fileOne = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java");
    	        File fileTwo = new File("C:\\Users\\debal\\eclipse-workspace\\evosuite-tests\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java");
    	        
    	        String javaCodeOne = readJavaFile(fileOne);
    	        String javaCodeTwo = readJavaFile(fileTwo);
    	                
    	        try {
    	            String destinationDirectoryOne = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest.java";
    	            String destinationDirectoryTwo = "C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\src\\testing_ChatGPT_on_java" + File.separator + programName + "_ESTest_scaffolding.java";
    	            
    	            File newJavaFileOne = new File(destinationDirectoryOne);
    	            FileWriter writerOne = new FileWriter(newJavaFileOne);
    	            writerOne.write(javaCodeOne);
    	            writerOne.close();
    	            System.out.println("Main class file .java created in the same directory.");

    	            File newJavaFileTwo = new File(destinationDirectoryTwo);
    	            FileWriter writerTwo = new FileWriter(newJavaFileTwo);
    	            writerTwo.write(javaCodeTwo);
    	            writerTwo.close();
    	            System.out.println("Main class file .java created in the same directory.");

    	        } catch (IOException e) {
    	            e.printStackTrace();
    	            System.err.println("Error creating the Java file.");
    	        }

    	        
    	        Thread.sleep(20000);

                // Combine the command with the provided program name
                String command = "cmd /c cd C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes && \"C:\\Program Files\\Java\\jdk1.8.0_202\\bin\\java\" -cp .;C:\\Users\\debal\\eclipse-workspace\\Test_ChatGPT_java\\target\\classes;C:\\Users\\debal\\Downloads\\junit-4.13.jar;C:\\Users\\debal\\Downloads\\hamcrest-core-1.3.jar;C:\\Users\\debal\\Downloads\\evosuite-standalone-runtime-1.0.6.jar org.junit.runner.JUnitCore testing_ChatGPT_on_java." + programName + "_ESTest";

                // Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }

                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("Evosuite Test Case Runner Output");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(800, 600);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteRunner = "EvosuiteTestcaseRunnerOnGeneratedCodeWithTestCasesOfGivenCode";
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteRunner.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    	
    	private static String selectRandomClassName(String javaCode) {
            Pattern pattern = Pattern.compile("class\\s+(\\w+)\\s*\\{");
            Matcher matcher = pattern.matcher(javaCode);
            if (matcher.find()) {
                return matcher.group(1);
            }
            return "";
        }
    
    	 	
    	//@Analyser
    	public void DetectConciseness() {
    		int lineCount = 0, totalLineCountOfGeneratedCode = 0;
    		int lineCountOfGivenSolution = 0;
    		List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
    		for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
       			lineCount = 0;
       			lineCount = countLinesInFile(javaFile);
       			totalLineCountOfGeneratedCode = totalLineCountOfGeneratedCode + lineCount;
                //System.out.println("File: " + filePath + ", Total Lines: " + lineCount);
    		}
    		lineCountOfGivenSolution = countLines(givenSolutionOfCurrentTestCase);
    		
    		if (lineCountOfGivenSolution >= totalLineCountOfGeneratedCode ) {
    			JOptionPane.showMessageDialog(null, "Generated Code is Concised" , "Information", JOptionPane.INFORMATION_MESSAGE);
    			JOptionPane.showMessageDialog(null, "Lines in Generated Code is " + totalLineCountOfGeneratedCode + " where lines in given solution is " + lineCountOfGivenSolution , "Information", JOptionPane.INFORMATION_MESSAGE);
    			
    		}else {
    			int moreLines = totalLineCountOfGeneratedCode - lineCountOfGivenSolution;
    			JOptionPane.showMessageDialog(null, "Generated Code has " + moreLines + "more lines of code than given solution" , "Information", JOptionPane.INFORMATION_MESSAGE);
    		}
    	}
    	
    	public static int countLines(String input) {
            if (input == null || input.isEmpty()) {
                return 0;
            }
            
            // Split the input string by line breaks (newline characters)
            String[] lines = input.split("\\r?\\n");
            
            // Return the count of lines
            return lines.length;
        }
    	
    	public static int countLinesInFile(File file) {
            int lineCount = 0;
            try {
                FileReader fileReader = new FileReader(file);
                BufferedReader bufferedReader = new BufferedReader(fileReader);

                while (bufferedReader.readLine() != null) {
                    lineCount++;
                }

                bufferedReader.close();
                fileReader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

            return lineCount;
        }
    	
    	//@Analyser
    	public void ExecutingGeneratedAndGivenCode() throws IOException, InterruptedException {
    		//Executing Generated code
    		List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
    		if (CodeAnalysis.size() > 0) {
                pathOfGeneratedProgram = CodeAnalysis.get(0);
                
                JTextArea textArea = new JTextArea();
                
                // Displaying the generated program the program
                try {
                    // Read the content of the Java file from a file path
                    File file = new File(pathOfGeneratedProgram); 
                    BufferedReader reader = new BufferedReader(new FileReader(file));
                    String line;
                    while ((line = reader.readLine()) != null) {
                        textArea.append(line + "\n");
                    }
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

                textArea.setLineWrap(true);
                textArea.setWrapStyleWord(true);
                JFrame frame = new JFrame("Generated Code");
            	frame.add(new JScrollPane(textArea));
            	frame.setSize(700, 600);
            	frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            	frame.setVisible(true);
            	
                programOutputTwo = runJavaProgramTwo(pathOfGeneratedProgram);
                //JOptionPane.showMessageDialog(null, programOutputTwo.toString(), "Program Output", JOptionPane.INFORMATION_MESSAGE);
            } 
    		//Executing given solution
    		JTextArea textAreaTwo = new JTextArea(givenSolutionOfCurrentTestCase);
        	JFrame frameTwo = new JFrame("Given Solution");
        	frameTwo.add(new JScrollPane(textAreaTwo));
        	frameTwo.setSize(700, 600);
        	frameTwo.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        	frameTwo.setVisible(true); 
        	
        	String mainClassName = findMainClassName(givenSolutionOfCurrentTestCase);

        	String directoryPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID ;
        	filePathToGivenSolution = directoryPath + File.separator + mainClassName + ".java";

        	try {
        	    File newJavaFile = new File(filePathToGivenSolution);

        	    //if (!newJavaFile.exists() && newJavaFile.createNewFile()) {
        	        FileWriter writer = new FileWriter(newJavaFile);
        	        writer.write(givenSolutionOfCurrentTestCase);
        	        writer.close();
        	        System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
        	    //} else {
        	    //    System.err.println("Failed to create main class file.");
        	    //}
        	} catch (IOException e) {
        	    e.printStackTrace();
        	    System.err.println("Error creating the Java file.");
        	}
        	try {
        	    // Call the runJavaProgram function to compile and execute the Java program
        	    programOutputOne = runJavaProgramTwo(filePathToGivenSolution);
        	    System.out.println("Output of the Java program:");
        	    System.out.println(programOutputOne);
        	    //JOptionPane.showMessageDialog(null, programOutputOne.toString(), "Program Output", JOptionPane.INFORMATION_MESSAGE);
        	} catch (IOException | InterruptedException e) {
        	    e.printStackTrace();
        	}
        	
        	JTextArea textAreaThree = new JTextArea();
        	textAreaThree.append("Output of Given program :" + "\n");
        	textAreaThree.append(programOutputTwo.toString() + "\n");
        	textAreaThree.append("Output of Generated program :" + "\n");
        	textAreaThree.append(programOutputOne.toString());
        	JFrame frameThree = new JFrame("Outputs ");
        	frameThree.add(new JScrollPane(textAreaThree));
        	frameThree.setSize(700, 600);
        	frameThree.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        	frameThree.setVisible(true); 
        	
    		
    	}
    	
    	
    	// Right now considering only one code snippet as given solution from book and considering ChatGPT is giving only one solution.
    	//@Analyser
    	public void ExecutingGeneratedCode() throws IOException, InterruptedException {
    		List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
    		            
            if (CodeAnalysis.size() > 0) {
                pathOfGeneratedProgram = CodeAnalysis.get(0);
                
                JTextArea textArea = new JTextArea();
                
                // Displaying the generated program the program
                try {
                    // Read the content of the Java file from a file path
                    File file = new File(pathOfGeneratedProgram); 
                    BufferedReader reader = new BufferedReader(new FileReader(file));
                    String line;
                    while ((line = reader.readLine()) != null) {
                        textArea.append(line + "\n");
                    }
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

                textArea.setLineWrap(true);
                textArea.setWrapStyleWord(true);
                JFrame frame = new JFrame("Generated Code");
            	frame.add(new JScrollPane(textArea));
            	frame.setSize(700, 600);
            	frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            	frame.setVisible(true);
            	
                programOutputTwo = runJavaProgramTwo(pathOfGeneratedProgram);
            	//String output = runJavaProgram(pathOfGeneratedProgram);
                JOptionPane.showMessageDialog(null, programOutputTwo.toString(), "Program Output", JOptionPane.INFORMATION_MESSAGE);
            } 
    	}
    	
    	public static String runJavaProgram(String sourceFilePath) throws IOException, InterruptedException {
            // Create a ProcessBuilder to run the Java program
            ProcessBuilder processBuilder = new ProcessBuilder("java", sourceFilePath);

            // Redirect the standard output and error streams
            processBuilder.redirectErrorStream(true);

            // Start the process
            Process process = processBuilder.start();

            // Capture the program's output
            InputStream inputStream = process.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
            StringBuilder output = new StringBuilder();

            // Read and append the program's output line by line
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append(System.lineSeparator());
            }

            // Wait for the process to finish
            int exitCode = process.waitFor();

            // Check the exit code
            if (exitCode == 0) {
                return output.toString(); // Return the program's output as a string
            } else {
                throw new RuntimeException("Java program execution failed with exit code: " + exitCode);
            }
        }
    
    	public static StringBuilder runJavaProgramTwo(String sourceFilePath) throws IOException, InterruptedException {
    	    ProcessBuilder processBuilder = new ProcessBuilder("java", sourceFilePath);
    	    processBuilder.redirectErrorStream(true);
    	    Process process = processBuilder.start();

    	    InputStream inputStream = process.getInputStream();
    	    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
    	    StringBuilder output = new StringBuilder();

    	    OutputStream outputStream = process.getOutputStream();
    	    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream));

    	    Thread inputThread = new Thread(() -> {
                try {
                    while (true) {
                        String userInput = JOptionPane.showInputDialog("Enter input (or type 'exit' to quit): ");
                        if (userInput == null || userInput.equalsIgnoreCase("exit")) {
                            break;
                        }
                        writer.write(userInput + "\n");
                        writer.flush();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });

    	    inputThread.start();

    	    String line;
    	    while ((line = reader.readLine()) != null) {
    	        output.append(line).append(System.lineSeparator());
    	    }

    	    int exitCode = process.waitFor();

    	    if (exitCode == 0) {
    	    	output.insert(0, "Output of the Java program:\n\n");
    	        //System.out.println(output.toString());
    	    } else {
    	    	output.insert(0, "Java program execution failed with exit code: " + exitCode + "\n\n");
    	    }

    	    return output; // Return the program's output as a string
    	}

    
    	// Testing Unnecessary comments
    	//@Analyser
    	//public void DetectComments() {}
    	
    	
    	//@Analyser
    	public void ExecutingGivenSolution() throws IOException, InterruptedException{
   		 
    		JTextArea textArea = new JTextArea(givenSolutionOfCurrentTestCase);
        	JFrame frame = new JFrame("Message");
        	frame.add(new JScrollPane(textArea));
        	frame.setSize(700, 600);
        	frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        	frame.setVisible(true); 
        	
        	String mainClassName = findMainClassName(givenSolutionOfCurrentTestCase);

        	String directoryPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID ;
        	filePathToGivenSolution = directoryPath + File.separator + mainClassName + ".java";

        	try {
        	    File newJavaFile = new File(filePathToGivenSolution);

        	    //if (!newJavaFile.exists() && newJavaFile.createNewFile()) {
        	        FileWriter writer = new FileWriter(newJavaFile);
        	        writer.write(givenSolutionOfCurrentTestCase);
        	        writer.close();
        	        System.out.println("Main class file '" + mainClassName + ".java' created in the same directory.");
        	    //} else {
        	    //    System.err.println("Failed to create main class file.");
        	    //}
        	} catch (IOException e) {
        	    e.printStackTrace();
        	    System.err.println("Error creating the Java file.");
        	}
        	try {
        	    // Call the runJavaProgram function to compile and execute the Java program
        	    programOutputOne = runJavaProgramTwo(filePathToGivenSolution);
        	    System.out.println("Output of the Java program:");
        	    System.out.println(programOutputOne);
        	    JOptionPane.showMessageDialog(null, programOutputOne.toString(), "Program Output", JOptionPane.INFORMATION_MESSAGE);
        	} catch (IOException | InterruptedException e) {
        	    e.printStackTrace();
        	}
                 		  
    	}  
    	 	
    	
    	@Metamorphism(
    			applicableTestCase="seed",
    			applicableDatamorphism = "",
    			message="Testing for single numerical outputs"
    			)
    	public boolean TestingSimilarityOfOneNumericalOutput(TestCase<String, String> tc) {
			tc.output = programOutputTwo.toString();
			String outputOfGivenSolution = programOutputOne.toString();
			if (areLastNumericValuesSimilar(tc.output, outputOfGivenSolution)) {
				JOptionPane.showMessageDialog(null, "Outputs of given program and generated program are same.", "Program Output", JOptionPane.INFORMATION_MESSAGE);
	    		return true;
	        } else {
	        	JOptionPane.showMessageDialog(null, "Outputs of given program and generated program are different.", "Program Output", JOptionPane.INFORMATION_MESSAGE);
	    		return false;
	        }
			    		    		
    	}
    	
    	@Metamorphism(
    			applicableTestCase="seed",
    			applicableDatamorphism = "",
    			message="Testing for string outputs with BLEUscore"
    			)
    	public boolean TestingSimilarityOfStringOutputUsingBLEU(TestCase<String, String> tc) {
    		tc.output = programOutputTwo.toString();
			String outputOfGivenSolution = programOutputOne.toString();
			double bleuScore = calculateBLEUScore(tc.output, outputOfGivenSolution);
			if(bleuScore >= 1.0) {
				JOptionPane.showMessageDialog(null, "Outputs of given program and generated program are same.", "Program Output", JOptionPane.INFORMATION_MESSAGE);
	    		return true;
	        } else {
	        	JOptionPane.showMessageDialog(null, "Outputs of given program and generated program are different.", "Program Output", JOptionPane.INFORMATION_MESSAGE);
	    		return false;
	        }
    	}
    	
    	@Metamorphism(
    			applicableTestCase="seed",
    			applicableDatamorphism = "",
    			message="Testing similar string outputs"
    			)
    	public boolean TestingSimilarityOfStringOutput(TestCase<String, String> tc) {
    		tc.output = programOutputTwo.toString();
			String outputOfGivenSolution = programOutputOne.toString();
			if(outputOfGivenSolution.equals(tc.output)) {
			    JOptionPane.showMessageDialog(null, "Outputs of given program and generated program are same.", "Program Output", JOptionPane.INFORMATION_MESSAGE);
	    		return true;
	        } else {
	        	JOptionPane.showMessageDialog(null, "Outputs of given program and generated program are different.", "Program Output", JOptionPane.INFORMATION_MESSAGE);
	    		return false;
	        }
    	}
    	
    	
    	
    	
    	public static double calculateBLEUScore(String reference, String candidate) {
            int genLength = candidate.split("\\s+").length;
            int refLength = reference.split("\\s+").length;

            // Brevity Penalty
            double brevityPenalty = (genLength > refLength) ? 1.0 : Math.exp(1.0 - (refLength / genLength));

            // Clipped precision
            List<Double> clippedPrecisionScores = new ArrayList<>();
            for (int n = 1; n <= 4; n++) { // You can adjust the value of 'n' as needed
                List<String> refNgrams = generateNgrams(reference, n);
                List<String> genNgrams = generateNgrams(candidate, n);
                double c = genNgrams.size();

                Map<String, Long> refNgramCounts = refNgrams.stream()
                        .collect(Collectors.groupingBy(w -> w, Collectors.counting()));

                genNgrams.forEach(gram -> refNgramCounts.merge(gram, 0L, Long::max));

                double clippedPrecision = genNgrams.stream()
                        .mapToDouble(gram -> (double) refNgramCounts.get(gram) / c)
                        .sum();

                clippedPrecisionScores.add(clippedPrecision);
            }

            double[] weights = {0.5, 0.5}; // You can modify the weights based on the number of n-grams you consider
            double logSum = 0.0;
            for (int i = 0; i < weights.length; i++) {
                logSum += weights[i] * Math.log(clippedPrecisionScores.get(i));
            }

            double bleuScore = brevityPenalty * Math.exp(logSum);
            return bleuScore;
        }

        public static List<String> generateNgrams(String text, int n) {
            text = text.toLowerCase();
            String[] tokens = text.split("\\s+");
            List<String> ngrams = new ArrayList<>();
            for (int i = 0; i <= tokens.length - n; i++) {
                ngrams.add(String.join(" ", Arrays.copyOfRange(tokens, i, i + n)));
            }
            return ngrams;
        }
    	
    	public static boolean areLastNumericValuesSimilar(String output1, String output2) {
            // Extract and compare only the last numeric values from the end of the strings
            String lastNumericValue1 = extractLastNumericValue(output1);
            String lastNumericValue2 = extractLastNumericValue(output2);

            // Compare the last numerical values (you can use other methods like Double.parseDouble() for more precision)
            return lastNumericValue1.equals(lastNumericValue2);
        }

        public static String extractLastNumericValue(String output) {
            // Regular expression to match numerical values
            String regex = "\\d+";

            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(output);

            String lastNumericValue = null;

            // Find the last numeric value in reverse order
            while (matcher.find()) {
                lastNumericValue = matcher.group();
            }

            return lastNumericValue;
        }
        
        //@Analyser
    	public void CodeQualityOfGeneratedCodeSnippets() {
        	String stat = "";
        	List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
        	for(String filePath : CodeAnalysis) {
       		int totalCommentCount = 0;
            int todoCount = 0;
            int fixmeCount = 0;
            int xxxCount = 0;
            int totalCodeLines = 0;
            int notMeaningfulWords = 0;

            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    totalCommentCount += countComments(line);
                    todoCount += countOccurrences(line, "TODO");
                    fixmeCount += countOccurrences(line, "FIXME");
                    xxxCount += countOccurrences(line, "XXX");
                    totalCodeLines++;
                 // Split the line into words (based on spaces and other common delimiters)
                    String[] words = line.split("\\s+");

                    for (String word : words) {
                        if (isVariableName(word)) {
                            if (!isMeaningful(word)) {
                                System.out.println("Line " + totalCodeLines + ": Unmeaningful variable name: " + word);
                                notMeaningfulWords++;                        
                            }else {
                            	System.out.println("");
                            }
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            stat = stat + "Code details at : " + filePath + "\n";
            stat = stat +  "Number of Meaningless variable names : " + notMeaningfulWords + "\n";
            //System.out.println("Comments details : ");
            stat = stat + "Total comments: " + totalCommentCount + "\n";
            stat = stat + "TODO comments: " + todoCount + "\n";
            stat = stat + "FIXME comments: " + fixmeCount + "\n";
            stat = stat + "XXX comments: " + xxxCount +"\n";
            double commentFrequency = (double) totalCommentCount / totalCodeLines;
            stat = stat + "Total lines of code: " + totalCodeLines + "\n";
            stat = stat + "Comment frequency: " + commentFrequency;
            
            JTextArea textAreaFour = new JTextArea(stat);
        	JFrame frameFour = new JFrame("Code statistics : ");
        	frameFour.add(new JScrollPane(textAreaFour));
        	frameFour.setSize(700, 600);
        	frameFour.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        	frameFour.setVisible(true); 
        }
        }
        private static int countComments(String line) {
            // Count both single-line and multi-line comments
            Pattern pattern = Pattern.compile("//|/\\*|\\*/");
            Matcher matcher = pattern.matcher(line);
            int count = 0;
            while (matcher.find()) {
                count++;
            }
            return count;
        }

        private static int countOccurrences(String line, String marker) {
            // Count occurrences of a specific marker in a line
            Pattern pattern = Pattern.compile(marker);
            Matcher matcher = pattern.matcher(line);
            int count = 0;
            while (matcher.find()) {
                count++;
            }
            return count;
        }
        
        // Define your criteria for meaningful variable names
        private static boolean isMeaningful(String variableName) {
            // You can define your own rules here
            // For example, check for length, avoid cryptic names, etc.
            return variableName.length() > 1 && !variableName.matches(".*[0-9].*");
        }

        // Define your criteria for variable names (e.g., starts with a lowercase letter)
        private static boolean isVariableName(String word) {
            return word.matches("[a-z][a-zA-Z0-9]*");
        }        
        
        //@Analyser
        public void TestSuiteTestCaseAnalyserPerYear () {
        	
        	// Map to store the count of test cases for each year
            Map<String, Integer> yearCountMap = new HashMap<>();

            // The approach to extract year for each test case
            for (int i = 0; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> x = testSuite.testSet.get(i);
                String id = x.id;
                // Use the get method to fetch the Year based on the ID
                String year = IDYear.get(id);
                //int currentYear = Integer.valueOf(year);
                // Increment the count for the corresponding year
                yearCountMap.put(year, yearCountMap.getOrDefault(year, 0) + 1);
            }

            // Create a bar chart dataset using the map
            DefaultCategoryDataset dataset = new DefaultCategoryDataset();
            for (Map.Entry<String, Integer> entry : yearCountMap.entrySet()) {
                dataset.addValue(entry.getValue(), "Number of Test Cases", entry.getKey());
            }

            // Create a bar chart
            JFreeChart barChart = ChartFactory.createBarChart("Number of Test Cases by Year",
                    "Year", "Number of Test Cases", dataset);

            // Create a JTextArea to display statistics
            JTextArea textArea = new JTextArea();
            textArea.setEditable(false);
            JScrollPane scrollPane = new JScrollPane(textArea);

            // Populate JTextArea with statistics
            StringBuilder stats = new StringBuilder();
            stats.append("Test Cases Statistics:\n");
            for (Map.Entry<String, Integer> entry : yearCountMap.entrySet()) {
                stats.append("Year ").append(entry.getKey()).append(": ").append(entry.getValue()).append(" test cases\n");
            }
            textArea.setText(stats.toString());

            // Create a JFrame to display both the bar chart and the JTextArea
            JFrame frame = new JFrame("Test Cases Statistics");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLayout(new BorderLayout());
            frame.add(new ChartPanel(barChart), BorderLayout.CENTER);
            frame.add(scrollPane, BorderLayout.SOUTH);
            frame.setSize(800, 600);
            frame.setVisible(true);
        }
        
        //@Analyser
        public void StackOverflowTestCaseAnalyserPerYear() {
            // File path of the JSON file containing test cases
            String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVATwo.json";

         // Initialize a map to store the count of test cases for each year
            Map<String, Integer> yearCountMap = new HashMap<>();

            // Parse the JSON file and process each test case
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                JsonNode rootNode = objectMapper.readTree(new File(filePath));
                Iterator<JsonNode> testCasesIterator = rootNode.elements();

                while (testCasesIterator.hasNext()) {
                    JsonNode testCase = testCasesIterator.next();
                    String year = testCase.get("yearOfPostingQuery").asText();

                    // Increment the count for the corresponding year
                    yearCountMap.put(year, yearCountMap.getOrDefault(year, 0) + 1);
                }
                
             // Sort the yearCountMap by key (year) to ensure the years are in increasing order
                Map<String, Integer> sortedYearCountMap = new TreeMap<>(yearCountMap);

                // Create a bar chart dataset using the sorted map
                DefaultCategoryDataset dataset = new DefaultCategoryDataset();
                for (Map.Entry<String, Integer> entry : sortedYearCountMap.entrySet()) {
                    dataset.addValue(entry.getValue(), "Number of Test Cases", entry.getKey());
                }

                JFreeChart barChart = ChartFactory.createBarChart("Number of Test Cases by Year",
                        "Year", "Number of Test Cases", dataset);

                // Display the bar chart in a swing window
                JFrame frame = new JFrame("Test Cases Statistics");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setLayout(new BorderLayout());

                // Create chart panel
                ChartPanel chartPanel = new ChartPanel(barChart);
                frame.add(chartPanel, BorderLayout.CENTER);

                // Create JTextArea to display statistics
                JTextArea textArea = new JTextArea();
                textArea.setEditable(false);
                JScrollPane scrollPane = new JScrollPane(textArea);
                frame.add(scrollPane, BorderLayout.SOUTH);

                // Populate JTextArea with statistics
                StringBuilder stats = new StringBuilder();
                stats.append("Test Cases Statistics:\n");
                for (Map.Entry<String, Integer> entry : yearCountMap.entrySet()) {
                    stats.append("Year ").append(entry.getKey()).append(": ").append(entry.getValue()).append(" test cases\n");
                }
                textArea.setText(stats.toString());

                frame.setSize(800, 600);
                frame.setVisible(true);

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        //@Analyser
        public void StackOverflowOneTopicBasedTestCaseAnalysisOnAllYears() {
            // File path of the JSON file containing test cases
            String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVATwo.json";

            // Prompt the user to input the target keyword
            String targetKeyword = JOptionPane.showInputDialog(null, "Enter the keyword to analyze:", "Keyword Input", JOptionPane.QUESTION_MESSAGE);

            if (targetKeyword != null && !targetKeyword.isEmpty()) {
            
            // Specify the keyword you want to analyze
            //String targetKeyword = "array";

            // Initialize a map to store the count of test cases for the specified keyword for each year
            Map<String, Integer> keywordCountByYearMap = new TreeMap<>();

            // Parse the JSON file and process each test case
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                JsonNode rootNode = objectMapper.readTree(new File(filePath));
                Iterator<JsonNode> testCasesIterator = rootNode.elements();

                while (testCasesIterator.hasNext()) {
                    JsonNode testCase = testCasesIterator.next();
                    String year = testCase.get("yearOfPostingQuery").asText();
                    JsonNode includedTopicsNode = testCase.get("includedTopics");
                    if (includedTopicsNode != null && includedTopicsNode.isArray()) {
                        for (JsonNode topicNode : includedTopicsNode) {
                            String topic = topicNode.asText().toLowerCase();
                            // Check if the topic contains the target keyword
                            if (topic.contains(targetKeyword.toLowerCase())) {
                                // Increment the count for the corresponding year
                                keywordCountByYearMap.put(year, keywordCountByYearMap.getOrDefault(year, 0) + 1);
                                break; // Move to the next test case after finding the keyword
                            }
                        }
                    }
                }
                
                // Create a JTextArea to display the statistics
                JTextArea textArea = new JTextArea();
                textArea.setEditable(false);
                textArea.setLineWrap(true);
                textArea.setWrapStyleWord(true);
                Font font = new Font(Font.MONOSPACED, Font.PLAIN, 12);
                textArea.setFont(font);

                // Append the statistics to the JTextArea
                textArea.append("Test Cases Statistics for Keyword '" + targetKeyword + "' by Year:\n");
                for (Map.Entry<String, Integer> entry : keywordCountByYearMap.entrySet()) {
                    textArea.append("Year " + entry.getKey() + ": " + entry.getValue() + " test cases\n");
                }

                // Create a scroll pane to hold the JTextArea
                JScrollPane scrollPane = new JScrollPane(textArea);

                // Create a bar chart to plot the number of test cases for the specified keyword by year
                DefaultCategoryDataset dataset = new DefaultCategoryDataset();
                for (Map.Entry<String, Integer> entry : keywordCountByYearMap.entrySet()) {
                    dataset.addValue(entry.getValue(), "Number of Test Cases", entry.getKey());
                }
                JFreeChart barChart = ChartFactory.createBarChart(
                        "Number of Test Cases for Keyword '" + targetKeyword + "' by Year",
                        "Year", "Number of Test Cases", dataset, PlotOrientation.VERTICAL, true, true, false);

                // Configure the appearance of the chart
                CategoryPlot plot = barChart.getCategoryPlot();
                CategoryAxis domainAxis = plot.getDomainAxis();
                domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_45); // Rotate the X-axis labels by 45 degrees

                // Create and configure the JFrame
                JFrame frame = new JFrame("Test Cases Statistics for Keyword '" + targetKeyword + "'");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setLayout(new BorderLayout());

                // Add the scroll pane containing the JTextArea to the frame
                frame.add(scrollPane, BorderLayout.SOUTH);
                
                // Create chart panel
                ChartPanel chartPanel = new ChartPanel(barChart);
                frame.add(chartPanel, BorderLayout.CENTER);

                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);

            } catch (IOException e) {
                e.printStackTrace();
            }
        }else {
            JOptionPane.showMessageDialog(null, "No keyword entered. Exiting program.", "Error", JOptionPane.ERROR_MESSAGE);
            System.exit(0);
        }
        }
        
        //@Analyser
        public void StackOverflowTestcaseAnalyserOnListOfTopics() {
            // File path of the JSON file containing test cases
            String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVATwo.json";

            // List of known Java-related topics
            //List<String> javaRelatedTopics = Arrays.asList("array", "thread", "inheritance", "method", "function", "polymorphism");
            List<String> javaRelatedTopics = null;
            
            // Prompt the user to input a list of strings separated by comma
            String input = JOptionPane.showInputDialog(null, "Enter a list of strings separated by comma:", "String List Input", JOptionPane.QUESTION_MESSAGE);

            if (input != null && !input.isEmpty()) {
                // Split the input string by comma to get individual strings
                String[] stringsArray = input.split(",");
                javaRelatedTopics = Arrays.asList(stringsArray);

                // Display the list of strings
                System.out.println("List of strings:");
                for (String str : javaRelatedTopics) {
                    System.out.println(str);
                }
            } else {
                JOptionPane.showMessageDialog(null, "No input provided. Exiting program.", "Error", JOptionPane.ERROR_MESSAGE);
                System.exit(0);
            }
            
            
            
            // Initialize a map to store the count of test cases for each keyword
            Map<String, Integer> keywordCountMap = new HashMap<>();

            // Parse the JSON file and process each test case
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                JsonNode rootNode = objectMapper.readTree(new File(filePath));
                Iterator<JsonNode> testCasesIterator = rootNode.elements();

                while (testCasesIterator.hasNext()) {
                    JsonNode testCase = testCasesIterator.next();
                    JsonNode includedTopicsNode = testCase.get("includedTopics");
                    if (includedTopicsNode != null && includedTopicsNode.isArray()) {
                        for (JsonNode topicNode : includedTopicsNode) {
                            String topic = topicNode.asText().toLowerCase();
                            // Check if any keyword matches the topic
                            for (String keyword : javaRelatedTopics) {
                                if (topic.contains(keyword.toLowerCase())) {
                                    // Increment the count for the corresponding keyword
                                    keywordCountMap.put(keyword, keywordCountMap.getOrDefault(keyword, 0) + 1);
                                }
                            }
                        }
                    }
                }

                // Create a JTextArea to display the statistics
                JTextArea textArea = new JTextArea();
                textArea.setEditable(false);
                textArea.setLineWrap(true);
                textArea.setWrapStyleWord(true);
                Font font = new Font(Font.MONOSPACED, Font.PLAIN, 12);
                textArea.setFont(font);

                // Append the statistics to the JTextArea
                textArea.append("Test Cases Statistics by Keyword:\n");
                for (Map.Entry<String, Integer> entry : keywordCountMap.entrySet()) {
                    textArea.append("Keyword: " + entry.getKey() + ", Number of Test Cases: " + entry.getValue() + "\n");
                }

                // Create a scroll pane to hold the JTextArea
                JScrollPane scrollPane = new JScrollPane(textArea);

                // Create and configure the JFrame
                JFrame frame = new JFrame("Test Cases Statistics");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setLayout(new BorderLayout());

                // Add the scroll pane containing the JTextArea to the frame
                frame.add(scrollPane, BorderLayout.SOUTH);
                
                // Create a bar chart dataset
                DefaultCategoryDataset dataset = new DefaultCategoryDataset();
                for (Map.Entry<String, Integer> entry : keywordCountMap.entrySet()) {
                    dataset.addValue(entry.getValue(), "Number of Test Cases", entry.getKey());
                }

                // Create a bar chart
                JFreeChart barChart = ChartFactory.createBarChart("Number of Test Cases by Topic",
                        "Topic", "Number of Test Cases", dataset);

                // Create chart panel
                ChartPanel chartPanel = new ChartPanel(barChart);
                frame.add(chartPanel, BorderLayout.CENTER);

                frame.setSize(800, 600);
                frame.setVisible(true);

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
       // @Analyser
        public void StackOverflowYearBasedTestcaseAnalyserOnListOfTopics() {
            // File path of the JSON file containing test cases
            String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVATwo.json";

            // List of known Java-related topics
            //List<String> javaRelatedTopics = Arrays.asList("array", "thread", "inheritance", "method", "function");
            // Prompt the user to input a list of strings separated by comma
            List<String> javaRelatedTopics = null;
            String input = JOptionPane.showInputDialog(null, "Enter a list of strings separated by comma:", "String List Input", JOptionPane.QUESTION_MESSAGE);

            if (input != null && !input.isEmpty()) {
                // Split the input string by comma to get individual strings
                String[] stringsArray = input.split(",");
                javaRelatedTopics = Arrays.asList(stringsArray);

                // Display the list of strings
                System.out.println("List of strings:");
                for (String str : javaRelatedTopics) {
                    System.out.println(str);
                }
            } else {
                JOptionPane.showMessageDialog(null, "No input provided. Exiting program.", "Error", JOptionPane.ERROR_MESSAGE);
                System.exit(0);
            }
            
            // Specify the year you want to analyze
            //String targetYear = "2010";
            // Prompt the user to input the target keyword
            String targetYear = JOptionPane.showInputDialog(null, "Enter the Year to analyze:", "Keyword Input", JOptionPane.QUESTION_MESSAGE);

            if (targetYear != null && !targetYear.isEmpty()) {
            // Initialize a map to store the count of test cases for each keyword
            Map<String, Integer> keywordCountMap = new HashMap<>();

            // Parse the JSON file and process each test case
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                JsonNode rootNode = objectMapper.readTree(new File(filePath));
                Iterator<JsonNode> testCasesIterator = rootNode.elements();

                while (testCasesIterator.hasNext()) {
                    JsonNode testCase = testCasesIterator.next();
                    String year = testCase.get("yearOfPostingQuery").asText();
                    // Check if the test case belongs to the target year
                    if (!year.equals(targetYear)) {
                        continue; // Skip the test case if it's not from the target year
                    }
                    JsonNode includedTopicsNode = testCase.get("includedTopics");
                    if (includedTopicsNode != null && includedTopicsNode.isArray()) {
                        for (JsonNode topicNode : includedTopicsNode) {
                            String topic = topicNode.asText().toLowerCase();
                            // Check if any keyword matches the topic
                            for (String keyword : javaRelatedTopics) {
                                if (topic.contains(keyword.toLowerCase())) {
                                    // Increment the count for the corresponding keyword
                                    keywordCountMap.put(keyword, keywordCountMap.getOrDefault(keyword, 0) + 1);
                                }
                            }
                        }
                    }
                }

                // Create a JTextArea to display the statistics
                JTextArea textArea = new JTextArea();
                textArea.setEditable(false);
                textArea.setLineWrap(true);
                textArea.setWrapStyleWord(true);
                Font font = new Font(Font.MONOSPACED, Font.PLAIN, 12);
                textArea.setFont(font);

                // Append the statistics to the JTextArea
                textArea.append("Test Cases Statistics by Keyword for Year " + targetYear + ":\n");
                for (Map.Entry<String, Integer> entry : keywordCountMap.entrySet()) {
                    textArea.append("Keyword: " + entry.getKey() + ", Number of Test Cases: " + entry.getValue() + "\n");
                }

                // Create a scroll pane to hold the JTextArea
                JScrollPane scrollPane = new JScrollPane(textArea);

                // Create and configure the JFrame
                JFrame frame = new JFrame("Test Cases Statistics for Year " + targetYear);
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setLayout(new BorderLayout());
                
                // Add the scroll pane containing the JTextArea to the frame
                frame.add(scrollPane, BorderLayout.SOUTH);
                
                // Create a bar chart dataset
                DefaultCategoryDataset dataset = new DefaultCategoryDataset();
                for (Map.Entry<String, Integer> entry : keywordCountMap.entrySet()) {
                    dataset.addValue(entry.getValue(), "Number of Test Cases", entry.getKey());
                }

                // Create a bar chart
                JFreeChart barChart = ChartFactory.createBarChart("Number of Test Cases by Topic",
                        "Topic", "Number of Test Cases for year " + targetYear, dataset);

                // Create chart panel
                ChartPanel chartPanel = new ChartPanel(barChart);
                frame.add(chartPanel, BorderLayout.CENTER);

                frame.setSize(800, 600);
                frame.setVisible(true); 

            } catch (IOException e) {
                e.printStackTrace();
            }
            }else {
                JOptionPane.showMessageDialog(null, "No keyword entered. Exiting program.", "Error", JOptionPane.ERROR_MESSAGE);
                System.exit(0);
            }
        }
        
        //@Analyser
        public void StackOverflowMaximumNumberOfTestCasesAskedYearWise () {
        	// File path of the JSON file containing test cases
            String filePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\JSONBenchmarkStackOverflowJAVATwo.json";

            // Initialize a map to store the count of test cases for each topic and year
            Map<String, Map<String, Integer>> topicCountByYearMap = new HashMap<>();

            // Parse the JSON file and process each test case
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                JsonNode rootNode = objectMapper.readTree(new File(filePath));
                Iterator<JsonNode> testCasesIterator = rootNode.elements();

                while (testCasesIterator.hasNext()) {
                    JsonNode testCase = testCasesIterator.next();
                    String year = testCase.get("yearOfPostingQuery").asText();
                    JsonNode includedTopicsNode = testCase.get("includedTopics");
                    if (includedTopicsNode != null && includedTopicsNode.isArray()) {
                        for (JsonNode topicNode : includedTopicsNode) {
                            String topic = topicNode.asText();
                            // Exclude the "java" topic
                            if (!shouldExcludeTopic(topic)) {
                                Map<String, Integer> yearCountMap = topicCountByYearMap.getOrDefault(year, new HashMap<>());
                                yearCountMap.put(topic, yearCountMap.getOrDefault(topic, 0) + 1);
                                topicCountByYearMap.put(year, yearCountMap);
                            }
                        }
                    }
                }

                // Create a bar chart dataset
                DefaultCategoryDataset dataset = new DefaultCategoryDataset();
                for (Map.Entry<String, Map<String, Integer>> entry : topicCountByYearMap.entrySet()) {
                    String year = entry.getKey();
                    Map<String, Integer> yearCountMap = entry.getValue();
                    String maxTopic = "";
                    int maxCount = 0;
                    for (Map.Entry<String, Integer> topicEntry : yearCountMap.entrySet()) {
                        if (topicEntry.getValue() > maxCount) {
                            maxTopic = topicEntry.getKey();
                            maxCount = topicEntry.getValue();
                        }
                    }
                    dataset.addValue(maxCount, maxTopic, year);
                }

                // Create a bar chart
                JFreeChart barChart = ChartFactory.createBarChart(
                        "Maximum Number of Test Cases asked for Specific Topic by Year",
                        "Year", "Number of Test Cases", dataset, PlotOrientation.VERTICAL, true, true, false);

                // Display the bar chart in a swing window
                JFrame frame = new JFrame("Test Cases Statistics");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setLayout(new BorderLayout());
                ChartPanel chartPanel = new ChartPanel(barChart);
                frame.add(chartPanel, BorderLayout.CENTER);

                // Create JTextArea to display statistics
                JTextArea textArea = new JTextArea();
                textArea.setEditable(false);
                JScrollPane scrollPane = new JScrollPane(textArea);
                frame.add(scrollPane, BorderLayout.SOUTH);

                // Populate JTextArea with statistics
                StringBuilder stats = new StringBuilder();
                stats.append("Test Cases Statistics:\n");
                for (Map.Entry<String, Map<String, Integer>> entry : topicCountByYearMap.entrySet()) {
                    String year = entry.getKey();
                    Map<String, Integer> yearCountMap = entry.getValue();
                    String maxTopic = "";
                    int maxCount = 0;
                    for (Map.Entry<String, Integer> topicEntry : yearCountMap.entrySet()) {
                        if (topicEntry.getValue() > maxCount) {
                            maxTopic = topicEntry.getKey();
                            maxCount = topicEntry.getValue();
                        }
                    }
                    stats.append("Year: ").append(year).append(", Maximum Topic: ").append(maxTopic)
                            .append(", Total Test Cases: ").append(maxCount).append("\n");
                }
                textArea.setText(stats.toString());

                frame.setSize(800, 600);
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);

            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        // Method to check if a topic should be excluded
        private static boolean shouldExcludeTopic(String topic) {
            String[] excludedTopics = {"java", "eclipse", "android", "spring", "spring-boot", "java-8", "c#"};
            return Arrays.asList(excludedTopics).contains(topic.toLowerCase());
        }
        
        @Analyser
        public static void AnalyseComplexity() {
        	PMDCodeAnalyzerForComplexityOnGeneratedCode();
        	PMDCodeAnalyzerForComplexityOnGivenSolution();
        }
   		  
        @Analyser
        public static void PMDCodeAnalyzerForComplexityOnGeneratedCode() {
        	List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	 for(String filePath : CodeAnalysis) {
       		try {
                // For Cyclomatic Complexity
                //String command = "cmd /c cd C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin && \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\pmd.bat\" check -d \"C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\Destination.java\" -R \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\custom_ruleset.xml\" -f text -r output1Cyclo.txt";
       			String command = "cmd /c cd C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin && \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\pmd.bat\" check -d \"" + filePath + "\" -R \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\custom_ruleset.xml\" -f text -r output1Cyclo.txt";
               
       			// Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }
                
                // For Cognitive complexity
               command = "cmd /c cd C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin && \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\pmd.bat\" check -d \"" + filePath + "\" -R \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\custom_ruleset_Cognitive.xml\" -f text -r output1Cognitive.txt";

                // Run the combined command
                process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }
                               
                // Collecting complexities
                String filePathTwo = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\output1Cyclo.txt";
                try {
                    int cyclomaticComplexity = extractCyclomaticComplexity(filePathTwo);
                    outputBuilder.append("Cyclomatic complexity: " + cyclomaticComplexity).append("\n");
                } catch (IOException e) {
                    System.err.println("Error occurred while reading the file: " + e.getMessage());
                }       
                
                filePathTwo = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\output1Cognitive.txt";

                try {
                    int highestComplexity = extractCognitiveComplexity(filePathTwo);
                    System.out.println("Highest cognitive complexity: " + highestComplexity);
                    outputBuilder.append("Cognitive complexity: " + highestComplexity).append("\n");
                } catch (IOException e) {
                    System.err.println("Error occurred while reading the file: " + e.getMessage());
                }                
                
                int loc = countLinesForLOC(filePath);
                outputBuilder.append("Lines of Code (LOC): " + loc);
                
                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("PMD Code Analyzer Output on complexities");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(1000, 800);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteGenerate = "ComplexitiesOfGeneratedCode";
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteGenerate.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }               

            } catch (IOException e) {
                e.printStackTrace();
            }
       	 }
       	 
        }
        
        @Analyser
        public static void PMDCodeAnalyzerForComplexityOnGivenSolution() {
        	//String destinationFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\Destination.java"; // Path to the destination Java file
        	String mainClassName = findMainClassName(givenSolutionOfCurrentTestCase);

        	String directoryPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\" + currentProblemID ;
        	String filePath = directoryPath + File.separator + mainClassName + ".java";
            try {
                copyJavaCode(givenSolutionOfCurrentTestCase, filePath);
                System.out.println("Java code copied successfully.");
            } catch (IOException e) {
                System.err.println("Error occurred while copying Java code: " + e.getMessage());
            }
        	try {
                // For Cyclomatic Complexity
                //String command = "cmd /c cd C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin && \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\pmd.bat\" check -d \"C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\Destination.java\" -R \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\custom_ruleset.xml\" -f text -r output1Cyclo.txt";
       			String command = "cmd /c cd C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin && \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\pmd.bat\" check -d \"" + filePath + "\" -R \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\custom_ruleset.xml\" -f text -r output1Cyclo.txt";
               
       			// Run the combined command
                Process process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                StringBuilder outputBuilder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }
                
                // For Cognitive complexity
               command = "cmd /c cd C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin && \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\pmd.bat\" check -d \"" + filePath + "\" -R \"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\custom_ruleset_Cognitive.xml\" -f text -r output1Cognitive.txt";

                // Run the combined command
                process = Runtime.getRuntime().exec(command);

                // Read and accumulate the output
                reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    outputBuilder.append(line).append("\n");
                }
                               
                // Collecting complexities
                String filePathTwo = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\output1Cyclo.txt";
                try {
                    int cyclomaticComplexity = extractCyclomaticComplexity(filePathTwo);
                    outputBuilder.append("Cyclomatic complexity: " + cyclomaticComplexity).append("\n");
                } catch (IOException e) {
                    System.err.println("Error occurred while reading the file: " + e.getMessage());
                }       
                
                filePathTwo = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\output1Cognitive.txt";

                try {
                    int highestComplexity = extractCognitiveComplexity(filePathTwo);
                    System.out.println("Highest cognitive complexity: " + highestComplexity);
                    outputBuilder.append("Cognitive complexity: " + highestComplexity).append("\n");
                } catch (IOException e) {
                    System.err.println("Error occurred while reading the file: " + e.getMessage());
                }                
                
                int loc = countLinesForLOC(filePath);
                outputBuilder.append("Lines of Code (LOC): " + loc);
                
                // Create a JFrame with JTextArea to display the output
                //JFrame frame = new JFrame("PMD Code Analyzer Output on complexities");
                //JTextArea textArea = new JTextArea(outputBuilder.toString());
                //textArea.setEditable(false);

                //JScrollPane scrollPane = new JScrollPane(textArea);
                //frame.add(scrollPane);

                //frame.setSize(1000, 800);
                //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                //frame.setVisible(true);
                
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            	folderPath = folderPath.concat(currentProblemID);
                String evosuiteGenerate = "ComplexitiesOfGivenSolution";
	            	            
	            // Creating a text file with prettyJson
	            String textFileName = evosuiteGenerate.concat(".txt");
	            String folderPathToTextFile = folderPath.concat("\\").concat(textFileName);
	            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(folderPathToTextFile))) {
                    // Write the prettyJSON to the file
                    writer2.write(outputBuilder.toString());                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
	            } catch (IOException e) {
                    e.printStackTrace();
                }                
        }
        
        public static void copyJavaCode(String javaCode, String destinationFilePath) throws IOException {
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(destinationFilePath))) {
                writer.write(javaCode);
            }
        } 
        
        public static int extractCognitiveComplexity(String filePath) throws IOException {
            int highestComplexity = 0;

            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    // Search for the phrase 'has a cognitive complexity of '
                    int startIndex = line.indexOf("has a cognitive complexity of ");
                    if (startIndex != -1) {
                        // Extract the complexity value
                        startIndex += "has a cognitive complexity of ".length();
                        int endIndex = line.indexOf(",", startIndex);
                        if (endIndex != -1) {
                            String complexityString = line.substring(startIndex, endIndex);
                            // Parse the extracted complexity number
                            int complexity = Integer.parseInt(complexityString);
                            // Update the highest complexity if needed
                            if (complexity > highestComplexity) {
                                highestComplexity = complexity;
                            }
                        }
                    }
                }
            }

            return highestComplexity;
        }
        
        public static int extractCyclomaticComplexity(String filePath) throws IOException {
            int highestComplexity = 0;

            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    // Search for the phrase 'has a total cyclomatic complexity of '
                    int startIndex = line.indexOf("has a total cyclomatic complexity of ");
                    if (startIndex != -1) {
                        // Extract the complexity value
                        startIndex += "has a total cyclomatic complexity of ".length();
                        int endIndex = line.indexOf(" ", startIndex);
                        if (endIndex != -1) {
                            String complexityString = line.substring(startIndex, endIndex);
                            // Parse the extracted complexity number
                            int complexity = Integer.parseInt(complexityString);
                            // Update the highest complexity if needed
                            if (complexity > highestComplexity) {
                                highestComplexity = complexity;
                            }
                        }
                    }
                }
            }

            return highestComplexity;
        }
        
        public static int extractCyclomaticComplexityTwo(String filePath) throws IOException {
        	int complexity = 0;
            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    // Search for the phrase 'a total cyclomatic complexity of '
                    int startIndex = line.indexOf("a total cyclomatic complexity of ");
                    if (startIndex != -1) {
                        // Extract the number that follows the phrase
                        startIndex += "a total cyclomatic complexity of ".length();
                        int endIndex = line.indexOf(" ", startIndex);
                        if (endIndex != -1) {
                            String complexityString = line.substring(startIndex, endIndex);
                            // Parse the extracted complexity number
                            complexity = Integer.parseInt(complexityString);
                            System.out.println("Cyclomatic complexity: " + complexity);
                        }
                    }
                }
            }
			return complexity;
        }
        public static int countLinesForLOC(String filePath) throws IOException {
            int loc = 0;

            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    // Ignore empty lines and lines containing only whitespace
                    if (!line.trim().isEmpty()) {
                        loc++;
                    }
                }
            }

            return loc;
        }
        
        //@Analyser
        public void ParaphraseRunner()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String selectedExecutor = null;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
        	//try {                
                //ChatGPT(x.input);
                //Falcon7B(x.input);
                //openCoPilot(x.input);
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                //}
            	try {
                EvosuiteTestCaseGenerator();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunner();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }
            	try {
                DetectCompilingGivenCode();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseGeneratorOnGivenSolution();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution(); 
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                detectCompilingOfGivenSolutionGeneratedTestCasesOnGeneratedCode();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                EvosuiteTestCaseRunnerOnGeneratedCodeForGivenSolution();
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }        
                
                try {
                detectCompilingOfGeneratedSolutionGeneratedTestCasesOnGivenSolution();
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                EvosuiteTestCaseRunnerOnGivenCodeForGeneratedSolution();
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                    isGeneratedCodeCompilable();
                }
                catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                    EvosuiteTestCaseGenerator();
                } catch (Exception e) {
                        System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
                try {
                    EvosuiteTestCaseRunner();
                } catch (Exception e) {
                        System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                
                List<String> paraphrases = new ArrayList<>();
               
                for (int i = 1; i < testSuite.testSet.size(); i++) {
                	try {
                        TestCase<String, String> y = testSuite.testSet.get(i);
                        paraphrases.add(y.input);
                        //ChatGPT(x.input);
                        //Falcon7B(x.input);
                        //openCoPilot(y.input);
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7B(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilot(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2(x.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiPro(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                	try {
                		isGeneratedCodeForParaphrasesCompilable();
                    	}
                        catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	try {
                		EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	}catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }         
                	String distance = computeDistancesBetweenParaphrases(Task, paraphrases.get(i - 1));
                	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	folderPath = folderPath.concat(currentProblemID);
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                }                
        }
        
        public static String computeDistancesBetweenParaphrases(String task, String paraphrase) throws FileNotFoundException, IOException {
        	String sentence1 = task;
            String sentence2 = paraphrase;
            String distances = null;
            
            // Load the sentence detection model
            SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
            SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

            // Split the paragraph into sentences
            String input = sentence1;
            String[] sentences = sentenceDetector.sentDetect(input);
            String sentenceWithProblemID = "";
            String problemDescription = "";        
            
            // Check if there are sentences
            if (sentences.length > 0) {
                // Extract the last sentence
                sentenceWithProblemID = sentences[sentences.length - 1];
                String uptoProgLanguage = sentences[sentences.length - 2];
                
                // Extract the main problem description part (excluding the last two sentence)
                problemDescription = input.substring(0, input.lastIndexOf(uptoProgLanguage));
            }
            //String sentenceToParaphrase = "Problem Description : \n12.10 (Fraction) Create a class Fraction with two integer final fields:\nnumerator and denominator. Its constructor creates fractions when given values\nfor both, but it has to avoid fractions with null denominators by throwing a\nNullDenominatorException of Programming Exercise 12.7.\n\n The programming language you need to use is: Java.";
            
            String sentence = problemDescription;
            sentence1 = sentence.replace("\r\n", "").replace("Problem Description :", "");
            
            // Split the paragraph into sentences
            input = sentence2;
            sentences = sentenceDetector.sentDetect(input);
            sentenceWithProblemID = "";
            problemDescription = "";        
            
            // Check if there are sentences
            if (sentences.length > 0) {
                // Extract the last sentence
                sentenceWithProblemID = sentences[sentences.length - 1];
                String uptoProgLanguage = sentences[sentences.length - 2];
                
                // Extract the main problem description part (excluding the last two sentence)
                problemDescription = input.substring(0, input.lastIndexOf(uptoProgLanguage));
            }
            //String sentenceToParaphrase = "Problem Description : \n12.10 (Fraction) Create a class Fraction with two integer final fields:\nnumerator and denominator. Its constructor creates fractions when given values\nfor both, but it has to avoid fractions with null denominators by throwing a\nNullDenominatorException of Programming Exercise 12.7.\n\n The programming language you need to use is: Java.";
            
            sentence = problemDescription;
            sentence2 = sentence.replace("\r\n", "").replace("Problem Description :", "");

            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe"; // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\compute_distances.py"; // Update with the actual path to your Python script

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);
            command.add(sentence1);
            command.add(sentence2);

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Read the output from the Python script
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;

                // Read all lines of output from Python                
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                    distances = distances + line;
                }

                // Wait for the process to complete
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            return distances;
        }
        
        //@Analyser
        public void SelectedParaphraseRunner() throws FileNotFoundException, IOException, InterruptedException {
        	String userInput = JOptionPane.showInputDialog("Enter test case ID to execute: ");
        	
            for (int i = 0; i < testSuite.testSet.size(); i++) { 
            	TestCase<String, String> x = testSuite.testSet.get(i);
                String id = x.id;
                if (userInput.equals(id)) {
                	//ChatGPT(x.input);
                    //Falcon7B(x.input);
                	//openCoPilot(x.input);
                	// Create a JComboBox for selecting the executor
                    String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro"};
                    JComboBox<String> executorComboBox = new JComboBox<>(executors);

                    // Show the dropdown dialog to the user
                    int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                            JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

                    if (result == JOptionPane.OK_OPTION) {
                        String selectedExecutor = (String) executorComboBox.getSelectedItem();
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(x.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7B(x.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilot(x.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2(x.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiPro(x.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    }
                	try {
                		isGeneratedCodeForParaphrasesCompilable();
                    	}
                        catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	try {
                		EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	}catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }         
                	String distance = computeDistancesBetweenParaphrases(x.input, testSuite.testSet.get(0).input);
                	String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	folderPath = folderPath.concat(currentProblemID);
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        
        //@Analyser
        public void SelectedTestCaseRunnerTwo() throws FileNotFoundException, IOException, InterruptedException {
        	numberOfAttempts = 1;
        	String Task = null;
        	String selectedExecutor = null;
        	long startTime = System.currentTimeMillis();
        	String userInput = JOptionPane.showInputDialog("Enter test case ID to execute: ");
        	
            for (int i = 0; i < testSuite.testSet.size(); i++) { 
            	TestCase<String, String> x = testSuite.testSet.get(i);
                String id = x.id;
                Task = x.input;
                if (userInput.equals(id)) {
                	// Create a JComboBox for selecting the executor
                    String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
                    JComboBox<String> executorComboBox = new JComboBox<>(executors);

                    // Show the dropdown dialog to the user
                    int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                            JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

                    if (result == JOptionPane.OK_OPTION) {
                        selectedExecutor = (String) executorComboBox.getSelectedItem();
                        
                        long startModelExecutionTime = System.currentTimeMillis();
                        
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(x.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7B(x.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilot(x.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2(x.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiPro(x.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                        
                        long endModelExecutionTime = System.currentTimeMillis();
                        long timeStampForExecution = endModelExecutionTime - startModelExecutionTime;
                        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        folderPath = folderPath.concat(currentProblemID);
                        String TimePathForExecution = folderPath.concat("\\").concat("ElapsedTimeForModelExecution.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePathForExecution))) {
                            // Write the Time to the file
                            writer2.write(Long.toString(timeStampForExecution)+ " milliseconds");
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        }
                    }
                    
                	//} catch (Exception e) {
                    //    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                    //}
                	try {
                    EvosuiteTestCaseGenerator();
                	} catch (Exception e) {
                        System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                    }
                	try {
                    EvosuiteTestCaseRunner();
                	} catch (Exception e) {
                        System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                    }
                	try {
                    DetectCompilingGivenCode();
                	}
                    catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }
                	try {
                    EvosuiteTestCaseGeneratorOnGivenSolution();
                	}
                    catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }
                	try {
                    EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution(); 
                	}
                    catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }
                	try {
                    detectCompilingOfGivenSolutionGeneratedTestCasesOnGeneratedCode();// replacing given solution by generated code and compile, to run test cases generated on Given solution by Evosuite on generated code
                	}
                    catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }
                    try {
                    EvosuiteTestCaseRunnerOnGeneratedCodeForGivenSolution();
                    }
                    catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }        
                    
                    try {
                    detectCompilingOfGeneratedSolutionGeneratedTestCasesOnGivenSolution(); ////
                    }
                    catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }
                    try {
                    EvosuiteTestCaseRunnerOnGivenCodeForGeneratedSolution(); ////
                    }
                    catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }  
                    
                    // Saving the task
                    String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    folderPath = folderPath.concat(currentProblemID);
                    String questionPath = folderPath.concat("\\").concat("task.txt");

                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                        // Write the Task to the file
                        writer2.write(Task);
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    }
                    long endTime = System.currentTimeMillis();
                    long timeStamp = endTime - startTime;
                    String TimePath = folderPath.concat("\\").concat("ElapsedTime.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                        // Write the Time to the file
                        writer2.write(Long.toString(timeStamp)+ " milliseconds");
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    }
                    //try {
                    //	GeminiProTestCaseGenerator(Task);
                    //}catch(IOException e) {
                    //    System.out.println("An exception occurred while generating test cases: " + e.getMessage());
                    //}
                    //DetectCompiling();
                    //PMDCodeAnalyzerForComplexityOnGeneratedCode();
                    //PMDCodeAnalyzerForComplexityOnGivenSolution();    
                    
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                }
            }
                }
        
        @Analyser
        public void SelectedTestCaseRunner() throws FileNotFoundException, IOException, InterruptedException {
        	numberOfAttempts = 1;
        	String Task = null;
        	String selectedExecutor = null;
        	long startTime = System.currentTimeMillis();
        	String userInput = JOptionPane.showInputDialog("Enter test case ID to execute: ");
        	
            for (int i = 0; i < testSuite.testSet.size(); i++) { 
            	TestCase<String, String> x = testSuite.testSet.get(i);
                String id = x.id;
                Task = x.input;
                if (userInput.equals(id)) {
                	// Create a JComboBox for selecting the executor
                    String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
                    JComboBox<String> executorComboBox = new JComboBox<>(executors);

                    // Show the dropdown dialog to the user
                    int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                            JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

                    if (result == JOptionPane.OK_OPTION) {
                        selectedExecutor = (String) executorComboBox.getSelectedItem();
                        
                        long startModelExecutionTime = System.currentTimeMillis();
                        
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(x.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7B(x.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilot(x.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2(x.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiPro(x.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                        
                        long endModelExecutionTime = System.currentTimeMillis();
                        long timeStampForExecution = endModelExecutionTime - startModelExecutionTime;
                        String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        folderPath = folderPath.concat(currentProblemID);
                        String TimePathForExecution = folderPath.concat("\\").concat("ElapsedTimeForModelExecution.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePathForExecution))) {
                            // Write the Time to the file
                            writer2.write(Long.toString(timeStampForExecution)+ " milliseconds");
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        }
                    }
                    
                	//} catch (Exception e) {
                    //    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                    //}
                 // Create an executor service with a single thread
                    ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();

                    // Timeout duration in seconds
                    int timeoutDurationThree = 2 * 60; // 2 minutes

                    // Task 1: EvosuiteTestCaseGenerator
                    Future<?> future1Three = executorThree.submit(() -> {
                        try {
                            EvosuiteTestCaseGenerator();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 1 timed out.");
                        future1Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 2: EvosuiteTestCaseRunner
                    Future<?> future2Three = executorThree.submit(() -> {
                        try {
                            EvosuiteTestCaseRunner();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 2 timed out.");
                        future2Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 3: DetectCompilingGivenCode
                    Future<?> future3Three = executorThree.submit(() -> {
                        try {
                            DetectCompilingGivenCode();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while detecting compilation for given code: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future3Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 3 timed out.");
                        future3Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 4: EvosuiteTestCaseGeneratorOnGivenSolution
                    Future<?> future4Three = executorThree.submit(() -> {
                        try {
                            EvosuiteTestCaseGeneratorOnGivenSolution();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while generating Evosuite test cases on given solution: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future4Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 4 timed out.");
                        future4Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 5: EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution
                    Future<?> future5Three = executorThree.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running Evosuite test cases on given solution: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future5Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 5 timed out.");
                        future5Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 6: detectCompilingOfGivenSolutionGeneratedTestCasesOnGeneratedCode
                    Future<?> future6Three = executorThree.submit(() -> {
                        try {
                            detectCompilingOfGivenSolutionGeneratedTestCasesOnGeneratedCode();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while detecting compilation of generated solution's test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future6Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 6 timed out.");
                        future6Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 7: EvosuiteTestCaseRunnerOnGeneratedCodeForGivenSolution
                    Future<?> future7Three = executorThree.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnGeneratedCodeForGivenSolution();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running Evosuite test cases on generated code for given solution: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future7Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 7 timed out.");
                        future7Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 8: detectCompilingOfGeneratedSolutionGeneratedTestCasesOnGivenSolution
                    Future<?> future8Three = executorThree.submit(() -> {
                        try {
                            detectCompilingOfGeneratedSolutionGeneratedTestCasesOnGivenSolution();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while detecting compilation of generated solution's test cases on given solution: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future8Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 8 timed out.");
                        future8Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 9: EvosuiteTestCaseRunnerOnGivenCodeForGeneratedSolution
                    Future<?> future9Three = executorThree.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnGivenCodeForGeneratedSolution();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running Evosuite test cases on given code for generated solution: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future9Three.get(timeoutDurationThree, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 9 timed out.");
                        future9Three.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Shut down the executor service
                    executorThree.shutdown();

                    
                    // Saving the task
                    String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    folderPath = folderPath.concat(currentProblemID);
                    String questionPath = folderPath.concat("\\").concat("task.txt");

                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                        // Write the Task to the file
                        writer2.write(Task);
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    }
                    long endTime = System.currentTimeMillis();
                    long timeStamp = endTime - startTime;
                    String TimePath = folderPath.concat("\\").concat("ElapsedTime.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                        // Write the Time to the file
                        writer2.write(Long.toString(timeStamp)+ " milliseconds");
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    }
                    //try {
                    //	GeminiProTestCaseGenerator(Task);
                    //}catch(IOException e) {
                    //    System.out.println("An exception occurred while generating test cases: " + e.getMessage());
                    //}
                    //DetectCompiling();
                    //PMDCodeAnalyzerForComplexityOnGeneratedCode();
                    //PMDCodeAnalyzerForComplexityOnGivenSolution();    
                    
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                }
            }
                }
                	
        
        
        @Analyser
        public void TestCaseRunner() throws FileNotFoundException, IOException, InterruptedException {
        	String Task = null;
        	String selectedExecutor;
            for (int i = 0; i < testSuite.testSet.size(); i++) {
            	try {
                TestCase<String, String> x = testSuite.testSet.get(i);
                Task = x.input;
                //ChatGPT(x.input);
                //Falcon7B(x.input);
                //openCoPilot(x.input);
                //GeminiPro(x.input);
                
                // Create a JComboBox for selecting the executor
                String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
                JComboBox<String> executorComboBox = new JComboBox<>(executors);

                // Show the dropdown dialog to the user
                int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                        JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

                if (result == JOptionPane.OK_OPTION) {
                    selectedExecutor = (String) executorComboBox.getSelectedItem();
                    if(selectedExecutor == "ChatGPT") {
                    	ChatGPT(x.input);
                    }else if(selectedExecutor == "Falcon7B"){
                    	Falcon7B(x.input);
                    }else if(selectedExecutor == "openCoPilot") {
                    	openCoPilot(x.input);
                    }else if(selectedExecutor == "Llama2") {
                    	LLama2(x.input);
                    }else if(selectedExecutor == "GeminiPro") {
                    	GeminiPro(x.input);
                    }else {
                    	System.out.println("Not a valid executer");
                    }
                }
                
            	} catch (Exception e) {
                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseGenerator();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunner();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }
            	try {
                DetectCompilingGivenCode();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseGeneratorOnGivenSolution();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution(); 
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                detectCompilingOfGivenSolutionGeneratedTestCasesOnGeneratedCode();// replacing given solution by generated code and compile, to run test cases generated on Given solution by Evosuite on generated code
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                EvosuiteTestCaseRunnerOnGeneratedCodeForGivenSolution();
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }        
                
                try {
                detectCompilingOfGeneratedSolutionGeneratedTestCasesOnGivenSolution(); ////
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                EvosuiteTestCaseRunnerOnGivenCodeForGeneratedSolution(); ////
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }  
                
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                //try {
                //	GeminiProTestCaseGenerator(Task);
                //}catch(IOException e) {
                //    System.out.println("An exception occurred while generating test cases: " + e.getMessage());
                //}
                //DetectCompiling();
                //PMDCodeAnalyzerForComplexityOnGeneratedCode();
                //PMDCodeAnalyzerForComplexityOnGivenSolution();    
                
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
            }
        }
        
        //@Analyser
        public static void ParaphraseDistanceCalculatorUsingBatchWriting() {
        	// Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;

            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(ID_of_Task);
            String outputFilePath = folderPath.concat("\\").concat("ParaphraseDistance.csv");

            // Ensure the folder path exists
            Path path = Paths.get(folderPath);
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // Prepare the CSV file writer
            try (FileWriter csvWriter = new FileWriter(outputFilePath)) {
                // Write CSV header
                csvWriter.append("ID_of_Task,ID_of_Paraphrase,Cosine_Distance,Euclidean_Distance,Task,Paraphrase\n");

                // Batch writing variables
                StringBuilder csvBuffer = new StringBuilder();
                int batchSize = 1000;  // Adjust batch size as needed
                AtomicInteger batchCount = new AtomicInteger();

                // Loop through the paraphrases
                for (int i = 1; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> y = testSuite.testSet.get(i);
                    String id_of_paraphrase = y.id;
                    String paraphrase = y.input;

                    // Compute the distances
                    String distance = computeDistancesBetweenParaphrases(Task, paraphrase);
                    double cosine_distance = cosineExtractor(distance);
                    double euclidean_distance = euclideanExtractor(distance);

                    // Prepare CSV line
                    csvBuffer.append(ID_of_Task).append(",")
                             .append(id_of_paraphrase).append(",")
                             .append(String.valueOf(cosine_distance)).append(",")
                             .append(String.valueOf(euclidean_distance)).append(",")
                             .append(Task.replace(",", " ").replace("\n", " ")).append(",")
                             .append(paraphrase.replace(",", " ").replace("\n", " ")).append("\n");

                    // Write batch to file every batchSize iterations
                    if (batchCount.incrementAndGet() % batchSize == 0) {
                        csvWriter.append(csvBuffer.toString());
                        csvBuffer.setLength(0);  // Clear the buffer
                    }
                }

                // Write any remaining lines in the buffer
                if (csvBuffer.length() > 0) {
                    csvWriter.append(csvBuffer.toString());
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        //@Analyser
        public static void ParaphraseSimilarityCalculatorToHashMapSequentially() {
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;

            // Loop through the paraphrases and compute similarity scores sequentially
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Log the input for debugging
                System.out.println("Computing task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                try {
                    // Compute the distances
                    double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);

                    // Store the results in the HashMap
                    distanceMap.put(id_of_paraphrase, distance);
                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println("Failed to compute distance for paraphrase: " + id_of_paraphrase);
                }
            }

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double maxDistance = Double.NEGATIVE_INFINITY;

            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) {
                    maxDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue();
                }
            }

            double minDistance = Double.POSITIVE_INFINITY;

            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) {
                    minDistance = entry.getValue();
                    maxId = entry.getKey(); // holding ID with minimum similarity or maximum dissimilarity
                }
            }
        }
        
        //@Analyser
        public static void ParaphraseSimilarityCalculatorToHashMapUsingParallelization() {
        	long startTime = System.currentTimeMillis();
        	
        	// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();

                	
        	distanceMap.clear();// Clear the content of previous execution
        	semanticDistanceMap.clear();
        	paraphraseMutantMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        semanticDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        paraphraseMutantMap.put(testSuite.testSet.get(i + 1).id, testSuite.testSet.get(i + 1).input);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double maxDistance = Double.NEGATIVE_INFINITY;

            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) {
                    maxDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue();
                }
            }

            double minDistance = Double.POSITIVE_INFINITY;

            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) {
                    minDistance = entry.getValue();
                    maxId = entry.getKey(); // holding ID with minimum similarity or maximum dissimilarity
                }
            }            
            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;   

            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(semanticDistanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            createCsvForParaphraseMutant(paraphraseMutantMap);
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();
        }
        
        public static void createCsvForParaphraseMutant(Map<String, String> similarityScoreMap) {
        	// Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            
            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(ID_of_Task);
            String outputFilePath = folderPath.concat("\\").concat("ParaphraseMutant.csv");
            
            // Ensure the folder path exists
            Path path = Paths.get(folderPath);
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // Prepare the CSV file writer
            try (FileWriter csvWriter = new FileWriter(outputFilePath)) {
                // Write CSV header
                csvWriter.append("ID_of_Task,ID_of_Paraphrase,Paraphrase,Neighbourhood,NumberOfWords\n");

                // Iterate through the keys of the similarityScoreMap (paraphrase IDs)
                for (String paraphraseId : similarityScoreMap.keySet()) {
                    // Fetch values from the hash maps
                    String paraphrase = similarityScoreMap.getOrDefault(paraphraseId, "");
                    int neighbourhood = neighbourhoodMap.getOrDefault(paraphraseId, -1);
                    int numberOfWords = numberOfWordsMap.getOrDefault(paraphraseId, -1);
                    String paraTask = paraTaskExtractor(paraphrase);

                    // Write the row to the CSV
                    csvWriter.append(ID_of_Task).append(",") // ID_of_Task
                             .append(paraphraseId).append(",") // ID_of_Paraphrase
                             .append(paraTask.replace("\\n", "")).append(",") // SimilarityScore
                             //.append(paraphrase.replace(",", " ").replace("\n", " ")).append(",")
                             .append(String.valueOf(neighbourhood)).append(",") // Neighbourhood
                             .append(String.valueOf(numberOfWords)).append("\n"); // NumberOfWords
                }

                System.out.println("CSV file created successfully at: " + outputFilePath);

            } catch (IOException e) {
                e.printStackTrace();
            }      
        }
        
        public static void createCsvFromHashMaps(Map<String, Double> similarityScoreMap) {
        	// Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            
            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(ID_of_Task);
            String outputFilePath = folderPath.concat("\\").concat("ParaphraseDistance.csv");
            
            // Ensure the folder path exists
            Path path = Paths.get(folderPath);
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // Prepare the CSV file writer
            try (FileWriter csvWriter = new FileWriter(outputFilePath)) {
                // Write CSV header
                csvWriter.append("ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords\n");

                // Iterate through the keys of the similarityScoreMap (paraphrase IDs)
                for (String paraphraseId : similarityScoreMap.keySet()) {
                    // Fetch values from the hash maps
                    double similarityScore = similarityScoreMap.getOrDefault(paraphraseId, 0.0);
                    int neighbourhood = neighbourhoodMap.getOrDefault(paraphraseId, -1);
                    int numberOfWords = numberOfWordsMap.getOrDefault(paraphraseId, -1);

                    // Write the row to the CSV
                    csvWriter.append(ID_of_Task).append(",") // ID_of_Task
                             .append(paraphraseId).append(",") // ID_of_Paraphrase
                             .append(String.valueOf(similarityScore)).append(",") // SimilarityScore
                             .append(String.valueOf(neighbourhood)).append(",") // Neighbourhood
                             .append(String.valueOf(numberOfWords)).append("\n"); // NumberOfWords
                }

                System.out.println("CSV file created successfully at: " + outputFilePath);

            } catch (IOException e) {
                e.printStackTrace();
            }      
        }
        
        
        //@Analyser
        public static void ParaphraseEuclideanCalculatorToHashMapUsingParallelization() {
        	long startTime = System.currentTimeMillis();
        	
        	// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            
        	
        	distanceMap.clear();// Clear the content of previous execution
        	euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    double distance = euclideanExtractor(dis);
                    	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
         
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }

         // End time measurement
            long endTime = System.currentTimeMillis();

            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
         // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();
        }
        
                
        //@Analyser
        public static void ParaphraseSimilarityCalculatorToHashMapUsingParallelizationTwo() {
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;

                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double maxDistance = Double.NEGATIVE_INFINITY;

            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) {
                    maxDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue();
                }
            }
            
            double minDistance = Double.POSITIVE_INFINITY;
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) {
                    minDistance = entry.getValue();
                    maxId = entry.getKey();// holding ID with minimum similarity or maximum dissimilarity
                }
            }

            // removalOfDuplicateParaphraseEntries();
            // savingIDofUniqueParaphrases();
        }
        
        private static double SemanticSimilarityUsingRoberta(String text1, String text2) throws IOException {
            double similarityScore = 0;
            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe"; // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\semanticsimilarityfinderthree.py"; // Update with the actual path to your Python script

            try {
                // Construct the command
                List<String> command = new ArrayList<>();
                command.add(pythonInterpreterPath);
                command.add(pythonScriptPath); // Replace with the actual path to your Python script
                command.add(text1);
                command.add(text2);

                // Run the command
                ProcessBuilder pb = new ProcessBuilder(command);
                Process process = pb.start();

                // Read the output
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println("Python script output: " + line);
                    // Regular expression pattern to match the score
                    String pattern = "Semantic Similarity Score:\\s*([0-9.]+)";
                    Pattern regex = Pattern.compile(pattern);
                    Matcher matcher = regex.matcher(line);

                    // Check if the pattern is found and extract the score
                    if (matcher.find()) {
                        String scoreStr = matcher.group(1);
                        similarityScore = Double.parseDouble(scoreStr);
                        System.out.println("Extracted Semantic Similarity Score: " + similarityScore);
                    } else {
                        System.out.println("No similarity score found in the string.");
                    }
                }

                // Wait for the process to finish
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Python script exited with error code: " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            return similarityScore;
        }

        
        private static double SemanticSimilarityUsingRobertaTwo(String text1, String text2) throws IOException {
        	double similarityScore = 0;
        	 // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe"; // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\semanticsimilarityfinderthree.py"; // Update with the actual path to your Python script

            try {
                // Construct the command
                List<String> command = new ArrayList<>();
                command.add(pythonInterpreterPath);
                command.add(pythonScriptPath); // Replace with the actual path to your Python script
                command.add(text1);
                command.add(text2);

                // Run the command
                ProcessBuilder pb = new ProcessBuilder(command);
                Process process = pb.start();

                // Read the output
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                 // Regular expression pattern to match the score
                    String pattern = "Semantic Similarity Score:\\s*([0-9.]+)";
                    Pattern regex = Pattern.compile(pattern);
                    Matcher matcher = regex.matcher(line);

                    // Check if the pattern is found and extract the score
                    if (matcher.find()) {
                        String scoreStr = matcher.group(1);
                        similarityScore = Double.parseDouble(scoreStr);
                        System.out.println("Extracted Semantic Similarity Score: " + similarityScore);
                    } else {
                        System.out.println("No similarity score found in the string.");
                    }
                }            

                // Wait for the process to finish
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Python script exited with error code: " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }      
         return similarityScore;
        }
        
        //@Analyser
        public static void ParaphraseDistanceCalculatorToHashMapUsingParallelizationTwo() {
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<String>> futures = new ArrayList<>();            

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        String distance = computeDistancesBetweenParaphrases(Task, paraphrase);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<String> future = futures.get(i);
                try {
                    String distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = euclideanExtractor(distance);

                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
            	maxIdinfo = maxIdinfo + "ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue() + "\n";
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }
            
            double maxDistance = Double.NEGATIVE_INFINITY;

            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) {
                    maxDistance = entry.getValue();
                    maxId = entry.getKey();
                }
            }

            // removalOfDuplicateParaphraseEntries();
            // savingIDofUniqueParaphrases();
        }
        
        //@Analyser
        public static void ParaphraseSimilarityCalculatorUsingParallelization() {
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(ID_of_Task);
            String outputFilePath = folderPath.concat("\\").concat("ParaphraseDistance.csv");
            sourcePathOfParaphraseDistance = folderPath.concat("\\");
            paraphraseDistanceCalculation = outputFilePath;

            // Ensure the folder path exists
            Path path = Paths.get(folderPath);
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // Prepare the CSV file writer
            try (FileWriter csvWriter = new FileWriter(outputFilePath)) {
                // Write CSV header
                csvWriter.append("ID_of_Task,ID_of_Paraphrase,SemanticSimilarity\n");

                // Create thread pool for parallel execution
                ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

                // List to hold Future objects for each computation task
                List<Future<Double>> futures = new ArrayList<>();

                // Loop through the paraphrases and submit tasks to executor service
                for (int i = 1; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> y = testSuite.testSet.get(i);
                    String id_of_paraphrase = y.id;
                    String paraphrase = y.input;

                    // Submit task to executor service
                    futures.add(executorService.submit(() -> {
                        try {
                            // Compute the distances
                            double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                            return distance;
                        } catch (Exception e) {
                            e.printStackTrace();
                            return null;
                        }
                    }));
                }

                // Loop through futures to get results and store in HashMap
                for (int i = 0; i < futures.size(); i++) {
                    Future<Double> future = futures.get(i);
                    try {
                        Double distance = future.get(); // Blocking call to get result
                        if (distance != null) {
                            double euclidean_distance = distance;

                            // Write the results to the CSV file
                            csvWriter.append(ID_of_Task).append(",")
                                    .append(testSuite.testSet.get(i + 1).id).append(",") // id_of_paraphrase
                                    .append(String.valueOf(euclidean_distance)).append("\n");
                        } else {
                            // Handle case where computation failed
                            System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }

                // Shutdown executor service
                executorService.shutdown();
                // removalOfDuplicateParaphraseEntries();
                // savingIDofUniqueParaphrases();

            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        
        //@Analyser
        public static void ParaphraseDistanceCalculatorUsingParallelization() {
        	// Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(ID_of_Task);
            String outputFilePath = folderPath.concat("\\").concat("ParaphraseDistance.csv");
            sourcePathOfParaphraseDistance = folderPath.concat("\\");
            paraphraseDistanceCalculation = outputFilePath;

            // Ensure the folder path exists
            Path path = Paths.get(folderPath);
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // Prepare the CSV file writer
            try (FileWriter csvWriter = new FileWriter(outputFilePath)) {
                // Write CSV header
                csvWriter.append("ID_of_Task,ID_of_Paraphrase,Cosine_Distance,Euclidean_Distance,Task,Paraphrase\n");

                // Create thread pool for parallel execution
                ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

                // List to hold Future objects for each computation task
                List<Future<String>> futures = new ArrayList<>();

                // Loop through the paraphrases and submit tasks to executor service
                for (int i = 1; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> y = testSuite.testSet.get(i);
                    String id_of_paraphrase = y.id;
                    String paraphrase = y.input;

                    // Submit task to executor service
                    futures.add(executorService.submit(() -> {
                        try {
                            // Compute the distances
                            String distance = computeDistancesBetweenParaphrases(Task, paraphrase);
                            return distance;
                        } catch (Exception e) {
                            e.printStackTrace();
                            return null;
                        }
                    }));
                }

                // Loop through futures to get results and write to CSV
                for (int i = 0; i < futures.size(); i++) {
                    Future<String> future = futures.get(i);
                    try {
                        String distance = future.get(); // Blocking call to get result
                        if (distance != null) {
                            double cosine_distance = cosineExtractor(distance);
                            double euclidean_distance = euclideanExtractor(distance);

                            // Write the results to the CSV file
                            csvWriter.append(ID_of_Task).append(",")
                                    .append(testSuite.testSet.get(i + 1).id).append(",") // id_of_paraphrase
                                    .append(String.valueOf(cosine_distance)).append(",")
                                    .append(String.valueOf(euclidean_distance)).append(",")
                                    .append(Task.replace(",", " ").replace("\n", " ")).append(",")
                                    .append(testSuite.testSet.get(i + 1).input.replace(",", " ").replace("\n", " ")).append("\n");
                        } else {
                            // Handle case where computation failed
                            System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }

                // Shutdown executor service
                executorService.shutdown();
                //removalOfDuplicateParaphraseEntries();
                //savingIDofUniqueParaphrases();

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        //@Analyser
        public static void ParaphraseDistanceCalculatorToMapAndCSV() {
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String task = x.input;
            String taskId = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // HashMap to store paraphrase ID and its corresponding Euclidean distance
            HashMap<String, Double> distanceMap = new HashMap<>();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Map.Entry<String, Double>>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String idOfParaphrase = y.id;
                String paraphrase = y.input;

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        String distance = computeDistancesBetweenParaphrases(task, paraphrase);
                        double euclideanDistance = euclideanExtractor(distance);
                        return new AbstractMap.SimpleEntry<>(idOfParaphrase, euclideanDistance);
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in the HashMap
            for (Future<Map.Entry<String, Double>> future : futures) {
                try {
                    Map.Entry<String, Double> entry = future.get(); // Blocking call to get result
                    if (entry != null) {
                        distanceMap.put(entry.getKey(), entry.getValue());
                    } else {
                        System.out.println("Failed to compute distance for a paraphrase");
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Create a set to keep track of unique distances
            Set<Double> uniqueDistances = new HashSet<>();
            HashMap<String, Double> uniqueDistanceMap = new HashMap<>();
            List<String> removedIds = new ArrayList<>(); // List to store removed IDs
            
            // Iterate through the original HashMap
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                String id = entry.getKey();
                Double distance = entry.getValue();
                
                // Check if the distance is already in the set of unique distances
                if (uniqueDistances.contains(distance)) {
                    removedIds.add(id); // List with removed IDs
                } else {
                    uniqueDistances.add(distance);
                    uniqueDistanceMap.put(id, distance); // Final hash map with unique paraphrases
                }
            }

            // Write unique paraphrases to CSV file
            String outputFilePath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\UniqueParaphrases.csv";
            
            try (FileWriter csvWriter = new FileWriter(outputFilePath)) {
                // Write CSV header
                csvWriter.append("ID_of_Paraphrase,Euclidean_Distance\n");

                // Write the unique paraphrases and their distances
                for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {
                    csvWriter.append(entry.getKey()).append(",")
                             .append(String.valueOf(entry.getValue())).append("\n");
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Find the ID with the highest Euclidean distance
            String maxId = null;
            double maxDistance = Double.NEGATIVE_INFINITY;

            for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) {
                    maxDistance = entry.getValue();
                    maxId = entry.getKey();
                }
            }
        }

        
        //@Analyser
        public static void ParaphraseDistanceCalculatorToMap() {
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String task = x.input;
            String taskId = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // HashMap to store paraphrase ID and its corresponding Euclidean distance
            HashMap<String, Double> distanceMap = new HashMap<>();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Map.Entry<String, Double>>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String idOfParaphrase = y.id;
                String paraphrase = y.input;

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        String distance = computeDistancesBetweenParaphrases(task, paraphrase);
                        double euclideanDistance = euclideanExtractor(distance);
                        return new AbstractMap.SimpleEntry<>(idOfParaphrase, euclideanDistance);
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in the HashMap
            for (Future<Map.Entry<String, Double>> future : futures) {
                try {
                    Map.Entry<String, Double> entry = future.get(); // Blocking call to get result
                    if (entry != null) {
                        distanceMap.put(entry.getKey(), entry.getValue());
                    } else {
                        System.out.println("Failed to compute distance for a paraphrase");
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();
            // Create a new HashMap to store unique distances
            //HashMap<String, Double> uniqueDistanceMap = new HashMap<>();
            
            // Create a list to store the IDs of removed entries
            //List<String> removedIds = new ArrayList<>();
            
            // Create a set to keep track of unique distances
            Set<Double> uniqueDistances = new HashSet<>();
            
            // Iterate through the original HashMap
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                String id = entry.getKey();
                Double distance = entry.getValue();
                
                // Check if the distance is already in the set of unique distances
                if (uniqueDistances.contains(distance)) {
                    // If the distance is a duplicate, add the ID to the list of removed IDs
                    removedIds.add(id); // List with removed IDs
                } else {
                    // If the distance is unique, add it to the set and the new HashMap
                    uniqueDistances.add(distance);
                    uniqueDistanceMap.put(id, distance);// Final hash map with unique paraphrases
                }
            }
            // Find the ID with the highest Euclidean distance
            //String maxId = null;
            double maxDistance = Double.NEGATIVE_INFINITY;

            for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) {
                    maxDistance = entry.getValue();
                    maxId = entry.getKey();
                }
            }     
        }

        public static String cleanDescription(String description) {
            // Regular expression to match leading numbers followed by a dot and a space
            String regex = "^[0-9]+\\.\\s*";
            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(description);
            
            // Replace all matches with an empty string
            return matcher.replaceFirst("");
        }
     
        // Removal of duplicate entries directly from the test suite
        //@TestSetFilter
        // List to store test cases to be removed
        public void filterDuplicateTestCases() throws FileNotFoundException, IOException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String problemDescription = "";
            // Load the sentence detection model
            SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
            SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

            // Split the problem into sentences
            String[] sentences = sentenceDetector.sentDetect(Task);

            // Check if there are sentences
            if (sentences.length > 0) {
                // Extract the last sentence
                String sentenceWithProblemIDandLanguage = sentences[sentences.length - 2];
                
                // Extract the main problem description part (excluding the last sentence)
                problemDescription = Task.substring(0, Task.lastIndexOf(sentenceWithProblemIDandLanguage));
            }
            problemDescription = problemDescription.replace("Problem Description :", "").replace("\r\n", "").replace("\n", "");
            problemDescription = problemDescription.substring(problemDescription.indexOf("Write"));
            
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
            Set<String> uniqueDescriptions = new HashSet<>();
            uniqueDescriptions.add(problemDescription);
            // Iterate through the test cases in the test suite
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String Input = y.input;
                String paraphrase = null;
               // Split the problem into sentences
                String[] sentencesTwo = sentenceDetector.sentDetect(Input);

                // Check if there are sentences
                if (sentencesTwo.length > 0) {
                    // Extract the last sentence
                    String sentenceWithProblemIDandLanguage = sentencesTwo[sentencesTwo.length - 2];
                    
                    // Extract the main problem description part (excluding the last sentence)
                    paraphrase = Task.substring(0, Task.lastIndexOf(sentenceWithProblemIDandLanguage));
                }
                paraphrase = paraphrase.replace("Problem Description :", "").replace("\r\n", "").replace("\n", "");
                
                paraphrase = paraphrase.replace("\r\n", "").replace("Problem Description :", "").replace("\n", "");
                //String cleanedDescription = cleanDescription(paraphrase);
                String cleanedDescription = paraphrase.substring(paraphrase.indexOf("Write"));
                
                if (!uniqueDescriptions.contains(cleanedDescription)) {
                    uniqueDescriptions.add(cleanedDescription);                    
                } else {
                	toBeRemovedTCs.add(y);
                }                
            }        
        // Remove all test cases that were added to the list of test cases to be removed
        testSuite.removeAllTestCases(toBeRemovedTCs);
    }  
        
     // Removal of duplicate entries directly from the test suite
        //@TestSetFilter
        // List to store test cases to be removed
        public void filterDuplicateTestCasesFromTestSuite() throws FileNotFoundException, IOException {
        	//TestCase<String, String> x = testSuite.testSet.get(0);
            //String Task = x.input;
            //String ID = x.id;
            //String problemDescription = Task;
            
            //problemDescription = problemDescription.replace("Problem Description :", "").replace("\r\n", "").replace("\n", "");
            //problemDescription = problemDescription.substring(problemDescription.indexOf("Write"), problemDescription.indexOf("\n"));
            
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
            Set<String> uniqueDescriptions = new HashSet<>();
            //uniqueDescriptions.add(problemDescription);
            // Iterate through the test cases in the test suite
            for (int i = 0; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String paraphrase = y.input;                
                String cleanedDescription = paraphrase.substring(paraphrase.indexOf("Write"), paraphrase.indexOf("The programming language is Java."));
                cleanedDescription = cleanedDescription.replace("\r\n", "").replace("\n", "");
                
                if (!uniqueDescriptions.contains(cleanedDescription)) {
                    uniqueDescriptions.add(cleanedDescription);                    
                } else {
                	toBeRemovedTCs.add(y);
                }                
            }        
        // Remove all test cases that were added to the list of test cases to be removed
        testSuite.removeAllTestCases(toBeRemovedTCs);
    }  
        
     // Removal of duplicate entries directly from the test suite
        @TestSetFilter
        // List to store test cases to be removed
        public void filterDuplicateTestCasesFromTestSuiteTwo() throws FileNotFoundException, IOException {
            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
            Set<String> uniqueDescriptions = new HashSet<>();
            
            // Iterate through the test cases in the test suite
            for (int i = 0; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String paraphrase = y.input;
                
                // Check if both "Write" and "The programming language is Java." are present in the paraphrase
                int writeIndex = paraphrase.indexOf("Write");
                int languageIndex = paraphrase.indexOf("The programming language is Java.");
                
                // Proceed only if both indices are valid
                if (writeIndex != -1 && languageIndex != -1 && writeIndex < languageIndex) {
                    String cleanedDescription = paraphrase.substring(writeIndex, languageIndex);
                    cleanedDescription = cleanedDescription.replace("\r\n", "").replace("\n", "");
                    
                    if (!uniqueDescriptions.contains(cleanedDescription)) {
                        uniqueDescriptions.add(cleanedDescription);                    
                    } else {
                        toBeRemovedTCs.add(y);
                    }
                } else {
                    // Handle the case where the required strings are not found or in wrong order
                    // For now, you can choose to log this information or handle it differently
                    System.out.println("Invalid range in test case " + i + ": " + paraphrase);
                }
            }        
            // Remove all test cases that were added to the list of test cases to be removed
            testSuite.removeAllTestCases(toBeRemovedTCs);
        }

          
        //Removing duplicate entries from the paraphrase distance table
        //@Analyser
        public static void removalOfDuplicateParaphraseEntries() {
        	String inputFile = paraphraseDistanceCalculation;
            String outputFile = sourcePathOfParaphraseDistance.concat("output.csv"); 

            try {
                List<String[]> data = readCSV(inputFile);
                List<String[]> cleanedData = removeDuplicates(data);

                writeCSV(outputFile, cleanedData);

                System.out.println("Duplicate entries based on Euclidean distance removed successfully.");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        private static List<String[]> readCSV(String filename) throws IOException {
            List<String[]> data = new ArrayList<>();
            try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
                String line;
                while ((line = br.readLine()) != null) {
                    String[] values = line.split(",");
                    data.add(values);
                }
            }
            return data;
        }

        private static List<String[]> removeDuplicates(List<String[]> data) {
            Set<String> uniqueDistances = new HashSet<>();
            List<String[]> cleanedData = new ArrayList<>();

            for (String[] entry : data) {
                String euclideanDistance = entry[3]; // Assuming Euclidean distance is at index 3
                if (!uniqueDistances.contains(euclideanDistance)) {
                    uniqueDistances.add(euclideanDistance);
                    cleanedData.add(entry);
                }
            }

            return cleanedData;
        }

        private static void writeCSV(String filename, List<String[]> data) throws IOException {
            try (FileWriter writer = new FileWriter(filename)) {
                for (String[] row : data) {
                    writer.write(String.join(",", row));
                    writer.write("\n");
                }
            }
        }
        
        // Storing the ID of unique paraphrases from output.csv
        //@Analyser
        public static void savingIDofUniqueParaphrases() {
        	String csvFile = sourcePathOfParaphraseDistance.concat("output.csv"); 
            String line = "";
            String csvSplitBy = ",";

            //List<String> paraphraseIds = new ArrayList<>();

            try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {
                // Skip the header line
                br.readLine();

                while ((line = br.readLine()) != null) {
                    // Use comma as separator
                    String[] values = line.split(csvSplitBy);

                    //if (values.length > 1) {
                        // "ID_of_Paraphrase" is the second column (index 1)
                    //    paraphraseIds.add(values[1]);
                    //}                    
                    if (values.length > 3) {
                        // Assuming "ID_of_Paraphrase" is the second column (index 1) and "Euclidean_Distance" is the fourth column (index 3)
                        String paraphraseId = values[1];
                        double euclideanDistance = Double.parseDouble(values[3]);

                        paraphraseIds.add(paraphraseId);
                        paraphraseIdToEuclideanDistance.put(paraphraseId, euclideanDistance);
                    }
                }

            } catch (IOException e) {
                e.printStackTrace();
            }

            // Print all IDs in the list
            for (String id : paraphraseIds) {
                System.out.println(id);
            }
            
            // Find the ID with the highest Euclidean distance
            //String maxId = null;
            double maxDistance = Double.NEGATIVE_INFINITY;

            for (Map.Entry<String, Double> entry : paraphraseIdToEuclideanDistance.entrySet()) {
                if (entry.getValue() > maxDistance) {
                    maxDistance = entry.getValue();
                    maxId = entry.getKey();
                }
            }            
        }
        
        // Filter duplicate paraphrases from the test suite
        @TestSetFilter
        public static void filterDuplicateParaphrasesFromTestSuite() {
                // List to store test cases to be removed
                List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();

                    // Iterate through the test cases in the test suite starting from index 1 because index 0 holds the original test case
                    for (int i = 1; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> x = testSuite.testSet.get(i);

                        // Check if the current test case ID matches the ID to remove
                        //if (x.id.equals(id)) 
                        //if (!paraphraseIds.contains(x.id)){
                        if (removedIds.contains(x.id)){
                            // If there is a match, add the test case to the list of test cases to be removed
                            toBeRemovedTCs.add(x);
                            // No need to continue searching for this ID, move to the next ID
                            //break;
                        }
                    }                
                // Remove all test cases that were added to the list of test cases to be removed
                testSuite.removeAllTestCases(toBeRemovedTCs);
            } 
        
     // Filter duplicate paraphrases from the test suite using CSV file
        @TestSetFilter
        public static void filterDuplicateParaphrasesFromTestSuiteUsingCSV() {
                // List to store test cases to be removed
                List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();

                    // Iterate through the test cases in the test suite starting from index 1 because index 0 holds the original test case
                    for (int i = 1; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> x = testSuite.testSet.get(i);

                        // Check if the current test case ID matches the ID to remove
                        //if (x.id.equals(id)) 
                        if (!paraphraseIds.contains(x.id)){
                        //if (removedIds.contains(x.id)){
                            // If there is a match, add the test case to the list of test cases to be removed
                            toBeRemovedTCs.add(x);
                            // No need to continue searching for this ID, move to the next ID
                            //break;
                        }
                    }                
                // Remove all test cases that were added to the list of test cases to be removed
                testSuite.removeAllTestCases(toBeRemovedTCs);
            } 
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustness()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);
            double initial_euclidean = 0.0;
            double final_euclidean = 0.0;
            String PassOrFail = null;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
        	//try {                
                //ChatGPT(x.input);
                //Falcon7B(x.input);
                //openCoPilot(x.input);
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                //}
            	try {
                EvosuiteTestCaseGenerator();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunner();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }
            	try {
                DetectCompilingGivenCode();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseGeneratorOnGivenSolution();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution(); 
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                detectCompilingOfGivenSolutionGeneratedTestCasesOnGeneratedCode();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                EvosuiteTestCaseRunnerOnGeneratedCodeForGivenSolution();
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }        
                
                try {
                detectCompilingOfGeneratedSolutionGeneratedTestCasesOnGivenSolution();
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                EvosuiteTestCaseRunnerOnGivenCodeForGeneratedSolution();
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                    isGeneratedCodeCompilable();
                }
                catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                    EvosuiteTestCaseGenerator();
                } catch (Exception e) {
                        System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
                try {
                    EvosuiteTestCaseRunner();
                } catch (Exception e) {
                        System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                ///////////////////////Paraphrase Execution///////////////////////////
                //List<String> paraphrases = new ArrayList<>();
                //Only executing the paraphrase with highest euclidean distance
                for (int i = 1; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> z = testSuite.testSet.get(i);
                    String id = z.id;
                    if(maxId.equals(id)) {
                    	executedIDs.add(maxId);
                    	final_euclidean = paraphraseIdToEuclideanDistance.get(maxId);
                    	//final_euclidean = uniqueDistanceMap.get(maxId);
                    	try {
                            if(selectedExecutor == "ChatGPT") {
                            	ChatGPT(z.input);
                            }else if(selectedExecutor == "Falcon7B"){
                            	Falcon7B(z.input);
                            }else if(selectedExecutor == "openCoPilot") {
                            	openCoPilot(z.input);
                            }else if(selectedExecutor == "Llama2") {
                            	LLama2(x.input);
                            }else if(selectedExecutor == "GeminiPro") {
                            	GeminiPro(z.input);
                            }else {
                            	System.out.println("Not a valid executer");
                            }
                        	} catch (Exception e) {
                                System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                            }
                    	try {
                    		isGeneratedCodeForParaphrasesCompilable();
                        	}
                            catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            } 
                    	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                    	try {
                    		EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                    	}catch (Exception e) {
                            System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        }         
                    	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                    	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    	folderPath = folderPath.concat(currentProblemID);
                    	//folderPath = folderPath.concat(maxId);
                        String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                            // Write the prettyJSON to the file
                            writer2.write(distance);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        // Checking the Evosuite runner that all test cases pass or fail
                        PassOrFail = PassOrFailFinder(folderPath);          
                        //PassOrFail = "Not Done";
                        String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                            // Write the prettyJSON to the file
                            writer2.write(PassOrFail);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                        // Wait for 60 seconds before running the next test case
                        try {
                        Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                        } catch (InterruptedException e) {
                            System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                        }
                    }//if
                }//for
                // If final paraphrase fails then only it enters to the next part
                if(PassOrFail.equals("Not Done")) {  
                	int maxIterations = 10; 
                    int iteration = 0;
                while(true) {
                // Check for convergence
                if (Math.abs(final_euclidean - initial_euclidean) < 0.1) {
                    System.out.println("Euclidean distances have converged. Exiting the loop.");
                    break;
                }
                if (iteration++ >= maxIterations) {
                    System.out.println("Reached maximum iterations. Exiting the loop.");
                    break;
                }
                // Now find the average of initial and final euclidean distance and find its nearest distance in the test suite to execute that paraphrase
                double avg_euclidean = (initial_euclidean + final_euclidean) / 2;
                // Find the nearest Euclidean distance to avg_euclidean that is not in executedIDs
                String nearestId = null;
                double minDistanceDiff = Double.POSITIVE_INFINITY;

                for (Map.Entry<String, Double> entry : paraphraseIdToEuclideanDistance.entrySet()) {
                //for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {	
                    double distance = entry.getValue();
                    double distanceDiff = Math.abs(distance - avg_euclidean);

                    if (distanceDiff < minDistanceDiff && !executedIDs.contains(entry.getKey()) && distance > initial_euclidean && distance < final_euclidean) {
                        minDistanceDiff = distanceDiff;
                        nearestId = entry.getKey();
                    }else {
                    	break;
                    }
                }  
                if(!executedIDs.contains(nearestId)) {
                for (int i = 1; i < testSuite.testSet.size(); i++) {
                	TestCase<String, String> y = testSuite.testSet.get(i);
                    //paraphrases.add(y.input);
                    String IDofY = y.id;
                    if(IDofY.equals(nearestId)) {
                	try {//ChatGPT(x.input);
                        //Falcon7B(x.input);
                        //openCoPilot(y.input);
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7B(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilot(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2(x.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiPro(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                	try {
                		isGeneratedCodeForParaphrasesCompilable();
                    	}
                        catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	try {
                		EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	}catch (Exception e) {
                        System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    }         
                	String distance = computeDistancesBetweenParaphrases(Task, y.input);
                	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	folderPath = folderPath.concat(currentProblemID);
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Add nearestId to executedIDs as its already executed
                    executedIDs.add(nearestId);
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                    // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                    PassOrFail = PassOrFailFinder(folderPath);
                    if(PassOrFail.equals("Done")) {
                    	initial_euclidean = paraphraseIdToEuclideanDistance.get(IDofY);
                    }else {
                    	final_euclidean = paraphraseIdToEuclideanDistance.get(IDofY);
                    }
                    }//if(IDofY.equals(nearestId))
                }//for
                }//if(!executedIDs.contains(nearestId))
                }//while 
                }//if
        }
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessTwo()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
            
        	try {
                EvosuiteTestCaseGenerator();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunner();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                        ///////////////////////Paraphrase Execution///////////////////////////
                        int endTestCaseNumber = testSuite.testSet.size() - 1;// Test case with highest changes
                        final int j = endTestCaseNumber;
                        TestCase<String, String> z = testSuite.testSet.get(endTestCaseNumber);
                        String id = z.id;
                        executedIDs.add(id);
                    	try {
                            if(selectedExecutor == "ChatGPT") {
                            	ChatGPT(z.input);
                            }else if(selectedExecutor == "Falcon7B"){
                            	Falcon7B(z.input);
                            }else if(selectedExecutor == "openCoPilot") {
                            	openCoPilotParaphrase(z.input);
                            }else if(selectedExecutor == "Llama2") {
                            	LLama2(x.input);
                            }else if(selectedExecutor == "GeminiPro") {
                            	GeminiProParaphrase(z.input);
                            }else {
                            	System.out.println("Not a valid executer");
                            }
                        	} catch (Exception e) {
                                System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                            }
                    	
                    	////////////////////////////////////
                        // If no java file exists    
                        folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	      folderPath = folderPath.concat(currentProblemID);
                	      String directoryPath = folderPath;
                        String fileNameOne = "generatedProgram1OfVersion1_0.java";

                        // Construct the file path
                        Path filePath = Paths.get(directoryPath, fileNameOne);
                        // Check if the java file does not exist, no java file created
                        if (!Files.exists(filePath)) {
                           	//PassOrFail = "Not Done";
                         	GeminiProParaphrase(z.input);
                        }  
                        
                    	// Create an executor service with a single thread
                        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                        
                        // Timeout duration in seconds
                        int timeoutDuration = 2 * 60; // 2 minutes

                        // Task 1: isGeneratedCodeForParaphrasesCompilable
                        Future<?> future1 = executor.submit(() -> {
                            try {
                                isGeneratedCodeForParaphrasesCompilable();
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future1.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 1 timed out.");
                            future1.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                        Future<?> future2 = executor.submit(() -> {
                            try {
                                EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(j); 
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future2.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 2 timed out.");
                            future2.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Shut down the executor service
                        executor.shutdown();           	
                    	
                    	//try {
                    	//	isGeneratedCodeForParaphrasesCompilable();
                        //	}
                        //    catch (Exception e) {
                        //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                        //    } 
                    	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                    	//if(!nothingGenerated.equals("nothingGenerated")) {
                    	//try {
                    	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(endTestCaseNumber);
                    	//}catch (Exception e) {
                        //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        //}   
                    	//}
                    	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                    	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    	folderPath = folderPath.concat(currentProblemID);
                    	//folderPath = folderPath.concat(maxId);
                        String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                            // Write the prettyJSON to the file
                            writer2.write(distance);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        // Checking the Evosuite runner that all test cases pass or fail
                    	if(!nothingGenerated.equals("nothingGenerated")) {
                        PassOrFail = PassOrFailFinder(folderPath);    
                    	}else {
                    		PassOrFail = "Not Done";
                    	}
                    	
                    	// If no file exists with after Evosuite Runner
                        //String directoryPath = folderPath;
                        String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                        
                        // Define the pattern
                        final Pattern pattern = Pattern.compile(patternString);

                        try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                            boolean fileExists = files
                                .map(Path::getFileName)  // Extract file names
                                .map(Path::toString)    // Convert to String
                                .anyMatch(fileName -> pattern.matcher(fileName).matches());

                            if (!fileExists) {
                                System.out.println("No file exists with the pattern: " + patternString);
                                PassOrFail = "Not Done";
                            }
                        } catch (IOException e) {
                            System.err.println("An error occurred while listing files: " + e.getMessage());
                        }     
                    	
                        //PassOrFail = "Not Done";
                        String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                            // Write the prettyJSON to the file
                            writer2.write(PassOrFail);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                        // Wait for 60 seconds before running the next test case
                        try {
                        Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                        } catch (InterruptedException e) {
                            System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                        }
                                            
                // If final paraphrase fails then only it enters to the next part
                int passedTestCaseNumber = 0;
                int failedTestCaseNumber = endTestCaseNumber;
                if(PassOrFail.equals("Not Done")) {  
                	int maxIterations = 15; 
                    int iteration = 0;
                while(true) {
                // Check for convergence
                if (iteration++ >= maxIterations) {
                    System.out.println("Reached maximum iterations. Exiting the loop.");
                    break;
                }
                if ((failedTestCaseNumber - passedTestCaseNumber) <= 1) {
                     break;
                }
                                
                    //find the middle test case between passed and not passed
                    int mid = (int) Math.round((passedTestCaseNumber + failedTestCaseNumber) / 2.0);
                    final int k = mid;
                	TestCase<String, String> y = testSuite.testSet.get(mid);
                    String IDofY = y.id;
                    try {
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7B(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilotParaphrase(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2(x.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiProParaphrase(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                        ////////////////////////////////////
                        // If no java file exists    
                        folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        folderPath = folderPath.concat(currentProblemID);
                        directoryPath = folderPath;
                        fileNameOne = "generatedProgram1OfVersion1_0.java";

                        // Construct the file path
                        filePath = Paths.get(directoryPath, fileNameOne);

                        // Check if the java file does not exist, no java file created
                        if (!Files.exists(filePath)) {
   	                        //PassOrFail = "Not Done";
 	                        GeminiProParaphrase(z.input);
                        }  
                    
                     // Create an executor service with a single thread
                        ScheduledExecutorService executorTwo = Executors.newSingleThreadScheduledExecutor();

                        // Timeout duration in seconds
                        int timeoutDurationTwo = 2 * 60; // 2 minutes

                        // Task 1: isGeneratedCodeForParaphrasesCompilable
                        Future<?> future1Two = executorTwo.submit(() -> {
                            try {
                                isGeneratedCodeForParaphrasesCompilable();
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future1Two.get(timeoutDurationTwo, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 1 timed out.");
                            future1Two.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                        Future<?> future2Two = executorTwo.submit(() -> {
                            try {
                                EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future2Two.get(timeoutDurationTwo, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 2 timed out.");
                            future2Two.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Shut down the executor service
                        executorTwo.shutdown();
                                	
                	
                	//try {
                	//	isGeneratedCodeForParaphrasesCompilable();
                    //	}
                    //    catch (Exception e) {
                    //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                    //    } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	//if(!nothingGenerated.equals("nothingGenerated")) {
                	//try {
                	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(mid);
                	//}catch (Exception e) {
                    //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    //}     
                	//}
                	distance = computeDistancesBetweenParaphrases(Task, y.input);
                	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	folderPath = folderPath.concat(currentProblemID);
                    distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Add nearestId to executedIDs as its already executed
                    executedIDs.add(IDofY);
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                    // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                    if(!nothingGenerated.equals("nothingGenerated")) {
                    PassOrFail = PassOrFailFinder(folderPath);
                    }else {
                    	PassOrFail = "Not Done";
                    }
                    
                    // If no file exists with after Evosuite Runner
                    //String directoryPath = folderPath;
                    //patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                    // Define the pattern
                    //final Pattern patternTwo = Pattern.compile(patternString);
                    try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                        boolean fileExists = files
                            .map(Path::getFileName)  // Extract file names
                            .map(Path::toString)    // Convert to String
                            .anyMatch(fileName -> pattern.matcher(fileName).matches());

                        if (!fileExists) {
                            System.out.println("No file exists with the pattern: " + patternString);
                            PassOrFail = "Not Done";
                        }
                    } catch (IOException e) {
                        System.err.println("An error occurred while listing files: " + e.getMessage());
                    }     
                    
                    if(PassOrFail.equals("Done")) {
                    	passedTestCaseNumber = mid;
                    }else {
                    	failedTestCaseNumber = mid;
                    }         
                    PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                        // Write the prettyJSON to the file
                        writer2.write(PassOrFail);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }//while 
                }//if
        }
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessFour()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            double initial_euclidean = highestSimilarityScore;
            //double initial_euclidean = 5.0;
            double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
        	try {
                EvosuiteTestCaseGenerator();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunner();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                    writer2.write(Double.toString(initial_euclidean));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }                 
                                
                if(!nothingGenerated.equals("nothingGenerated")) {
                    PassOrFail = PassOrFailFinderTwo(folderPath);    
                	}else {
                		PassOrFail = "Not Done";
                	}
                String PassOrFailPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                } 
                
                // if the original program executed successfully then only enter in the next section
                if(PassOrFail.equals("Done")) {                	
                                        
                ///////////////////////Paraphrase with lowest semantic similarity value///////////////////////////
                for (int i = 0; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> z = testSuite.testSet.get(i);
                    String id = z.id;
                    if (maxId.equals(id)) {                        
                        currentTestCase = z;            	
                    	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                            // Write the Task to the file
                            writer2.write(maxId);
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        }
                        final int k = i;
                    	
                    	executedIDs.add(maxId);
                    	final_euclidean = distanceMap.get(maxId);                        
                    	try {
                            if(selectedExecutor == "ChatGPT") {
                            	ChatGPT(z.input);
                            }else if(selectedExecutor == "Falcon7B"){
                            	Falcon7B(z.input);
                            }else if(selectedExecutor == "openCoPilot") {
                            	openCoPilotParaphrase(z.input);
                            }else if(selectedExecutor == "Llama2") {
                            	LLama2(x.input);
                            }else if(selectedExecutor == "GeminiPro") {
                            	GeminiProParaphrase(z.input);
                            }else {
                            	System.out.println("Not a valid executer");
                            }
                        	} catch (Exception e) {
                                System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                            }
              ////////////////////////////////////
              // If no java file exists    
              folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
      	      folderPath = folderPath.concat(currentProblemID);
      	      String directoryPath = folderPath;
              String fileNameOne = "generatedProgram1OfVersion1_0.java";

              // Construct the file path
              Path filePath = Paths.get(directoryPath, fileNameOne);

              // Check if the java file does not exist, no java file created
              if (!Files.exists(filePath)) {
                 	//PassOrFail = "Not Done";
               	GeminiProParaphrase(z.input);
              }   
                    	
                    	// Create an executor service with a single thread
                        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                        
                        // Timeout duration in seconds
                        int timeoutDuration = 2 * 60; // 2 minutes

                        // Task 1: isGeneratedCodeForParaphrasesCompilable
                        Future<?> future1 = executor.submit(() -> {
                            try {
                                isGeneratedCodeForParaphrasesCompilable();
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future1.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 1 timed out.");
                            future1.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                        Future<?> future2 = executor.submit(() -> {
                            try {
                                EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future2.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 2 timed out.");
                            future2.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Shut down the executor service
                        executor.shutdown();           	
                    	
                    	//try {
                    	//	isGeneratedCodeForParaphrasesCompilable();
                        //	}
                        //    catch (Exception e) {
                        //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                        //    } 
                    	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                    	//try {
                    	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                    	//}catch (Exception e) {
                        //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        //}         
                    	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                    	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    	folderPath = folderPath.concat(currentProblemID);
                    	//folderPath = folderPath.concat(maxId);
                        String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                            // Write the prettyJSON to the file
                            writer2.write(distance);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        // Checking the Evosuite runner that all test cases pass or fail
                        //PassOrFail = PassOrFailFinder(folderPath);      
                        if(!nothingGenerated.equals("nothingGenerated")) {
                            PassOrFail = PassOrFailFinder(folderPath);    
                        	}else {
                        		PassOrFail = "Not Done";
                        	}
                        //PassOrFail = "Not Done";
                        
                        // If no file exists with after Evosuite Runner
                        //String directoryPath = folderPath;
                        String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                        
                        // Define the pattern
                        Pattern pattern = Pattern.compile(patternString);

                        try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                            boolean fileExists = files
                                .map(Path::getFileName)  // Extract file names
                                .map(Path::toString)    // Convert to String
                                .anyMatch(fileName -> pattern.matcher(fileName).matches());

                            if (!fileExists) {
                                System.out.println("No file exists with the pattern: " + patternString);
                                PassOrFail = "Not Done";
                            }
                        } catch (IOException e) {
                            System.err.println("An error occurred while listing files: " + e.getMessage());
                        }                                                  
                        
                        String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                            // Write the prettyJSON to the file
                            writer2.write(PassOrFail);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                        String lowestSimilarityPath = folderPath.concat("\\").concat("lowestSimilarityScore.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(lowestSimilarityPath))) {
                            // Write the Task to the file
                            writer2.write(Double.toString(final_euclidean));
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        } 
                        
                        // Wait for 60 seconds before running the next test case
                        try {
                        Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                        } catch (InterruptedException e) {
                            System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                        }
                    }// if(maxId.equals(id))
                }//for
                                            
                // If final paraphrase fails then only it enters to the next part
                if(PassOrFail.equals("Not Done")) {  
                	int maxIterations = 8; 
                    int iteration = 0;
                    int count = 3;
                while(true) {
                // Check for convergence
                if (iteration++ >= maxIterations) {
                    System.out.println("Reached maximum iterations. Exiting the loop.");
                    break;
                }
                
               // Check for convergence
               //if (Math.abs(final_euclidean - initial_euclidean) < 0.1) {
               //    System.out.println("Euclidean distances have converged. Exiting the loop.");
               //    break;
               //}
            
               // Now find the average of initial and final euclidean distance and find its nearest distance in the test suite to execute that paraphrase
               double avg_euclidean = (initial_euclidean + final_euclidean) / 2;
               // Find the nearest Euclidean distance to avg_euclidean that is not in executedIDs
               String nearestId = null;
               double minDistanceDiff = Double.POSITIVE_INFINITY;

               for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
               //for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {	
                double distance = entry.getValue();
                double distanceDiff = Math.abs(distance - avg_euclidean);

                if (distanceDiff < minDistanceDiff && !executedIDs.contains(entry.getKey())) {
                    minDistanceDiff = distanceDiff;
                    nearestId = entry.getKey();
                }
               }  
            
               for (int i = 1; i < testSuite.testSet.size(); i++) {
            	TestCase<String, String> y = testSuite.testSet.get(i);
                //paraphrases.add(y.input);
                String IDofY = y.id;
                if(IDofY.equals(nearestId)) {             
                    try {
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7B(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilotParaphrase(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2(x.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiProParaphrase(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                        ////////////////////////////////////
                        // If no java file exists    
                        folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	    folderPath = folderPath.concat(currentProblemID);
                	    String directoryPath = folderPath;
                        String fileNameOne = "generatedProgram1OfVersion1_0.java";

                        // Construct the file path
                        Path filePath = Paths.get(directoryPath, fileNameOne);

                        // Check if the java file does not exist, no java file created
                        if (!Files.exists(filePath)) {
                           	//PassOrFail = "Not Done";
                         	GeminiProParaphrase(y.input);
                        }   
                  
                    final int k = i;
                 // Create an executor service with a single thread
                    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                    
                    // Timeout duration in seconds
                    int timeoutDuration = 2 * 60; // 2 minutes

                    // Task 1: isGeneratedCodeForParaphrasesCompilable
                    Future<?> future1 = executor.submit(() -> {
                        try {
                            isGeneratedCodeForParaphrasesCompilable();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future1.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 1 timed out.");
                        future1.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                    Future<?> future2 = executor.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future2.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 2 timed out.");
                        future2.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Shut down the executor service
                    executor.shutdown();                   
                    
                    
                	//try {
                	//	isGeneratedCodeForParaphrasesCompilable();
                    //	}
                    //    catch (Exception e) {
                    //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                    //    } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	//try {
                	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	//}catch (Exception e) {
                    //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    //}         
                	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Add nearestId to executedIDs as its already executed
                    executedIDs.add(IDofY);
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                    // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                    //PassOrFail = PassOrFailFinder(folderPath);
                    if(!nothingGenerated.equals("nothingGenerated")) {
                        PassOrFail = PassOrFailFinder(folderPath);    
                    	}else {
                    		PassOrFail = "Not Done";
                    	}                    
                    
                    // If no file exists with after Evosuite Runner
                    //String directoryPath = folderPath;
                    String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                    // Define the pattern
                    Pattern pattern = Pattern.compile(patternString);
                    try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                        boolean fileExists = files
                            .map(Path::getFileName)  // Extract file names
                            .map(Path::toString)    // Convert to String
                            .anyMatch(fileName -> pattern.matcher(fileName).matches());

                        if (!fileExists) {
                            System.out.println("No file exists with the pattern: " + patternString);
                            PassOrFail = "Not Done";
                        }
                    } catch (IOException e) {
                        System.err.println("An error occurred while listing files: " + e.getMessage());
                    }                                     
                    
                    if(PassOrFail.equals("Done")) {
                    	initial_euclidean = distanceMap.get(IDofY);
                    }else {
                    	final_euclidean = distanceMap.get(IDofY);
                    }
                    String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                        // Write the prettyJSON to the file
                        writer2.write(PassOrFail);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    
                    String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(distanceMap.get(IDofY)));
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                    
                    String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(count));
                        count++;
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                }//if
                }//for
                }//while 
                }//if
                }//if(PassOrFail.equals("Done")) 
        }
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessThree()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            double initial_euclidean = highestSimilarityScore;
            double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                    writer2.write(Double.toString(initial_euclidean));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                                
                if(PassOrFail.equals("Done")) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	for (int i = 0; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (IdWithHighestSimilarity.equals(id)) {                        
                            currentTestCase = z;            	
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(IdWithHighestSimilarity);
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(IdWithHighestSimilarity);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(initial_euclidean));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                	
                	
                        
                ///////////////////////Paraphrase with highest euclidean Execution that is lowest similarity///////////////////////////
                for (int i = 0; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> z = testSuite.testSet.get(i);
                    String id = z.id;
                    if (maxId.equals(id)) {                        
                        currentTestCase = z;            	
                    	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                            // Write the Task to the file
                            writer2.write(maxId);
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        }
                        final int k = i;
                    	
                    	executedIDs.add(maxId);
                    	final_euclidean = distanceMap.get(maxId);                        
                    	try {
                            if(selectedExecutor == "ChatGPT") {
                            	ChatGPT(z.input);
                            }else if(selectedExecutor == "Falcon7B"){
                            	Falcon7BParaphrase(z.input);
                            }else if(selectedExecutor == "openCoPilot") {
                            	openCoPilotParaphrase(z.input);
                            }else if(selectedExecutor == "Llama2") {
                            	LLama2Paraphrase(z.input);
                            }else if(selectedExecutor == "GeminiPro") {
                            	GeminiProParaphrase(z.input);
                            }else {
                            	System.out.println("Not a valid executer");
                            }
                        	} catch (Exception e) {
                                System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                            }
              ////////////////////////////////////
              // If no java file exists    
              folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
      	      folderPath = folderPath.concat(currentProblemID);
      	      String directoryPath = folderPath;
              String fileNameOne = "generatedProgram1OfVersion1_0.java";

              // Construct the file path
              Path filePath = Paths.get(directoryPath, fileNameOne);

              // Check if the java file does not exist, no java file created
              if (!Files.exists(filePath)) {
                 	//PassOrFail = "Not Done";
               	GeminiProParaphrase(z.input);
              }   
                    	
                    	// Create an executor service with a single thread
                        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                        
                        // Timeout duration in seconds
                        int timeoutDuration = 2 * 60; // 2 minutes

                        // Task 1: isGeneratedCodeForParaphrasesCompilable
                        Future<?> future1 = executor.submit(() -> {
                            try {
                                isGeneratedCodeForParaphrasesCompilable();
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future1.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 1 timed out.");
                            future1.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                        Future<?> future2 = executor.submit(() -> {
                            try {
                                EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future2.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 2 timed out.");
                            future2.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Shut down the executor service
                        executor.shutdown();           	
                    	
                    	//try {
                    	//	isGeneratedCodeForParaphrasesCompilable();
                        //	}
                        //    catch (Exception e) {
                        //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                        //    } 
                    	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                    	//try {
                    	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                    	//}catch (Exception e) {
                        //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        //}         
                    	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                    	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    	folderPath = folderPath.concat(currentProblemID);
                    	//folderPath = folderPath.concat(maxId);
                        String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                            // Write the prettyJSON to the file
                            writer2.write(distance);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        // Checking the Evosuite runner that all test cases pass or fail
                        //PassOrFail = PassOrFailFinder(folderPath);      
                        if(!nothingGenerated.equals("nothingGenerated")) {
                            PassOrFail = PassOrFailFinder(folderPath);    
                        	}else {
                        		PassOrFail = "Not Done";
                        	}
                        //PassOrFail = "Not Done";
                        
                        // If no file exists with after Evosuite Runner
                        //String directoryPath = folderPath;
                        String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                        
                        // Define the pattern
                        Pattern pattern = Pattern.compile(patternString);

                        try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                            boolean fileExists = files
                                .map(Path::getFileName)  // Extract file names
                                .map(Path::toString)    // Convert to String
                                .anyMatch(fileName -> pattern.matcher(fileName).matches());

                            if (!fileExists) {
                                System.out.println("No file exists with the pattern: " + patternString);
                                PassOrFail = "Not Done";
                            }
                        } catch (IOException e) {
                            System.err.println("An error occurred while listing files: " + e.getMessage());
                        }                                                  
                        
                        String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                            // Write the prettyJSON to the file
                            writer2.write(PassOrFail);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                        String lowestSimilarityPath = folderPath.concat("\\").concat("lowestSimilarityScore.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(lowestSimilarityPath))) {
                            // Write the Task to the file
                            writer2.write(Double.toString(final_euclidean));
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        } 
                        
                        // Wait for 60 seconds before running the next test case
                        try {
                        Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                        } catch (InterruptedException e) {
                            System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                        }
                    }// if(maxId.equals(id))
                }//for
                                            
                // If final paraphrase fails then only it enters to the next part
                if(PassOrFail.equals("Not Done")) {  
                	int maxIterations = 8; 
                    int iteration = 0;
                    int count = 3;
                while(true) {
                // Check for convergence
                if (iteration++ >= maxIterations) {
                    System.out.println("Reached maximum iterations. Exiting the loop.");
                    break;
                }
                
               // Check for convergence
               if (Math.abs(final_euclidean - initial_euclidean) < 0.05) {
                   System.out.println("Euclidean distances have converged. Exiting the loop.");
                   break;
               }
            
               // Now find the average of initial and final euclidean distance and find its nearest distance in the test suite to execute that paraphrase
               double avg_euclidean = (initial_euclidean + final_euclidean) / 2;
               // Find the nearest Euclidean distance to avg_euclidean that is not in executedIDs
               String nearestId = null;
               double minDistanceDiff = Double.POSITIVE_INFINITY;

               for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
               //for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {	
                double distance = entry.getValue();
                double distanceDiff = Math.abs(distance - avg_euclidean);

                if (distanceDiff < minDistanceDiff && !executedIDs.contains(entry.getKey())) {
                    minDistanceDiff = distanceDiff;
                    nearestId = entry.getKey();
                }
               }  
               
               double SimilarityOfNearestId = distanceMap.get(nearestId);
               if(final_euclidean < SimilarityOfNearestId && SimilarityOfNearestId < initial_euclidean) {
            
               for (int i = 1; i < testSuite.testSet.size(); i++) {
            	TestCase<String, String> y = testSuite.testSet.get(i);
                //paraphrases.add(y.input);
                String IDofY = y.id;
                if(IDofY.equals(nearestId)) {             
                    try {
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7BParaphrase(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilotParaphrase(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2Paraphrase(y.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiProParaphrase(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                        ////////////////////////////////////
                        // If no java file exists    
                        folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	    folderPath = folderPath.concat(currentProblemID);
                	    String directoryPath = folderPath;
                        String fileNameOne = "generatedProgram1OfVersion1_0.java";

                        // Construct the file path
                        Path filePath = Paths.get(directoryPath, fileNameOne);

                        // Check if the java file does not exist, no java file created
                        if (!Files.exists(filePath)) {
                           	//PassOrFail = "Not Done";
                         	GeminiProParaphrase(y.input);
                        }   
                  
                    final int k = i;
                 // Create an executor service with a single thread
                    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                    
                    // Timeout duration in seconds
                    int timeoutDuration = 2 * 60; // 2 minutes

                    // Task 1: isGeneratedCodeForParaphrasesCompilable
                    Future<?> future1 = executor.submit(() -> {
                        try {
                            isGeneratedCodeForParaphrasesCompilable();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future1.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 1 timed out.");
                        future1.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                    Future<?> future2 = executor.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future2.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 2 timed out.");
                        future2.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Shut down the executor service
                    executor.shutdown();                   
                    
                    
                	//try {
                	//	isGeneratedCodeForParaphrasesCompilable();
                    //	}
                    //    catch (Exception e) {
                    //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                    //    } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	//try {
                	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	//}catch (Exception e) {
                    //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    //}         
                	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Add nearestId to executedIDs as its already executed
                    executedIDs.add(IDofY);
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                    // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                    //PassOrFail = PassOrFailFinder(folderPath);
                    if(!nothingGenerated.equals("nothingGenerated")) {
                        PassOrFail = PassOrFailFinder(folderPath);    
                    	}else {
                    		PassOrFail = "Not Done";
                    	}                    
                    
                    // If no file exists with after Evosuite Runner
                    //String directoryPath = folderPath;
                    String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                    // Define the pattern
                    Pattern pattern = Pattern.compile(patternString);
                    try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                        boolean fileExists = files
                            .map(Path::getFileName)  // Extract file names
                            .map(Path::toString)    // Convert to String
                            .anyMatch(fileName -> pattern.matcher(fileName).matches());

                        if (!fileExists) {
                            System.out.println("No file exists with the pattern: " + patternString);
                            PassOrFail = "Not Done";
                        }
                    } catch (IOException e) {
                        System.err.println("An error occurred while listing files: " + e.getMessage());
                    }                                     
                    
                    if(PassOrFail.equals("Done")) {
                    	initial_euclidean = distanceMap.get(IDofY);
                    	semanticThreshold = initial_euclidean;
                    }else {
                    	final_euclidean = distanceMap.get(IDofY);
                    }
                    String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                        // Write the prettyJSON to the file
                        writer2.write(PassOrFail);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    
                    String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(distanceMap.get(IDofY)));
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                    
                    String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(count));
                        count++;
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                }//if
                }//for
                }//while 
                }//if
                }//if
                }//if
        }
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessThreeUsingRatioMap()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            double initial_euclidean = highestSimilarityScore;
            double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                    writer2.write(Double.toString(initial_euclidean));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                                
                if(PassOrFail.equals("Done")) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	for (int i = 0; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (IdWithHighestSimilarity.equals(id)) {                        
                            currentTestCase = z;            	
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(IdWithHighestSimilarity);
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(IdWithHighestSimilarity);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(initial_euclidean));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String SemanticSimilarityPath = folderPath.concat("\\").concat("SemanticSimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                                // Write the Task to the file
                            	double semantic = 0;
                            	for (Map.Entry<String, Double> entry : semanticDistanceMap.entrySet()) {
                                    if (entry.getKey().equals(currentProblemID)) {
                                        semantic = entry.getValue();
                                    }
                                }
                                writer2.write(Double.toString(semantic));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String EuclideanSimilarityPath = folderPath.concat("\\").concat("EuclideanSimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(EuclideanSimilarityPath))) {
                                // Write the Task to the file
                            	double euclidean = 0;
                            	for (Map.Entry<String, Double> entry : euclideanDistanceMap.entrySet()) {
                                    if (entry.getKey().equals(currentProblemID)) {
                                        euclidean = entry.getValue();
                                    }
                                }
                                writer2.write(Double.toString(euclidean));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                	
                	
                        
                ///////////////////////Paraphrase with highest euclidean Execution that is lowest similarity///////////////////////////
                for (int i = 0; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> z = testSuite.testSet.get(i);
                    String id = z.id;
                    if (maxId.equals(id)) {                        
                        currentTestCase = z;            	
                    	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                            // Write the Task to the file
                            writer2.write(maxId);
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        }
                        final int k = i;
                    	
                    	executedIDs.add(maxId);
                    	final_euclidean = ratioMap.get(maxId);                        
                    	try {
                            if(selectedExecutor == "ChatGPT") {
                            	ChatGPT(z.input);
                            }else if(selectedExecutor == "Falcon7B"){
                            	Falcon7BParaphrase(z.input);
                            }else if(selectedExecutor == "openCoPilot") {
                            	openCoPilotParaphrase(z.input);
                            }else if(selectedExecutor == "Llama2") {
                            	LLama2Paraphrase(z.input);
                            }else if(selectedExecutor == "GeminiPro") {
                            	GeminiProParaphrase(z.input);
                            }else {
                            	System.out.println("Not a valid executer");
                            }
                        	} catch (Exception e) {
                                System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                            }
              ////////////////////////////////////
              // If no java file exists    
              folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
      	      folderPath = folderPath.concat(currentProblemID);
      	      String directoryPath = folderPath;
              String fileNameOne = "generatedProgram1OfVersion1_0.java";

              // Construct the file path
              Path filePath = Paths.get(directoryPath, fileNameOne);

              // Check if the java file does not exist, no java file created
              if (!Files.exists(filePath)) {
                 	//PassOrFail = "Not Done";
               	GeminiProParaphrase(z.input);
              }   
                    	
                    	// Create an executor service with a single thread
                        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                        
                        // Timeout duration in seconds
                        int timeoutDuration = 2 * 60; // 2 minutes

                        // Task 1: isGeneratedCodeForParaphrasesCompilable
                        Future<?> future1 = executor.submit(() -> {
                            try {
                                isGeneratedCodeForParaphrasesCompilable();
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future1.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 1 timed out.");
                            future1.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                        Future<?> future2 = executor.submit(() -> {
                            try {
                                EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future2.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 2 timed out.");
                            future2.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Shut down the executor service
                        executor.shutdown();           	
                    	
                    	//try {
                    	//	isGeneratedCodeForParaphrasesCompilable();
                        //	}
                        //    catch (Exception e) {
                        //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                        //    } 
                    	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                    	//try {
                    	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                    	//}catch (Exception e) {
                        //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        //}         
                    	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                    	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    	folderPath = folderPath.concat(currentProblemID);
                    	//folderPath = folderPath.concat(maxId);
                        String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                            // Write the prettyJSON to the file
                            writer2.write(distance);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        // Checking the Evosuite runner that all test cases pass or fail
                        //PassOrFail = PassOrFailFinder(folderPath);      
                        if(!nothingGenerated.equals("nothingGenerated")) {
                            PassOrFail = PassOrFailFinder(folderPath);    
                        	}else {
                        		PassOrFail = "Not Done";
                        	}
                        //PassOrFail = "Not Done";
                        
                        // If no file exists with after Evosuite Runner
                        //String directoryPath = folderPath;
                        String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                        
                        // Define the pattern
                        Pattern pattern = Pattern.compile(patternString);

                        try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                            boolean fileExists = files
                                .map(Path::getFileName)  // Extract file names
                                .map(Path::toString)    // Convert to String
                                .anyMatch(fileName -> pattern.matcher(fileName).matches());

                            if (!fileExists) {
                                System.out.println("No file exists with the pattern: " + patternString);
                                PassOrFail = "Not Done";
                            }
                        } catch (IOException e) {
                            System.err.println("An error occurred while listing files: " + e.getMessage());
                        }                                                  
                        
                        String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                            // Write the prettyJSON to the file
                            writer2.write(PassOrFail);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                        String lowestSimilarityPath = folderPath.concat("\\").concat("lowestSimilarityScore.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(lowestSimilarityPath))) {
                            // Write the Task to the file
                            writer2.write(Double.toString(final_euclidean));
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        } 
                        
                        String SemanticSimilarityPath = folderPath.concat("\\").concat("SemanticSimilarityScore.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                            // Write the Task to the file
                        	double semantic = 0;
                        	for (Map.Entry<String, Double> entry : semanticDistanceMap.entrySet()) {
                                if (entry.getKey().equals(currentProblemID)) {
                                    semantic = entry.getValue();
                                }
                            }
                            writer2.write(Double.toString(semantic));
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        } 
                        
                        String EuclideanSimilarityPath = folderPath.concat("\\").concat("EuclideanSimilarityScore.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(EuclideanSimilarityPath))) {
                            // Write the Task to the file
                        	double euclidean = 0;
                        	for (Map.Entry<String, Double> entry : euclideanDistanceMap.entrySet()) {
                                if (entry.getKey().equals(currentProblemID)) {
                                    euclidean = entry.getValue();
                                }
                            }
                            writer2.write(Double.toString(euclidean));
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        } 
                        
                        // Wait for 60 seconds before running the next test case
                        try {
                        Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                        } catch (InterruptedException e) {
                            System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                        }
                    }// if(maxId.equals(id))
                }//for
                                            
                // If final paraphrase fails then only it enters to the next part
                if(PassOrFail.equals("Not Done")) {  
                	int maxIterations = 8; 
                    int iteration = 0;
                    int count = 3;
                while(true) {
                // Check for convergence
                if (iteration++ >= maxIterations) {
                    System.out.println("Reached maximum iterations. Exiting the loop.");
                    break;
                }
                
               // Check for convergence
               if (Math.abs(final_euclidean - initial_euclidean) < 0.05) {
                   System.out.println("Euclidean distances have converged. Exiting the loop.");
                   break;
               }
            
               // Now find the average of initial and final euclidean distance and find its nearest distance in the test suite to execute that paraphrase
               double avg_euclidean = (initial_euclidean + final_euclidean) / 2;
               // Find the nearest Euclidean distance to avg_euclidean that is not in executedIDs
               String nearestId = null;
               double minDistanceDiff = Double.POSITIVE_INFINITY;

               for (Map.Entry<String, Double> entry : ratioMap.entrySet()) {
               //for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {	
                double distance = entry.getValue();
                double distanceDiff = Math.abs(distance - avg_euclidean);

                if (distanceDiff < minDistanceDiff && !executedIDs.contains(entry.getKey())) {
                    minDistanceDiff = distanceDiff;
                    nearestId = entry.getKey();
                }
               }  
               
               double SimilarityOfNearestId = ratioMap.get(nearestId);
               if(final_euclidean < SimilarityOfNearestId && SimilarityOfNearestId < initial_euclidean) {
            
               for (int i = 1; i < testSuite.testSet.size(); i++) {
            	TestCase<String, String> y = testSuite.testSet.get(i);
                //paraphrases.add(y.input);
                String IDofY = y.id;
                if(IDofY.equals(nearestId)) {             
                    try {
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7BParaphrase(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilotParaphrase(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2Paraphrase(y.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiProParaphrase(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                        ////////////////////////////////////
                        // If no java file exists    
                        folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	    folderPath = folderPath.concat(currentProblemID);
                	    String directoryPath = folderPath;
                        String fileNameOne = "generatedProgram1OfVersion1_0.java";

                        // Construct the file path
                        Path filePath = Paths.get(directoryPath, fileNameOne);

                        // Check if the java file does not exist, no java file created
                        if (!Files.exists(filePath)) {
                           	//PassOrFail = "Not Done";
                         	GeminiProParaphrase(y.input);
                        }   
                  
                    final int k = i;
                 // Create an executor service with a single thread
                    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                    
                    // Timeout duration in seconds
                    int timeoutDuration = 2 * 60; // 2 minutes

                    // Task 1: isGeneratedCodeForParaphrasesCompilable
                    Future<?> future1 = executor.submit(() -> {
                        try {
                            isGeneratedCodeForParaphrasesCompilable();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future1.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 1 timed out.");
                        future1.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                    Future<?> future2 = executor.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future2.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 2 timed out.");
                        future2.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Shut down the executor service
                    executor.shutdown();                   
                    
                    
                	//try {
                	//	isGeneratedCodeForParaphrasesCompilable();
                    //	}
                    //    catch (Exception e) {
                    //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                    //    } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	//try {
                	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	//}catch (Exception e) {
                    //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    //}         
                	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Add nearestId to executedIDs as its already executed
                    executedIDs.add(IDofY);
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                    // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                    //PassOrFail = PassOrFailFinder(folderPath);
                    if(!nothingGenerated.equals("nothingGenerated")) {
                        PassOrFail = PassOrFailFinder(folderPath);    
                    	}else {
                    		PassOrFail = "Not Done";
                    	}                    
                    
                    // If no file exists with after Evosuite Runner
                    //String directoryPath = folderPath;
                    String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                    // Define the pattern
                    Pattern pattern = Pattern.compile(patternString);
                    try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                        boolean fileExists = files
                            .map(Path::getFileName)  // Extract file names
                            .map(Path::toString)    // Convert to String
                            .anyMatch(fileName -> pattern.matcher(fileName).matches());

                        if (!fileExists) {
                            System.out.println("No file exists with the pattern: " + patternString);
                            PassOrFail = "Not Done";
                        }
                    } catch (IOException e) {
                        System.err.println("An error occurred while listing files: " + e.getMessage());
                    }                                     
                    
                    if(PassOrFail.equals("Done")) {
                    	initial_euclidean = ratioMap.get(IDofY);
                    	semanticThreshold = initial_euclidean;
                    }else {
                    	final_euclidean = ratioMap.get(IDofY);
                    }
                    String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                        // Write the prettyJSON to the file
                        writer2.write(PassOrFail);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    
                    String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(ratioMap.get(IDofY)));
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                    
                    String SemanticSimilarityPathTwo = folderPath.concat("\\").concat("SemanticSimilarityScore.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPathTwo))) {
                        // Write the Task to the file
                    	double semantic = 0;
                    	for (Map.Entry<String, Double> entry : semanticDistanceMap.entrySet()) {
                            if (entry.getKey().equals(currentProblemID)) {
                                semantic = entry.getValue();
                            }
                        }
                        writer2.write(Double.toString(semantic));
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                    
                    String EuclideanSimilarityPath = folderPath.concat("\\").concat("EuclideanSimilarityScore.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(EuclideanSimilarityPath))) {
                        // Write the Task to the file
                    	double euclidean = 0;
                    	for (Map.Entry<String, Double> entry : euclideanDistanceMap.entrySet()) {
                            if (entry.getKey().equals(currentProblemID)) {
                                euclidean = entry.getValue();
                            }
                        }
                        writer2.write(Double.toString(euclidean));
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                    
                    String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(count));
                        count++;
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                }//if
                }//for
                }//while 
                }//if
                }//if
                }//if
        }
        
        //@Analyser
        public void CheckingIDsAboveSemanticThreshold() throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            
            int count = 0;
            
            List<String> executedIDs = new ArrayList<>();
            String PassOrFail = null;
            
        	String selectedExecutor = null;
        	// Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
            }
            
        	for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
        		if (entry.getValue() > semanticThreshold) {//
        			for (int i = 1; i < testSuite.testSet.size(); i++) {
                    	TestCase<String, String> y = testSuite.testSet.get(i);
                        //paraphrases.add(y.input);
                        String IDofY = y.id;
                        if(IDofY.equals(entry.getKey())) {             
                            try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(y.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(y.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(y.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(y.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(y.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                                ////////////////////////////////////
                                // If no java file exists    
                                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	    folderPath = folderPath.concat(currentProblemID);
                        	    String directoryPath = folderPath;
                                String fileNameOne = "generatedProgram1OfVersion1_0.java";

                                // Construct the file path
                                Path filePath = Paths.get(directoryPath, fileNameOne);

                                // Check if the java file does not exist, no java file created
                                if (!Files.exists(filePath)) {
                                   	//PassOrFail = "Not Done";
                                 	GeminiProParaphrase(y.input);
                                }   
                          
                            final int k = i;
                         // Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();                   
                            
                            
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Add nearestId to executedIDs as its already executed
                            executedIDs.add(IDofY);
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                            // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                            //PassOrFail = PassOrFailFinder(folderPath);
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}                    
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);
                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                     
                            
                            //if(PassOrFail.equals("Done")) {
                            //	initial_euclidean = distanceMap.get(IDofY);
                            //	//semanticThreshold = initial_euclidean;
                            //}else {
                            //	final_euclidean = distanceMap.get(IDofY);
                            //}
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(distanceMap.get(IDofY)));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(count));
                                count++;
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                                                
                        
        		}//if
        	}//if
        }//for
        	}
        }
        
        //@Analyser
        public void CheckingIDsAboveSemanticEuclideanRatioThreshold() throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            
            int count = 0;
            
            List<String> executedIDs = new ArrayList<>();
            String PassOrFail = null;
            
        	String selectedExecutor = null;
        	// Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
            }
            
        	for (Map.Entry<String, Double> entry : ratioMap.entrySet()) {
        		if (entry.getValue() > semanticThreshold) {//
        			for (int i = 1; i < testSuite.testSet.size(); i++) {
                    	TestCase<String, String> y = testSuite.testSet.get(i);
                        //paraphrases.add(y.input);
                        String IDofY = y.id;
                        if(IDofY.equals(entry.getKey())) {             
                            try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(y.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(y.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(y.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(y.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(y.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                                ////////////////////////////////////
                                // If no java file exists    
                                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	    folderPath = folderPath.concat(currentProblemID);
                        	    String directoryPath = folderPath;
                                String fileNameOne = "generatedProgram1OfVersion1_0.java";

                                // Construct the file path
                                Path filePath = Paths.get(directoryPath, fileNameOne);

                                // Check if the java file does not exist, no java file created
                                if (!Files.exists(filePath)) {
                                   	//PassOrFail = "Not Done";
                                 	GeminiProParaphrase(y.input);
                                }   
                          
                            final int k = i;
                         // Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();                   
                            
                            
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Add nearestId to executedIDs as its already executed
                            executedIDs.add(IDofY);
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                            // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                            //PassOrFail = PassOrFailFinder(folderPath);
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}                    
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);
                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                     
                            
                            //if(PassOrFail.equals("Done")) {
                            //	initial_euclidean = distanceMap.get(IDofY);
                            //	//semanticThreshold = initial_euclidean;
                            //}else {
                            //	final_euclidean = distanceMap.get(IDofY);
                            //}
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(ratioMap.get(IDofY)));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(count));
                                count++;
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                                                
                        
        		}//if
        	}//if
        }//for
        	}
        }
        
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessThreeEuclidean()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            double initial_euclidean = highestSimilarityScore;
            double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                    writer2.write(Double.toString(initial_euclidean));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                                
                //if(PassOrFail.equals("Done")) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	for (int i = 0; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (IdWithHighestSimilarity.equals(id)) {                        
                            currentTestCase = z;            	
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(IdWithHighestSimilarity);
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(IdWithHighestSimilarity);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(initial_euclidean));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                	
                	
                        
                ///////////////////////Paraphrase with highest euclidean Execution that is lowest similarity///////////////////////////
                for (int i = 0; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> z = testSuite.testSet.get(i);
                    String id = z.id;
                    if (maxId.equals(id)) {                        
                        currentTestCase = z;            	
                    	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                            // Write the Task to the file
                            writer2.write(maxId);
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        }
                        final int k = i;
                    	
                    	executedIDs.add(maxId);
                    	final_euclidean = distanceMap.get(maxId);                        
                    	try {
                            if(selectedExecutor == "ChatGPT") {
                            	ChatGPT(z.input);
                            }else if(selectedExecutor == "Falcon7B"){
                            	Falcon7BParaphrase(z.input);
                            }else if(selectedExecutor == "openCoPilot") {
                            	openCoPilotParaphrase(z.input);
                            }else if(selectedExecutor == "Llama2") {
                            	LLama2Paraphrase(z.input);
                            }else if(selectedExecutor == "GeminiPro") {
                            	GeminiProParaphrase(z.input);
                            }else {
                            	System.out.println("Not a valid executer");
                            }
                        	} catch (Exception e) {
                                System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                            }
              ////////////////////////////////////
              // If no java file exists    
              folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
      	      folderPath = folderPath.concat(currentProblemID);
      	      String directoryPath = folderPath;
              String fileNameOne = "generatedProgram1OfVersion1_0.java";

              // Construct the file path
              Path filePath = Paths.get(directoryPath, fileNameOne);

              // Check if the java file does not exist, no java file created
              if (!Files.exists(filePath)) {
                 	//PassOrFail = "Not Done";
               	GeminiProParaphrase(z.input);
              }   
                    	
                    	// Create an executor service with a single thread
                        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                        
                        // Timeout duration in seconds
                        int timeoutDuration = 2 * 60; // 2 minutes

                        // Task 1: isGeneratedCodeForParaphrasesCompilable
                        Future<?> future1 = executor.submit(() -> {
                            try {
                                isGeneratedCodeForParaphrasesCompilable();
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future1.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 1 timed out.");
                            future1.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                        Future<?> future2 = executor.submit(() -> {
                            try {
                                EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future2.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 2 timed out.");
                            future2.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Shut down the executor service
                        executor.shutdown();           	
                    	
                    	//try {
                    	//	isGeneratedCodeForParaphrasesCompilable();
                        //	}
                        //    catch (Exception e) {
                        //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                        //    } 
                    	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                    	//try {
                    	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                    	//}catch (Exception e) {
                        //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        //}         
                    	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                    	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    	folderPath = folderPath.concat(currentProblemID);
                    	//folderPath = folderPath.concat(maxId);
                        String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                            // Write the prettyJSON to the file
                            writer2.write(distance);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        // Checking the Evosuite runner that all test cases pass or fail
                        //PassOrFail = PassOrFailFinder(folderPath);      
                        if(!nothingGenerated.equals("nothingGenerated")) {
                            PassOrFail = PassOrFailFinder(folderPath);    
                        	}else {
                        		PassOrFail = "Not Done";
                        	}
                        //PassOrFail = "Not Done";
                        
                        // If no file exists with after Evosuite Runner
                        //String directoryPath = folderPath;
                        String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                        
                        // Define the pattern
                        Pattern pattern = Pattern.compile(patternString);

                        try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                            boolean fileExists = files
                                .map(Path::getFileName)  // Extract file names
                                .map(Path::toString)    // Convert to String
                                .anyMatch(fileName -> pattern.matcher(fileName).matches());

                            if (!fileExists) {
                                System.out.println("No file exists with the pattern: " + patternString);
                                PassOrFail = "Not Done";
                            }
                        } catch (IOException e) {
                            System.err.println("An error occurred while listing files: " + e.getMessage());
                        }                                                  
                        
                        String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                            // Write the prettyJSON to the file
                            writer2.write(PassOrFail);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                        String lowestSimilarityPath = folderPath.concat("\\").concat("lowestSimilarityScore.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(lowestSimilarityPath))) {
                            // Write the Task to the file
                            writer2.write(Double.toString(final_euclidean));
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        } 
                        
                        // Wait for 60 seconds before running the next test case
                        try {
                        Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                        } catch (InterruptedException e) {
                            System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                        }
                    }// if(maxId.equals(id))
                }//for
                
                
                if(PassOrFail.equals("Done")) {
                	euclideanThreshold = final_euclidean;
                }
                                            
                // If final paraphrase fails then only it enters to the next part
                if(PassOrFail.equals("Not Done")) {  
                	int maxIterations = 8; 
                    int iteration = 0;
                    int count = 3;
                while(true) {
                // Check for convergence
                if (iteration++ >= maxIterations) {
                    System.out.println("Reached maximum iterations. Exiting the loop.");
                    break;
                }
                
               // Check for convergence
               if (Math.abs(final_euclidean - initial_euclidean) < 0.005) {
                   System.out.println("Euclidean distances have converged. Exiting the loop.");
                   break;
               }
            
               // Now find the average of initial and final euclidean distance and find its nearest distance in the test suite to execute that paraphrase
               double avg_euclidean = (initial_euclidean + final_euclidean) / 2;
               // Find the nearest Euclidean distance to avg_euclidean that is not in executedIDs
               String nearestId = null;
               double minDistanceDiff = Double.POSITIVE_INFINITY;

               for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
               //for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {	
                double distance = entry.getValue();
                double distanceDiff = Math.abs(distance - avg_euclidean);

                if (distanceDiff < minDistanceDiff && !executedIDs.contains(entry.getKey())) {
                    minDistanceDiff = distanceDiff;
                    nearestId = entry.getKey();
                }
               }  
               
               double SimilarityOfNearestId = distanceMap.get(nearestId);
               if(final_euclidean > SimilarityOfNearestId && SimilarityOfNearestId > initial_euclidean) {
            
               for (int i = 1; i < testSuite.testSet.size(); i++) {
            	TestCase<String, String> y = testSuite.testSet.get(i);
                //paraphrases.add(y.input);
                String IDofY = y.id;
                if(IDofY.equals(nearestId)) {             
                    try {
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7BParaphrase(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilotParaphrase(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2Paraphrase(y.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiProParaphrase(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                        ////////////////////////////////////
                        // If no java file exists    
                        folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	    folderPath = folderPath.concat(currentProblemID);
                	    String directoryPath = folderPath;
                        String fileNameOne = "generatedProgram1OfVersion1_0.java";

                        // Construct the file path
                        Path filePath = Paths.get(directoryPath, fileNameOne);

                        // Check if the java file does not exist, no java file created
                        if (!Files.exists(filePath)) {
                           	//PassOrFail = "Not Done";
                         	GeminiProParaphrase(y.input);
                        }   
                  
                    final int k = i;
                 // Create an executor service with a single thread
                    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                    
                    // Timeout duration in seconds
                    int timeoutDuration = 2 * 60; // 2 minutes

                    // Task 1: isGeneratedCodeForParaphrasesCompilable
                    Future<?> future1 = executor.submit(() -> {
                        try {
                            isGeneratedCodeForParaphrasesCompilable();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future1.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 1 timed out.");
                        future1.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                    Future<?> future2 = executor.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future2.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 2 timed out.");
                        future2.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Shut down the executor service
                    executor.shutdown();                   
                    
                    
                	//try {
                	//	isGeneratedCodeForParaphrasesCompilable();
                    //	}
                    //    catch (Exception e) {
                    //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                    //    } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	//try {
                	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	//}catch (Exception e) {
                    //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    //}         
                	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Add nearestId to executedIDs as its already executed
                    executedIDs.add(IDofY);
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                    // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                    //PassOrFail = PassOrFailFinder(folderPath);
                    if(!nothingGenerated.equals("nothingGenerated")) {
                        PassOrFail = PassOrFailFinder(folderPath);    
                    	}else {
                    		PassOrFail = "Not Done";
                    	}                    
                    
                    // If no file exists with after Evosuite Runner
                    //String directoryPath = folderPath;
                    String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                    // Define the pattern
                    Pattern pattern = Pattern.compile(patternString);
                    try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                        boolean fileExists = files
                            .map(Path::getFileName)  // Extract file names
                            .map(Path::toString)    // Convert to String
                            .anyMatch(fileName -> pattern.matcher(fileName).matches());

                        if (!fileExists) {
                            System.out.println("No file exists with the pattern: " + patternString);
                            PassOrFail = "Not Done";
                        }
                    } catch (IOException e) {
                        System.err.println("An error occurred while listing files: " + e.getMessage());
                    }                                     
                    
                    if(PassOrFail.equals("Done")) {
                    	initial_euclidean = distanceMap.get(IDofY);
                    	euclideanThreshold = initial_euclidean;
                    }else {
                    	final_euclidean = distanceMap.get(IDofY);
                    }
                    String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                        // Write the prettyJSON to the file
                        writer2.write(PassOrFail);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    
                    String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(distanceMap.get(IDofY)));
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                    
                    String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(count));
                        count++;
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                }//if
                }//for
                }//while 
                }//if
                }//if
                //}//if
        }     
        
        
        //@Analyser
        public void CheckingIDsBelowEuclideanThreshold() throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            
            int count = 0;
            
            List<String> executedIDs = new ArrayList<>();
            String PassOrFail = null;
            
        	String selectedExecutor = null;
        	// Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
            }
            
        	for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
        		if (entry.getValue() < euclideanThreshold) {//
        			for (int i = 1; i < testSuite.testSet.size(); i++) {
                    	TestCase<String, String> y = testSuite.testSet.get(i);
                        //paraphrases.add(y.input);
                        String IDofY = y.id;
                        if(IDofY.equals(entry.getKey())) {             
                            try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(y.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(y.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(y.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(y.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(y.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                                ////////////////////////////////////
                                // If no java file exists    
                                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	    folderPath = folderPath.concat(currentProblemID);
                        	    String directoryPath = folderPath;
                                String fileNameOne = "generatedProgram1OfVersion1_0.java";

                                // Construct the file path
                                Path filePath = Paths.get(directoryPath, fileNameOne);

                                // Check if the java file does not exist, no java file created
                                if (!Files.exists(filePath)) {
                                   	//PassOrFail = "Not Done";
                                 	GeminiProParaphrase(y.input);
                                }   
                          
                            final int k = i;
                         // Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();                   
                            
                            
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Add nearestId to executedIDs as its already executed
                            executedIDs.add(IDofY);
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                            // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                            //PassOrFail = PassOrFailFinder(folderPath);
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}                    
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);
                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                     
                            
                            //if(PassOrFail.equals("Done")) {
                            //	initial_euclidean = distanceMap.get(IDofY);
                            //	//semanticThreshold = initial_euclidean;
                            //}else {
                            //	final_euclidean = distanceMap.get(IDofY);
                            //}
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(distanceMap.get(IDofY)));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(count));
                                count++;
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                                                
                        
        		}//if
        	}//if
        }//for
        	}
        }
        
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessThreeNew()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            double initial_euclidean = highestSimilarityScore;
            double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                    writer2.write(Double.toString(initial_euclidean));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                                
                //if(PassOrFail.equals("Done")) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	for (int i = 0; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (IdWithHighestSimilarity.equals(id)) {                        
                            currentTestCase = z;            	
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(IdWithHighestSimilarity);
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(IdWithHighestSimilarity);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(initial_euclidean));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                	
                	
                        
                ///////////////////////Paraphrase with highest euclidean Execution that is lowest similarity///////////////////////////
                for (int i = 0; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> z = testSuite.testSet.get(i);
                    String id = z.id;
                    if (maxId.equals(id)) {                        
                        currentTestCase = z;            	
                    	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                            // Write the Task to the file
                            writer2.write(maxId);
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        }
                        final int k = i;
                    	
                    	executedIDs.add(maxId);
                    	final_euclidean = distanceMap.get(maxId);                        
                    	try {
                            if(selectedExecutor == "ChatGPT") {
                            	ChatGPT(z.input);
                            }else if(selectedExecutor == "Falcon7B"){
                            	Falcon7BParaphrase(z.input);
                            }else if(selectedExecutor == "openCoPilot") {
                            	openCoPilotParaphrase(z.input);
                            }else if(selectedExecutor == "Llama2") {
                            	LLama2Paraphrase(z.input);
                            }else if(selectedExecutor == "GeminiPro") {
                            	GeminiProParaphrase(z.input);
                            }else {
                            	System.out.println("Not a valid executer");
                            }
                        	} catch (Exception e) {
                                System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                            }
              ////////////////////////////////////
              // If no java file exists    
              folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
      	      folderPath = folderPath.concat(currentProblemID);
      	      String directoryPath = folderPath;
              String fileNameOne = "generatedProgram1OfVersion1_0.java";

              // Construct the file path
              Path filePath = Paths.get(directoryPath, fileNameOne);

              // Check if the java file does not exist, no java file created
              if (!Files.exists(filePath)) {
                 	//PassOrFail = "Not Done";
               	GeminiProParaphrase(z.input);
              }   
                    	
                    	// Create an executor service with a single thread
                        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                        
                        // Timeout duration in seconds
                        int timeoutDuration = 2 * 60; // 2 minutes

                        // Task 1: isGeneratedCodeForParaphrasesCompilable
                        Future<?> future1 = executor.submit(() -> {
                            try {
                                isGeneratedCodeForParaphrasesCompilable();
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future1.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 1 timed out.");
                            future1.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                        Future<?> future2 = executor.submit(() -> {
                            try {
                                EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future2.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 2 timed out.");
                            future2.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Shut down the executor service
                        executor.shutdown();           	
                    	
                    	//try {
                    	//	isGeneratedCodeForParaphrasesCompilable();
                        //	}
                        //    catch (Exception e) {
                        //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                        //    } 
                    	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                    	//try {
                    	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                    	//}catch (Exception e) {
                        //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        //}         
                    	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                    	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    	folderPath = folderPath.concat(currentProblemID);
                    	//folderPath = folderPath.concat(maxId);
                        String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                            // Write the prettyJSON to the file
                            writer2.write(distance);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        // Checking the Evosuite runner that all test cases pass or fail
                        //PassOrFail = PassOrFailFinder(folderPath);      
                        if(!nothingGenerated.equals("nothingGenerated")) {
                            PassOrFail = PassOrFailFinder(folderPath);    
                        	}else {
                        		PassOrFail = "Not Done";
                        	}
                        //PassOrFail = "Not Done";
                        
                        // If no file exists with after Evosuite Runner
                        //String directoryPath = folderPath;
                        String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                        
                        // Define the pattern
                        Pattern pattern = Pattern.compile(patternString);

                        try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                            boolean fileExists = files
                                .map(Path::getFileName)  // Extract file names
                                .map(Path::toString)    // Convert to String
                                .anyMatch(fileName -> pattern.matcher(fileName).matches());

                            if (!fileExists) {
                                System.out.println("No file exists with the pattern: " + patternString);
                                PassOrFail = "Not Done";
                            }
                        } catch (IOException e) {
                            System.err.println("An error occurred while listing files: " + e.getMessage());
                        }                                                  
                        
                        String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                            // Write the prettyJSON to the file
                            writer2.write(PassOrFail);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                        String lowestSimilarityPath = folderPath.concat("\\").concat("lowestSimilarityScore.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(lowestSimilarityPath))) {
                            // Write the Task to the file
                            writer2.write(Double.toString(final_euclidean));
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        } 
                        
                        // Wait for 60 seconds before running the next test case
                        try {
                        Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                        } catch (InterruptedException e) {
                            System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                        }
                    }// if(maxId.equals(id))
                }//for
                                            
                // If final paraphrase fails then only it enters to the next part
                if(PassOrFail.equals("Not Done")) {  
                	int maxIterations = 8; 
                    int iteration = 0;
                    int count = 3;
                while(true) {
                // Check for convergence
                if (iteration++ >= maxIterations) {
                    System.out.println("Reached maximum iterations. Exiting the loop.");
                    break;
                }
                
               // Check for convergence
               if (Math.abs(final_euclidean - initial_euclidean) < 0.05) {
                   System.out.println("Euclidean distances have converged. Exiting the loop.");
                   break;
               }
            
               // Now find the average of initial and final euclidean distance and find its nearest distance in the test suite to execute that paraphrase
               double avg_euclidean = (initial_euclidean + final_euclidean) / 2;
               // Find the nearest Euclidean distance to avg_euclidean that is not in executedIDs
               String nearestId = null;
               double minDistanceDiff = Double.POSITIVE_INFINITY;

               for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
               //for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {	
                double distance = entry.getValue();
                double distanceDiff = Math.abs(distance - avg_euclidean);

                if (distanceDiff < minDistanceDiff && !executedIDs.contains(entry.getKey())) {
                    minDistanceDiff = distanceDiff;
                    nearestId = entry.getKey();
                }
               }  
               
               double SimilarityOfNearestId = distanceMap.get(nearestId);
               if(final_euclidean < SimilarityOfNearestId && SimilarityOfNearestId < initial_euclidean) {
            
               for (int i = 1; i < testSuite.testSet.size(); i++) {
            	TestCase<String, String> y = testSuite.testSet.get(i);
                //paraphrases.add(y.input);
                String IDofY = y.id;
                if(IDofY.equals(nearestId)) {             
                    try {
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7BParaphrase(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilotParaphrase(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2Paraphrase(y.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiProParaphrase(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                        ////////////////////////////////////
                        // If no java file exists    
                        folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	    folderPath = folderPath.concat(currentProblemID);
                	    String directoryPath = folderPath;
                        String fileNameOne = "generatedProgram1OfVersion1_0.java";

                        // Construct the file path
                        Path filePath = Paths.get(directoryPath, fileNameOne);

                        // Check if the java file does not exist, no java file created
                        if (!Files.exists(filePath)) {
                           	//PassOrFail = "Not Done";
                         	GeminiProParaphrase(y.input);
                        }   
                  
                    final int k = i;
                 // Create an executor service with a single thread
                    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                    
                    // Timeout duration in seconds
                    int timeoutDuration = 2 * 60; // 2 minutes

                    // Task 1: isGeneratedCodeForParaphrasesCompilable
                    Future<?> future1 = executor.submit(() -> {
                        try {
                            isGeneratedCodeForParaphrasesCompilable();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future1.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 1 timed out.");
                        future1.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                    Future<?> future2 = executor.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future2.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 2 timed out.");
                        future2.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Shut down the executor service
                    executor.shutdown();                   
                    
                    
                	//try {
                	//	isGeneratedCodeForParaphrasesCompilable();
                    //	}
                    //    catch (Exception e) {
                    //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                    //    } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	//try {
                	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	//}catch (Exception e) {
                    //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    //}         
                	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Add nearestId to executedIDs as its already executed
                    executedIDs.add(IDofY);
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                    // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                    //PassOrFail = PassOrFailFinder(folderPath);
                    if(!nothingGenerated.equals("nothingGenerated")) {
                        PassOrFail = PassOrFailFinder(folderPath);    
                    	}else {
                    		PassOrFail = "Not Done";
                    	}                    
                    
                    // If no file exists with after Evosuite Runner
                    //String directoryPath = folderPath;
                    String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                    // Define the pattern
                    Pattern pattern = Pattern.compile(patternString);
                    try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                        boolean fileExists = files
                            .map(Path::getFileName)  // Extract file names
                            .map(Path::toString)    // Convert to String
                            .anyMatch(fileName -> pattern.matcher(fileName).matches());

                        if (!fileExists) {
                            System.out.println("No file exists with the pattern: " + patternString);
                            PassOrFail = "Not Done";
                        }
                    } catch (IOException e) {
                        System.err.println("An error occurred while listing files: " + e.getMessage());
                    }                                     
                    
                    if(PassOrFail.equals("Done")) {
                    	initial_euclidean = distanceMap.get(IDofY);
                    }else {
                    	final_euclidean = distanceMap.get(IDofY);
                    }
                    String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                        // Write the prettyJSON to the file
                        writer2.write(PassOrFail);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    
                    String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(distanceMap.get(IDofY)));
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                    
                    String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(count));
                        count++;
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                //}//if
                }//for
                }//while 
                }//if
                }//if
                }//if
        }
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessFive()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            double initial_euclidean = 0.0;
            double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
        	try {
                EvosuiteTestCaseGenerator();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunner();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");
                
                initial_euclidean = SemanticSimilarityUsingRoberta(Task, Task);
                

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                    writer2.write(Double.toString(initial_euclidean));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                                
                if(PassOrFail.equals("Done")) {               	
                        
                ///////////////////////Paraphrase with highest euclidean Execution that is lowest similarity///////////////////////////
                for (int i = 0; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> z = testSuite.testSet.get(i);
                    String id = z.id;
                    if (maxId.equals(id)) {                        
                        currentTestCase = z;            	
                    	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                            // Write the Task to the file
                            writer2.write(maxId);
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        }
                        final int k = i;
                    	
                    	executedIDs.add(maxId);
                    	final_euclidean = distanceMap.get(maxId);                        
                    	try {
                            if(selectedExecutor == "ChatGPT") {
                            	ChatGPT(z.input);
                            }else if(selectedExecutor == "Falcon7B"){
                            	Falcon7BParaphrase(z.input);
                            }else if(selectedExecutor == "openCoPilot") {
                            	openCoPilotParaphrase(z.input);
                            }else if(selectedExecutor == "Llama2") {
                            	LLama2Paraphrase(x.input);
                            }else if(selectedExecutor == "GeminiPro") {
                            	GeminiProParaphrase(z.input);
                            }else {
                            	System.out.println("Not a valid executer");
                            }
                        	} catch (Exception e) {
                                System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                            }
              ////////////////////////////////////
              // If no java file exists    
              folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
      	      folderPath = folderPath.concat(currentProblemID);
      	      String directoryPath = folderPath;
              String fileNameOne = "generatedProgram1OfVersion1_0.java";

              // Construct the file path
              Path filePath = Paths.get(directoryPath, fileNameOne);

              // Check if the java file does not exist, no java file created
              if (!Files.exists(filePath)) {
                 	//PassOrFail = "Not Done";
               	GeminiProParaphrase(z.input);
              }   
                    	
                    	// Create an executor service with a single thread
                        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                        
                        // Timeout duration in seconds
                        int timeoutDuration = 2 * 60; // 2 minutes

                        // Task 1: isGeneratedCodeForParaphrasesCompilable
                        Future<?> future1 = executor.submit(() -> {
                            try {
                                isGeneratedCodeForParaphrasesCompilable();
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test case: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future1.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 1 timed out.");
                            future1.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                        Future<?> future2 = executor.submit(() -> {
                            try {
                                EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                            } catch (Exception e) {
                                System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            }
                        });

                        // Wait for the task to complete or timeout
                        try {
                            future2.get(timeoutDuration, TimeUnit.SECONDS);
                        } catch (TimeoutException e) {
                            System.out.println("Task 2 timed out.");
                            future2.cancel(true); // Interrupt the task
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }

                        // Shut down the executor service
                        executor.shutdown();           	
                    	
                    	//try {
                    	//	isGeneratedCodeForParaphrasesCompilable();
                        //	}
                        //    catch (Exception e) {
                        //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                        //    } 
                    	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                    	//try {
                    	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                    	//}catch (Exception e) {
                        //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        //}         
                    	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                    	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                    	folderPath = folderPath.concat(currentProblemID);
                    	//folderPath = folderPath.concat(maxId);
                        String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                            // Write the prettyJSON to the file
                            writer2.write(distance);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        // Checking the Evosuite runner that all test cases pass or fail
                        //PassOrFail = PassOrFailFinder(folderPath);      
                        if(!nothingGenerated.equals("nothingGenerated")) {
                            PassOrFail = PassOrFailFinder(folderPath);    
                        	}else {
                        		PassOrFail = "Not Done";
                        	}
                        //PassOrFail = "Not Done";
                        
                        // If no file exists with after Evosuite Runner
                        //String directoryPath = folderPath;
                        String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                        
                        // Define the pattern
                        Pattern pattern = Pattern.compile(patternString);

                        try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                            boolean fileExists = files
                                .map(Path::getFileName)  // Extract file names
                                .map(Path::toString)    // Convert to String
                                .anyMatch(fileName -> pattern.matcher(fileName).matches());

                            if (!fileExists) {
                                System.out.println("No file exists with the pattern: " + patternString);
                                PassOrFail = "Not Done";
                            }
                        } catch (IOException e) {
                            System.err.println("An error occurred while listing files: " + e.getMessage());
                        }                                                  
                        
                        String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                            // Write the prettyJSON to the file
                            writer2.write(PassOrFail);                    
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                        String lowestSimilarityPath = folderPath.concat("\\").concat("lowestSimilarityScore.txt");
                        try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(lowestSimilarityPath))) {
                            // Write the Task to the file
                            writer2.write(Double.toString(final_euclidean));
                        } catch (IOException e) {
                            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                        } 
                        
                        // Wait for 60 seconds before running the next test case
                        try {
                        Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                        } catch (InterruptedException e) {
                            System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                        }
                    }// if(maxId.equals(id))
                }//for
                                            
                // If final paraphrase fails then only it enters to the next part
                if(PassOrFail.equals("Not Done")) {  
                	int maxIterations = 8; 
                    int iteration = 0;
                    int count = 3;
                while(true) {
                // Check for convergence
                if (iteration++ >= maxIterations) {
                    System.out.println("Reached maximum iterations. Exiting the loop.");
                    break;
                }
                
               // Check for convergence
               //if (Math.abs(final_euclidean - initial_euclidean) < 0.05) {
               //    System.out.println("Euclidean distances have converged. Exiting the loop.");
               //    break;
               //}
            
               // Now find the average of initial and final euclidean distance and find its nearest distance in the test suite to execute that paraphrase
               double avg_euclidean = (initial_euclidean + final_euclidean) / 2;
               // Find the nearest Euclidean distance to avg_euclidean that is not in executedIDs
               String nearestId = null;
               double minDistanceDiff = Double.POSITIVE_INFINITY;

               for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
               //for (Map.Entry<String, Double> entry : uniqueDistanceMap.entrySet()) {	
                double distance = entry.getValue();
                double distanceDiff = Math.abs(distance - avg_euclidean);

                if (distanceDiff < minDistanceDiff && !executedIDs.contains(entry.getKey())) {
                    minDistanceDiff = distanceDiff;
                    nearestId = entry.getKey();
                }
               }  
               
               double SimilarityOfNearestId = distanceMap.get(nearestId);
               if(final_euclidean < SimilarityOfNearestId && SimilarityOfNearestId < initial_euclidean) {
            
               for (int i = 1; i < testSuite.testSet.size(); i++) {
            	TestCase<String, String> y = testSuite.testSet.get(i);
                //paraphrases.add(y.input);
                String IDofY = y.id;
                if(IDofY.equals(nearestId)) {             
                    try {
                        if(selectedExecutor == "ChatGPT") {
                        	ChatGPT(y.input);
                        }else if(selectedExecutor == "Falcon7B"){
                        	Falcon7BParaphrase(y.input);
                        }else if(selectedExecutor == "openCoPilot") {
                        	openCoPilotParaphrase(y.input);
                        }else if(selectedExecutor == "Llama2") {
                        	LLama2Paraphrase(x.input);
                        }else if(selectedExecutor == "GeminiPro") {
                        	GeminiProParaphrase(y.input);
                        }else {
                        	System.out.println("Not a valid executer");
                        }
                    	} catch (Exception e) {
                            System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                        }
                        ////////////////////////////////////
                        // If no java file exists    
                        folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                	    folderPath = folderPath.concat(currentProblemID);
                	    String directoryPath = folderPath;
                        String fileNameOne = "generatedProgram1OfVersion1_0.java";

                        // Construct the file path
                        Path filePath = Paths.get(directoryPath, fileNameOne);

                        // Check if the java file does not exist, no java file created
                        if (!Files.exists(filePath)) {
                           	//PassOrFail = "Not Done";
                         	GeminiProParaphrase(y.input);
                        }   
                  
                    final int k = i;
                 // Create an executor service with a single thread
                    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                    
                    // Timeout duration in seconds
                    int timeoutDuration = 2 * 60; // 2 minutes

                    // Task 1: isGeneratedCodeForParaphrasesCompilable
                    Future<?> future1 = executor.submit(() -> {
                        try {
                            isGeneratedCodeForParaphrasesCompilable();
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test case: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future1.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 1 timed out.");
                        future1.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                    Future<?> future2 = executor.submit(() -> {
                        try {
                            EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                        } catch (Exception e) {
                            System.out.println("An exception occurred while running test cases: " + e.getMessage());
                        }
                    });

                    // Wait for the task to complete or timeout
                    try {
                        future2.get(timeoutDuration, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("Task 2 timed out.");
                        future2.cancel(true); // Interrupt the task
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }

                    // Shut down the executor service
                    executor.shutdown();                   
                    
                    
                	//try {
                	//	isGeneratedCodeForParaphrasesCompilable();
                    //	}
                    //    catch (Exception e) {
                    //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                    //    } 
                	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                	//try {
                	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                	//}catch (Exception e) {
                    //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                    //}         
                	String distance = computeDistancesBetweenParaphrases(Task, y.input);                	
                    String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                        // Write the prettyJSON to the file
                        writer2.write(distance);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    // Add nearestId to executedIDs as its already executed
                    executedIDs.add(IDofY);
                    // Wait for 60 seconds before running the next test case
                    try {
                    Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                    }
                    // if passes then update the initial_euclidean with the euclidean distance of y from original otherwise update the final_euclidean with the euclidean distance of y from original 
                    //PassOrFail = PassOrFailFinder(folderPath);
                    if(!nothingGenerated.equals("nothingGenerated")) {
                        PassOrFail = PassOrFailFinder(folderPath);    
                    	}else {
                    		PassOrFail = "Not Done";
                    	}                    
                    
                    // If no file exists with after Evosuite Runner
                    //String directoryPath = folderPath;
                    String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";                    
                    // Define the pattern
                    Pattern pattern = Pattern.compile(patternString);
                    try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                        boolean fileExists = files
                            .map(Path::getFileName)  // Extract file names
                            .map(Path::toString)    // Convert to String
                            .anyMatch(fileName -> pattern.matcher(fileName).matches());

                        if (!fileExists) {
                            System.out.println("No file exists with the pattern: " + patternString);
                            PassOrFail = "Not Done";
                        }
                    } catch (IOException e) {
                        System.err.println("An error occurred while listing files: " + e.getMessage());
                    }                                     
                    
                    if(PassOrFail.equals("Done")) {
                    	initial_euclidean = distanceMap.get(IDofY);
                    }else {
                    	final_euclidean = distanceMap.get(IDofY);
                    }
                    String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                        // Write the prettyJSON to the file
                        writer2.write(PassOrFail);                    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    
                    String SemanticSimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SemanticSimilarityPath))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(distanceMap.get(IDofY)));
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                    
                    String paraphraseNumber = folderPath.concat("\\").concat("paraphraseNumber.txt");
                    try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(paraphraseNumber))) {
                        // Write the Task to the file
                        writer2.write(Double.toString(count));
                        count++;
                    } catch (IOException e) {
                        System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                    } 
                }//if
                }//for
                }//while 
                }//if
                }//if
                }//if
        }
                
        public String PassOrFailFinder(String folderPath) {      	      	
        	
        	String PassOrFail = null;
        	File directory = new File(folderPath);
            // Define the pattern to match file names like EvosuiteTestcaseRunnerOnParaphraseX where X is any number
            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
            Pattern pattern = Pattern.compile(patternString);
            // Get the list of files in the directory
            File[] files = directory.listFiles();
            if (files != null) {
                for (File file : files) {
                    if (file.isFile()) {
                        Matcher matcher = pattern.matcher(file.getName());
                        if (matcher.matches()) {
                            System.out.println("Found matching file: " + file.getName());
                            // Check the second-to-last line of the file
                            try (BufferedReader br = new BufferedReader(new FileReader(file))) {
                                String lastLine = null;
                                String secondLastLine = null;
                                String line;
                                while ((line = br.readLine()) != null) {
                                    secondLastLine = lastLine;
                                    lastLine = line;
                                }
                                System.out.println(secondLastLine);
                                if (secondLastLine != null && secondLastLine.contains("OK")) {
                                    PassOrFail = "Done";
                                } else {
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            } else {
                System.out.println("The specified directory does not exist or is not a directory.");
            }
			return PassOrFail;
        }
        
public String PassOrFailFinderTwo(String folderPath) {      	      	
        	
        	String PassOrFail = null;
        	File directory = new File(folderPath);
            // Define the pattern to match file names like EvosuiteTestcaseRunnerOnParaphraseX where X is any number
            String patternString = "EvosuiteTestcaseRunner\\.txt";
            Pattern pattern = Pattern.compile(patternString);
            // Get the list of files in the directory
            File[] files = directory.listFiles();
            if (files != null) {
                for (File file : files) {
                    if (file.isFile()) {
                        Matcher matcher = pattern.matcher(file.getName());
                        if (matcher.matches()) {
                            System.out.println("Found matching file: " + file.getName());
                            // Check the second-to-last line of the file
                            try (BufferedReader br = new BufferedReader(new FileReader(file))) {
                                String lastLine = null;
                                String secondLastLine = null;
                                String line;
                                while ((line = br.readLine()) != null) {
                                    secondLastLine = lastLine;
                                    lastLine = line;
                                }
                                System.out.println(secondLastLine);
                                if (secondLastLine != null && secondLastLine.contains("OK")) {
                                    PassOrFail = "Done";
                                } else {
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            } else {
                System.out.println("The specified directory does not exist or is not a directory.");
            }
			return PassOrFail;
        }
        
        //@Analyser
        public static void ParaphraseDistanceCalculator() {
        	// Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            
            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(ID_of_Task);
            String outputFilePath = folderPath.concat("\\").concat("ParaphraseDistance.csv");
            
            // Ensure the folder path exists
            Path path = Paths.get(folderPath);
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // Prepare the CSV file writer
            try (FileWriter csvWriter = new FileWriter(outputFilePath)) {
                // Write CSV header
                //csvWriter.append("ID_of_Task,ID_of_Paraphrase,Cosine_Distance,Euclidean_Distance,Task,Paraphrase\n");
            	csvWriter.append("ID_of_Task,ID_of_Paraphrase,Cosine_Distance,Euclidean_Distance,Semantic_Similarity\n");

                // Loop through the paraphrases
                for (int i = 1; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> y = testSuite.testSet.get(i);
                    String id_of_paraphrase = y.id;
                    String paraphrase = y.input;

                    // Compute the distances
                    String distance;
                    double semantic_similarity;
					distance = computeDistancesBetweenParaphrases(Task, paraphrase);
					semantic_similarity = SemanticSimilarityUsingRoberta(Task, paraphrase);
					
                    double cosine_distance = cosineExtractor(distance);
                    double euclidean_distance = euclideanExtractor(distance);

                 // Write the results to the CSV file
                    csvWriter.append(ID_of_Task).append(",")
                             .append(id_of_paraphrase).append(",")
                             .append(String.valueOf(cosine_distance)).append(",")
                             .append(String.valueOf(euclidean_distance)).append(",")
                             //.append(Task.replace(",", " ").replace("\n", " ")).append(",")
                             //.append(paraphrase.replace(",", " ").replace("\n", " ")).append("\n");
                             .append(String.valueOf(semantic_similarity)).append("\n");
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
            
            sortedParaphrasesByEuclidean = fetchParaphrasesInOrder(outputFilePath);
            printHighestAndLowestEuclideanDistances(sortedParaphrasesByEuclidean);
        }
        
     // Function to print the highest and lowest Euclidean distances
        public static void printHighestAndLowestEuclideanDistances(Map<String, Double> paraphraseMap) {
            if (!paraphraseMap.isEmpty()) {
                // First entry for the lowest distance, last entry for the highest
                String lowestParaphraseId = paraphraseMap.entrySet().iterator().next().getKey();
                double lowestDistance = paraphraseMap.entrySet().iterator().next().getValue();

                String highestParaphraseId = null;
                double highestDistance = 0.0;
                for (Map.Entry<String, Double> entry : paraphraseMap.entrySet()) {
                    highestParaphraseId = entry.getKey();
                    highestDistance = entry.getValue();
                }
                
                lowestDistanceByEuclidean = lowestDistance;
                lowestParaphraseIdByEuclidean = lowestParaphraseId;
                highestDistanceByEuclidean = highestDistance;
                highestParaphraseIdByEuclidean = highestParaphraseId;

                System.out.println("\nLowest Euclidean Distance: " + lowestDistance + " (Paraphrase ID: " + lowestParaphraseId + ")");
                System.out.println("Highest Euclidean Distance: " + highestDistance + " (Paraphrase ID: " + highestParaphraseId + ")");
            }
        }
        
     // Function to find paraphrase IDs by a given Euclidean distance
        public static List<String> findParaphrasesByDistance(Map<String, Double> paraphraseMap, double distance) {
            List<String> paraphraseIds = new ArrayList<>();

            for (Map.Entry<String, Double> entry : paraphraseMap.entrySet()) {
                if (entry.getValue() == distance) {
                    paraphraseIds.add(entry.getKey());
                }
            }

            return paraphraseIds;
        }
        
        public static Map<String, Double> fetchParaphrasesInOrder(String csvFilePath) {
            List<String[]> paraphraseData = new ArrayList<>();

            try (BufferedReader br = new BufferedReader(new FileReader(csvFilePath))) {
                String line;
                boolean isFirstLine = true; // To skip the header row

                while ((line = br.readLine()) != null) {
                    // Skip the header line
                    if (isFirstLine) {
                        isFirstLine = false;
                        continue;
                    }

                    // Split CSV line by commas
                    String[] columns = line.split(",");

                    // Extract ID of paraphrase and Euclidean distance
                    String idOfParaphrase = columns[1].trim(); // Assuming 2nd column is ID_of_Paraphrase
                    double euclideanDistance = Double.parseDouble(columns[3].trim()); // Assuming 4th column is Euclidean_Distance

                    // Add to paraphrase data list
                    paraphraseData.add(new String[]{idOfParaphrase, String.valueOf(euclideanDistance)});
                }

            } catch (IOException e) {
                e.printStackTrace();
            }

            // Sort the paraphrase data by Euclidean distance in increasing order
            paraphraseData.sort(Comparator.comparingDouble(arr -> Double.parseDouble(arr[1])));

            // Store in LinkedHashMap to preserve order
            Map<String, Double> sortedParaphraseMap = new LinkedHashMap<>();
            for (String[] data : paraphraseData) {
                sortedParaphraseMap.put(data[0], Double.parseDouble(data[1]));
            }

            return sortedParaphraseMap;
        }
        
        private static double cosineExtractor(String content) throws IOException {
            // Regular expression to find the cosine similarity value
            Pattern pattern = Pattern.compile("Cosine Similarity:\\s*([0-9]*\\.[0-9]+)");
            Matcher matcher = pattern.matcher(content);

            if (matcher.find()) {
                // Extract and return the cosine similarity value
                return Double.parseDouble(matcher.group(1));
            } else {
                throw new IOException("Cosine Similarity value not found in the file");
            }
        }
        
        private static double euclideanExtractor(String content) throws IOException {
            // Regular expression to find the cosine similarity value
            Pattern pattern = Pattern.compile("Euclidean Distance:\\s*([0-9]*\\.[0-9]+)");
            Matcher matcher = pattern.matcher(content);

            if (matcher.find()) {
                // Extract and return the cosine similarity value
                return Double.parseDouble(matcher.group(1));
            } else {
                throw new IOException("Euclidean Distance value not found in the file");
            }
        }
        
        //@TestExecuter
    	public static void GeminiProTestCaseGenerator(String problem) throws FileNotFoundException, IOException, InterruptedException {
    		String problemDescription = "";
    	    String sentenceWithProblemID = "";
    	    String problemID = "";
    	    String output = null;
    	    List<String> statement = new ArrayList<>();
            List<String> programCode = new ArrayList<>();
    	    
    		// Load the sentence detection model
            SentenceModel modelNLP = new SentenceModel(new FileInputStream("C:\\Morphy\\en-sent.bin"));
            SentenceDetectorME sentenceDetector = new SentenceDetectorME(modelNLP);

            // Split the problem into sentences
            String[] sentences = sentenceDetector.sentDetect(problem);

            // Check if there are sentences
            if (sentences.length > 0) {
                // Extract the last sentence
                sentenceWithProblemID = sentences[sentences.length - 1];
                
                // Use regular expression to extract "problemID"
                problemID = extractProblemID(sentenceWithProblemID);
                currentProblemID = problemID;
                //givenSolutionOfCurrentTestCase = solutionsMap.get(currentProblemID);
                givenSolutionOfCurrentTestCase = IDSolution.get(currentProblemID);
                
                // Extract the main problem description part (excluding the last sentence)
                problemDescription = problem.substring(0, problem.lastIndexOf(sentenceWithProblemID));
            }
    	    
            if(givenSolutionOfCurrentTestCase == null) {
            	givenSolutionOfCurrentTestCase = IDSolution.get(seedId);
            }
            String query = problemDescription + "Can you generate test cases including corner cases to test the program of the given problem?";
            
            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python310\\python.exe";

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\code_generation_geminipro_2 (8).py";

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);
            command.add(query);

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Read the output from the Python script
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                StringBuilder response = new StringBuilder();
                while ((line = reader.readLine()) != null) {
                    response.append(line).append("\n");
                }

                // Display the response
                if (response.length() > 0) {
                	output = response.toString();
                	System.out.println(output);
                    //JOptionPane.showMessageDialog(null, response.toString(), "Response", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    System.err.println("Error: No response generated.");
                }

                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            ///////////////////////////////////////
            // Saving the test cases
            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(currentProblemID);
            String questionPath = folderPath.concat("\\").concat("TestCases.txt");

            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                // Write the Task to the file
                writer2.write(output);
            } catch (IOException e) {
                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
            }            
    	}    	
    	        
    	//@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessBasedOnSimilarityTwo()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
        	int totalTestCases = testSuite.testSet.size();
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            //double initial_euclidean = highestSimilarityScore;
            //double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                //String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                //try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                //    writer2.write(Double.toString(initial_euclidean));
                //} catch (IOException e) {
                //    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                //} 
                
                String totalParaphrasesPath = folderPath.concat("\\").concat("NumberOfParaphrases.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(totalParaphrasesPath))) {
                    // Write the Task to the file
                	writer2.write(Integer.toString(totalTestCases));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String TimePath = folderPath.concat("\\").concat("ElapsedTime.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                    // Write the Time to the file
                    writer2.write(Long.toString(elapsedTime)+ " milliseconds");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String MemoryUsagePath = folderPath.concat("\\").concat("MemoryUsage.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(MemoryUsagePath))) {
                    // Write the Time to the file
                    writer2.write(Double.toString(memoryUsedInMB)+ " MB");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                                
                if(PassOrFail.equals("Done")) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	// Sort the map by values in decreasing order and collect the keys
                    List<String> sortedKeys = distanceMap.entrySet()
                        .stream()
                        .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
                        .map(Map.Entry::getKey)
                        .collect(Collectors.toList());
                    
                    String PassOrFailTwo = "Done";
                    // sorted paraphrase IDs
                    for (String idOfSortedKey : sortedKeys) {
                    	
                            // Check for convergence
                    		if(!PassOrFailTwo.equals("Done")) {
                                System.out.println("Reached Paraphrase with min perturbation.");
                                break;
                            }//if
                	for (int i = 1; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (idOfSortedKey.equals(id)) {                        
                            currentTestCase = z;  
                            Double SimilarityScore = distanceMap.get(idOfSortedKey);
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(SimilarityScore.toString());
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(idOfSortedKey);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            PassOrFailTwo = PassOrFail;
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(SimilarityScore));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NeighbourhoodPath = folderPath.concat("\\").concat("Neighbourhood.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NeighbourhoodPath))) {
                                // Write the Task to the file
                                writer2.write(Integer.toString(Neighbourhood));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NumberOfWordsPath = folderPath.concat("\\").concat("NumberOfWords.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NumberOfWordsPath))) {
                                // Write the Task to the file
                                writer2.write(Integer.toString(NumberOfWords));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                    	//}//while
                    }//for
                	
                }//if
        }
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessBasedOnSimilarity()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
        	int totalTestCases = testSuite.testSet.size();
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            //double initial_euclidean = highestSimilarityScore;
            //double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                //String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                //try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                //    writer2.write(Double.toString(initial_euclidean));
                //} catch (IOException e) {
                //    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                //} 
                
                String totalParaphrasesPath = folderPath.concat("\\").concat("NumberOfParaphrases.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(totalParaphrasesPath))) {
                    // Write the Task to the file
                	writer2.write(Integer.toString(totalTestCases));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String TimePath = folderPath.concat("\\").concat("ElapsedTime.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                    // Write the Time to the file
                    writer2.write(Long.toString(elapsedTime)+ " milliseconds");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String MemoryUsagePath = folderPath.concat("\\").concat("MemoryUsage.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(MemoryUsagePath))) {
                    // Write the Time to the file
                    writer2.write(Double.toString(memoryUsedInMB)+ " MB");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                
                          
                //if(PassOrFail.equals("Done")) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	// Sort the map by values in decreasing order and collect the keys
                    List<String> sortedKeys = distanceMap.entrySet()
                        .stream()
                        .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
                        .map(Map.Entry::getKey)
                        .collect(Collectors.toList());
                    
                    String PassOrFailTwo = "Done";
                    // sorted paraphrase IDs
                    for (String idOfSortedKey : sortedKeys) {
                    	int responseTwo = JOptionPane.showConfirmDialog(
                                null,                    // Parent component (null means it's centered on the screen)
                                "Do you want to continue?", // Message to display
                                "Continue?",             // Title of the dialog
                                JOptionPane.YES_NO_OPTION); // Options (Yes/No)

                        // Check the response from the user
                        if (responseTwo == JOptionPane.YES_OPTION) {
                    	
                            // Check for convergence
                    		//if(!PassOrFailTwo.equals("Done")) {
                            //    System.out.println("Reached Paraphrase with min perturbation.");
                            //    break;
                            //}//if
                	for (int i = 1; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (idOfSortedKey.equals(id)) {                        
                            currentTestCase = z;  
                            Double SimilarityScore = distanceMap.get(idOfSortedKey);
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(SimilarityScore.toString());
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(idOfSortedKey);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            //PassOrFailTwo = PassOrFail;
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(SimilarityScore));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NeighbourhoodPath = folderPath.concat("\\").concat("Neighbourhood.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NeighbourhoodPath))) {
                                // Write the Task to the file
                                writer2.write(Integer.toString(Neighbourhood));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NumberOfWordsPath = folderPath.concat("\\").concat("NumberOfWords.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NumberOfWordsPath))) {
                                // Write the Task to the file
                                writer2.write(Integer.toString(NumberOfWords));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                    	//}//while
                        
                    }else {
                        // If No, stop the program
                        JOptionPane.showMessageDialog(null, "Stopping the program...");
                        break; // Exit the loop and stop execution
                    }
                	
                //}//if
                    } 
              }
    	
    	//@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessBasedOnEuclidean()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
        	int totalTestCases = testSuite.testSet.size();
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            //double initial_euclidean = highestSimilarityScore;
            //double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                //String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                //try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                //    writer2.write(Double.toString(initial_euclidean));
                //} catch (IOException e) {
                //    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                //}
                
                String totalParaphrasesPath = folderPath.concat("\\").concat("NumberOfParaphrases.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(totalParaphrasesPath))) {
                    // Write the Task to the file
                	writer2.write(Integer.toString(totalTestCases));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String TimePath = folderPath.concat("\\").concat("ElapsedTime.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                    // Write the Time to the file
                    writer2.write(Long.toString(elapsedTime)+ " milliseconds");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String MemoryUsagePath = folderPath.concat("\\").concat("MemoryUsage.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(MemoryUsagePath))) {
                    // Write the Time to the file
                    writer2.write(Double.toString(memoryUsedInMB)+ " MB");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                                
                //if(PassOrFail.equals("Done")) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	// Sort the map by values in increasing order and collect the keys
                	List<String> sortedKeys = distanceMap.entrySet()
                        .stream()
                        .sorted(Map.Entry.comparingByValue())
                        .map(Map.Entry::getKey)
                        .collect(Collectors.toList());
                    
                    String PassOrFailTwo = "Done";
                    // sorted paraphrase IDs
                    for (String idOfSortedKey : sortedKeys) {
                    	int responseTwo = JOptionPane.showConfirmDialog(
                                null,                    // Parent component (null means it's centered on the screen)
                                "Do you want to continue?", // Message to display
                                "Continue?",             // Title of the dialog
                                JOptionPane.YES_NO_OPTION); // Options (Yes/No)

                        // Check the response from the user
                        if (responseTwo == JOptionPane.YES_OPTION) {
                    	
                            // Check for convergence
                    		//if(!PassOrFailTwo.equals("Done")) {
                            //    System.out.println("Reached Paraphrase with min perturbation.");
                            //    break;
                            //}//if
                	for (int i = 1; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (idOfSortedKey.equals(id)) {                        
                            currentTestCase = z;  
                            Double SimilarityScore = distanceMap.get(idOfSortedKey);
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(SimilarityScore.toString());
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(idOfSortedKey);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            PassOrFailTwo = PassOrFail;
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(SimilarityScore));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NeighbourhoodPath = folderPath.concat("\\").concat("Neighbourhood.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NeighbourhoodPath))) {
                                // Write the Task to the file
                                writer2.write(Integer.toString(Neighbourhood));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NumberOfWordsPath = folderPath.concat("\\").concat("NumberOfWords.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NumberOfWordsPath))) {
                                // Write the Task to the file
                                writer2.write(Integer.toString(NumberOfWords));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                    	//}//while
                        
                    }else {
                        // If No, stop the program
                        JOptionPane.showMessageDialog(null, "Stopping the program...");
                        break; // Exit the loop and stop execution
                    }
                	
                //}//if
                    } 
              }
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessBasedOnEuclideanTwo()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
        	int totalTestCases = testSuite.testSet.size();
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            //double initial_euclidean = highestSimilarityScore;
            //double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                //String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                //try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                //    writer2.write(Double.toString(initial_euclidean));
                //} catch (IOException e) {
                //    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                //}
                
                String totalParaphrasesPath = folderPath.concat("\\").concat("NumberOfParaphrases.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(totalParaphrasesPath))) {
                    // Write the Task to the file
                	writer2.write(Integer.toString(totalTestCases));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String TimePath = folderPath.concat("\\").concat("ElapsedTime.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                    // Write the Time to the file
                    writer2.write(Long.toString(elapsedTime)+ " milliseconds");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String MemoryUsagePath = folderPath.concat("\\").concat("MemoryUsage.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(MemoryUsagePath))) {
                    // Write the Time to the file
                    writer2.write(Double.toString(memoryUsedInMB)+ " MB");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                                
                if(PassOrFail.equals("Done")) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	// Sort the map by values in increasing order and collect the keys
                	List<String> sortedKeys = distanceMap.entrySet()
                        .stream()
                        .sorted(Map.Entry.comparingByValue())
                        .map(Map.Entry::getKey)
                        .collect(Collectors.toList());
                    
                    String PassOrFailTwo = "Done";
                    // sorted paraphrase IDs
                    for (String idOfSortedKey : sortedKeys) {
                    	
                            // Check for convergence
                    		if(!PassOrFailTwo.equals("Done")) {
                                System.out.println("Reached Paraphrase with min perturbation.");
                                break;
                            }//if
                	for (int i = 1; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (idOfSortedKey.equals(id)) {                        
                            currentTestCase = z;  
                            Double SimilarityScore = distanceMap.get(idOfSortedKey);
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(SimilarityScore.toString());
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(idOfSortedKey);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            PassOrFailTwo = PassOrFail;
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(SimilarityScore));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NeighbourhoodPath = folderPath.concat("\\").concat("Neighbourhood.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NeighbourhoodPath))) {
                                // Write the Task to the file
                                writer2.write(Integer.toString(Neighbourhood));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NumberOfWordsPath = folderPath.concat("\\").concat("NumberOfWords.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NumberOfWordsPath))) {
                                // Write the Task to the file
                                writer2.write(Integer.toString(NumberOfWords));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                    	//}//while
                    }//for
                	
                }//if
        }
        
        
        //@Analyser
        public void ParaphraseRunnerOnEvaluatingRobustnessBasedOnEuclideanThree()throws FileNotFoundException, IOException, InterruptedException {
        	TestCase<String, String> x = testSuite.testSet.get(0);
        	int totalTestCases = testSuite.testSet.size();
            String Task = x.input;
            String ID = x.id;
            String selectedExecutor = null;
            List<String> executedIDs = new ArrayList<>();
            executedIDs.add(ID);            
            String PassOrFail = null;
            //double initial_euclidean = highestSimilarityScore;
            //double final_euclidean = 0.0;
            
            // Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x.input);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x.input);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x.input);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x.input);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x.input);
                }else {
                	System.out.println("Not a valid executer");
                }
            }
            List<String> CodeAnalysis = new ArrayList<>();
        	if (!filePathForCodeAnalysis.isEmpty()) {
        		CodeAnalysis.addAll(filePathForCodeAnalysis);
        	} else {
        		CodeAnalysis.addAll(filePathForLastCodeAnalysis);
        	}
       	    for(String filePath : CodeAnalysis) {
       			File javaFile = new File(filePath);
    		
    		if (!javaFile.exists() || !javaFile.getName().endsWith(".java")) {
    			break;
            }
    		}
       	    
       	// Create an executor service with a single thread
            ScheduledExecutorService executorThree = Executors.newSingleThreadScheduledExecutor();
            
            // Timeout duration in seconds
            int timeoutDurationThree = 2 * 60; // 2 minutes

            // Task 1: isGeneratedCodeForParaphrasesCompilable
            Future<?> future1Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseGenerator();;
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future1Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 1 timed out.");
                future1Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
            Future<?> future2Three = executorThree.submit(() -> {
                try {
                	EvosuiteTestCaseRunner();; 
                } catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            });

            // Wait for the task to complete or timeout
            try {
                future2Three.get(timeoutDurationThree, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("Task 2 timed out.");
                future2Three.cancel(true); // Interrupt the task
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }

            // Shut down the executor service
            executorThree.shutdown();         	    
       	    
        	//try {
                //EvosuiteTestCaseGenerator();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                //}
            	//try {
                //EvosuiteTestCaseRunner();
            	//} catch (Exception e) {
                //    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                //}            	
                // Saving the task
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String questionPath = folderPath.concat("\\").concat("task.txt");

                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                    // Write the Task to the file
                    writer2.write(Task);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String maxIdPath = folderPath.concat("\\").concat("maxId.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(maxIdPath))) {
                    // Write the Task to the file
                    writer2.write(maxId);
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                //String highestSimilarityPath = folderPath.concat("\\").concat("highestSimilarityScore.txt");
                //try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(highestSimilarityPath))) {
                    // Write the Task to the file
                //    writer2.write(Double.toString(initial_euclidean));
                //} catch (IOException e) {
                //    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                //}
                
                String totalParaphrasesPath = folderPath.concat("\\").concat("NumberOfParaphrases.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(totalParaphrasesPath))) {
                    // Write the Task to the file
                	writer2.write(Integer.toString(totalTestCases));
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                } 
                
                String TimePath = folderPath.concat("\\").concat("ElapsedTime.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                    // Write the Time to the file
                    writer2.write(Long.toString(elapsedTime)+ " milliseconds");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                String MemoryUsagePath = folderPath.concat("\\").concat("MemoryUsage.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(MemoryUsagePath))) {
                    // Write the Time to the file
                    writer2.write(Double.toString(memoryUsedInMB)+ " MB");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
                
                PassOrFail = PassOrFailFinderTwo(folderPath);
                String PassFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassFailCheckPath))) {
                    // Write the prettyJSON to the file
                    writer2.write(PassOrFail);                    
                } catch (IOException e) {
                    e.printStackTrace();
                }
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
                   
                int counter = 0;
                //if(PassOrFail.equals("Done")) {                
                if(counter <14) {
                	
                	///////////////////////Paraphrase with lowest euclidean that is highest similarity////////////////////
                	// Sort the map by values in increasing order and collect the keys
                	List<String> sortedKeys = distanceMap.entrySet()
                        .stream()
                        .sorted(Map.Entry.comparingByValue())
                        .map(Map.Entry::getKey)
                        .collect(Collectors.toList());
                	
                	//String PassOrFailTwo = "Done"; //for now
                    // sorted paraphrase IDs
                    for (String idOfSortedKey : sortedKeys) {
                    	
                            // Check for convergence
                    		//if(!PassOrFailTwo.equals("Done")) {
                                //System.out.println("Reached Paraphrase with min perturbation.");
                                //break;
                            //}//if
                    	counter++;
                    	    if(counter>14) {
                                System.out.println("Reached Paraphrase with min perturbation.");
                                break;
                            }//if                   
                    
                	for (int i = 1; i < testSuite.testSet.size(); i++) {
                        TestCase<String, String> z = testSuite.testSet.get(i);
                        String id = z.id;
                        if (idOfSortedKey.equals(id)) {                        
                            currentTestCase = z;  
                            Double SimilarityScore = distanceMap.get(idOfSortedKey);
                            Double neighbourhood = (double)neighbourhoodMap.get(idOfSortedKey);
                            Double numberOfWords = (double)numberOfWordsMap.get(idOfSortedKey); 
                        	String enterPath = folderPath.concat("\\").concat("enterPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(enterPath))) {
                                // Write the Task to the file
                                writer2.write(SimilarityScore.toString());
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            }
                            final int k = i;
                        	
                        	executedIDs.add(idOfSortedKey);                        	                    
                        	try {
                                if(selectedExecutor == "ChatGPT") {
                                	ChatGPT(z.input);
                                }else if(selectedExecutor == "Falcon7B"){
                                	Falcon7BParaphrase(z.input);
                                }else if(selectedExecutor == "openCoPilot") {
                                	openCoPilotParaphrase(z.input);
                                }else if(selectedExecutor == "Llama2") {
                                	LLama2Paraphrase(z.input);
                                }else if(selectedExecutor == "GeminiPro") {
                                	GeminiProParaphrase(z.input);
                                }else {
                                	System.out.println("Not a valid executer");
                                }
                            	} catch (Exception e) {
                                    System.out.println("An exception occurred while executing ChatGPT: " + e.getMessage());
                                }
                  ////////////////////////////////////
                  // If no java file exists    
                  folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
          	      folderPath = folderPath.concat(currentProblemID);
          	      String directoryPath = folderPath;
                  String fileNameOne = "generatedProgram1OfVersion1_0.java";

                  // Construct the file path
                  Path filePath = Paths.get(directoryPath, fileNameOne);

                  // Check if the java file does not exist, no java file created
                  if (!Files.exists(filePath)) {
                     	//PassOrFail = "Not Done";
                   	GeminiProParaphrase(z.input);
                  }   
                        	
                        	// Create an executor service with a single thread
                            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                            
                            // Timeout duration in seconds
                            int timeoutDuration = 2 * 60; // 2 minutes

                            // Task 1: isGeneratedCodeForParaphrasesCompilable
                            Future<?> future1 = executor.submit(() -> {
                                try {
                                    isGeneratedCodeForParaphrasesCompilable();
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test case: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future1.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 1 timed out.");
                                future1.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Task 2: EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution
                            Future<?> future2 = executor.submit(() -> {
                                try {
                                    EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(k); 
                                } catch (Exception e) {
                                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                                }
                            });

                            // Wait for the task to complete or timeout
                            try {
                                future2.get(timeoutDuration, TimeUnit.SECONDS);
                            } catch (TimeoutException e) {
                                System.out.println("Task 2 timed out.");
                                future2.cancel(true); // Interrupt the task
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            }

                            // Shut down the executor service
                            executor.shutdown();           	
                        	
                        	//try {
                        	//	isGeneratedCodeForParaphrasesCompilable();
                            //	}
                            //    catch (Exception e) {
                            //        System.out.println("An exception occurred while running test case: " + e.getMessage());
                            //    } 
                        	// Replacing 1st generated solution by 2nd 3rd and so on generated solutions in each iteration and run Evosuite generated test cases for the first generated solution on them
                        	//try {
                        	//	EvosuiteTestCaseRunnerOnParaphrasesForGeneratedSolution(i);
                        	//}catch (Exception e) {
                            //    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                            //}         
                        	String distance = computeDistancesBetweenParaphrases(Task, z.input);
                        	folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                        	folderPath = folderPath.concat(currentProblemID);
                        	//folderPath = folderPath.concat(maxId);
                            String distancePath = folderPath.concat("\\").concat("distanceFromOriginalTask.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(distancePath))) {
                                // Write the prettyJSON to the file
                                writer2.write(distance);                    
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            // Checking the Evosuite runner that all test cases pass or fail
                            //PassOrFail = PassOrFailFinder(folderPath);      
                            if(!nothingGenerated.equals("nothingGenerated")) {
                                PassOrFail = PassOrFailFinder(folderPath);    
                            	}else {
                            		PassOrFail = "Not Done";
                            	}
                            //PassOrFail = "Not Done";
                            
                            // If no file exists with after Evosuite Runner
                            //String directoryPath = folderPath;
                            String patternString = "EvosuiteTestcaseRunnerOnParaphrase\\d+\\.txt";
                            
                            // Define the pattern
                            Pattern pattern = Pattern.compile(patternString);

                            try (Stream<Path> files = Files.list(Paths.get(directoryPath))) {
                                boolean fileExists = files
                                    .map(Path::getFileName)  // Extract file names
                                    .map(Path::toString)    // Convert to String
                                    .anyMatch(fileName -> pattern.matcher(fileName).matches());

                                if (!fileExists) {
                                    System.out.println("No file exists with the pattern: " + patternString);
                                    PassOrFail = "Not Done";
                                }
                            } catch (IOException e) {
                                System.err.println("An error occurred while listing files: " + e.getMessage());
                            }                                                  
                            //PassOrFailTwo = PassOrFail;
                            
                            String PassOrFailCheckPath = folderPath.concat("\\").concat("PassOrFailCheckPath.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(PassOrFailCheckPath))) {
                                // Write the prettyJSON to the file
                                writer2.write(PassOrFail);     
                            	//writer2.write("Done");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            
                            String SimilarityPath = folderPath.concat("\\").concat("SimilarityScore.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(SimilarityPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(SimilarityScore));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NeighbourhoodPath = folderPath.concat("\\").concat("Neighbourhood.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NeighbourhoodPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(neighbourhood));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            String NumberOfWordsPath = folderPath.concat("\\").concat("NumberOfWords.txt");
                            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(NumberOfWordsPath))) {
                                // Write the Task to the file
                                writer2.write(Double.toString(numberOfWords));
                            } catch (IOException e) {
                                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                            } 
                            
                            // Wait for 60 seconds before running the next test case
                            try {
                            Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                            } catch (InterruptedException e) {
                                System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                            }
                        }// if(maxId.equals(id))
                    }//for
                    	//}//while
                    }//for
                	
                }//if
                neighbourhoodMap.clear();
                numberOfWordsMap.clear();
        }
    	
    	
    	//@Analyser
        public static void ParaphraseCosineCalculatorToHashMapUsingParallelization() {
    		long startTime = System.currentTimeMillis();
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
    		
        	distanceMap.clear();// Clear the content of previous execution
        	//euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    double distance = cosineExtractor(dis);
                    	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        //euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
         
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }

            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();
        }
    	
    	//@Analyser
        public static void ParaphraseBLEUCalculatorToHashMapUsingParallelization() {
    		long startTime = System.currentTimeMillis();
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
    		
        	distanceMap.clear();// Clear the content of previous execution
        	//euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	//String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    //double distance = euclideanExtractor(dis);
                    	//double distance = calculateBLEUScoreTwo(Task, Collections.singletonList(paraphrase));
                    	String orgTask = orgTaskExtractor(Task);
                        String paraTask = paraTaskExtractor(paraphrase);
                    	double distance = calculateBLEUScoreTwo(orgTask, paraTask);
                    	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        //euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
         
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }

            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();

        }
    	
    	//@Analyser
        public static void ParaphraseROUGENCalculatorToHashMapUsingParallelization() {
    		long startTime = System.currentTimeMillis();
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
    		
    		distanceMap.clear();// Clear the content of previous execution
        	//euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	//String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    //double distance = euclideanExtractor(dis);
                    	String orgTask = orgTaskExtractor(Task);
                        String paraTask = paraTaskExtractor(paraphrase);
                    	double distance = calculateROUGETwoScore(orgTask, paraTask);
                    	                    	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        //euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
         
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }
            
            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();

        }
    	
    	//@Analyser
        public static void ParaphraseROUGELCalculatorToHashMapUsingParallelization() {
    		long startTime = System.currentTimeMillis(); 
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();

    		
        	distanceMap.clear();// Clear the content of previous execution
        	//euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	//String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    //double distance = euclideanExtractor(dis);
                    	String orgTask = orgTaskExtractor(Task);
                        String paraTask = paraTaskExtractor(paraphrase);
                    	double distance = calculateROUGELScore(orgTask, paraTask);
                    	                    	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        //euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
         
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }
            
            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime; 
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();
        }
    	
    	//@Analyser
        public static void ParaphraseMeteorCalculatorToHashMapUsingParallelization() {
    		long startTime = System.currentTimeMillis(); 
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
    		
        	distanceMap.clear();// Clear the content of previous execution
        	//euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;

                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	//String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    //double distance = euclideanExtractor(dis);
                    	String orgTask = orgTaskExtractor(Task);
                        String paraTask = paraTaskExtractor(paraphrase);
                    	double distance = calculateMETEORScore(orgTask, paraTask);
                                            	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        //euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
         
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }

            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();
        }
    	
    	//@Analyser
        public static void ParaphraseChrFCalculatorToHashMapUsingParallelization() {
    		long startTime = System.currentTimeMillis(); 
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
    		
        	distanceMap.clear();// Clear the content of previous execution
        	//euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;
                
                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	//String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    //double distance = euclideanExtractor(dis);
                    	String orgTask = orgTaskExtractor(Task);
                        String paraTask = paraTaskExtractor(paraphrase);
                    	double distance = calculateChrFScore(orgTask, paraTask);
                    	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        //euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            StringBuilder outputMessage = new StringBuilder();
         // Output the content of the HashMap
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                outputMessage.append("ID_of_Paraphrase: ").append(entry.getKey())
                             .append(", Euclidean_Distance: ").append(entry.getValue())
                             .append("\n");
            }

            // Display the list in a dialog box
            JOptionPane.showMessageDialog(null, outputMessage.toString(), "Euclidean Distances", JOptionPane.INFORMATION_MESSAGE);
            
            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }

            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();
        }
    	
    	//@Analyser
        public static void ParaphraseLevenshteinCharacterLevelCalculatorToHashMapUsingParallelization() {
    		long startTime = System.currentTimeMillis(); 
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
    		
        	distanceMap.clear();// Clear the content of previous execution
        	//euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;
                
                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	//String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    //double distance = euclideanExtractor(dis);
                    	String orgTask = orgTaskExtractor(Task);
                        String paraTask = paraTaskExtractor(paraphrase);
                    	double distance = calculateLevenshteinDistanceCharacterLevel(orgTask, paraTask);
                    	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        //euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            StringBuilder outputMessage = new StringBuilder();
         // Output the content of the HashMap
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                outputMessage.append("ID_of_Paraphrase: ").append(entry.getKey())
                             .append(", Euclidean_Distance: ").append(entry.getValue())
                             .append("\n");
            }

            // Display the list in a dialog box
            JOptionPane.showMessageDialog(null, outputMessage.toString(), "Euclidean Distances", JOptionPane.INFORMATION_MESSAGE);
            
            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }

            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();
        }
    	
    	// Method to execute Python script and parse Levenshtein distance
        public static double calculateLevenshteinDistanceCharacterLevel(String string1, String string2) throws Exception {
            double distance = 0.0;

            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python313\\python.exe"; // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\calculate_levenshtein.py"; // Update with the actual path to your Python script

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);
            
            // Add the two strings as command-line arguments
            command.add(string1);
            command.add(string2);

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Read the output from the Python script
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println("Python Output: " + line);
                    
                    // Split the string by ":" and trim whitespace
                    String[] parts = line.split(":");
                    if (parts.length >= 2) {
                        String distanceString = parts[1].trim(); // Get the second part and trim whitespace
                        try {
                            distance = Double.parseDouble(distanceString); // Convert to double (if distance is numeric)
                            System.out.println("Extracted Levenshtein distance: " + distance);
                        } catch (NumberFormatException e) {
                            System.err.println("Error parsing distance: " + distanceString);
                        }
                    } else {
                        System.err.println("Invalid format: " + line);
                    }
                }

                // Wait for the process to complete
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            
            return distance;
        }
        
        
        //@Analyser
        public static void ParaphraseLevenshteinWordLevelCalculatorToHashMapUsingParallelization() {
            long startTime = System.currentTimeMillis(); 
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
    		
        	distanceMap.clear();// Clear the content of previous execution
        	
        	for (Map.Entry<String, Integer> entry : numberOfWordsMap.entrySet()) {
        	    distanceMap.put(entry.getKey(), entry.getValue().doubleValue());
        	}


            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            StringBuilder outputMessage = new StringBuilder();
         // Output the content of the HashMap
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                outputMessage.append("ID_of_Paraphrase: ").append(entry.getKey())
                             .append(", Euclidean_Distance: ").append(entry.getValue())
                             .append("\n");
            }

            // Display the list in a dialog box
            JOptionPane.showMessageDialog(null, outputMessage.toString(), "Euclidean Distances", JOptionPane.INFORMATION_MESSAGE);
            
            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }

            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            //neighbourhoodMap.clear();
            //numberOfWordsMap.clear();
        	
        }
        
        
        //@Analyser
        public static void ParaphraseLevenshteinWordLevelCalculatorToHashMapUsingParallelizationTwo() {
    		long startTime = System.currentTimeMillis(); 
    		
    		// Create an instance of the Runtime class
            Runtime runtime = Runtime.getRuntime();
            // Call garbage collector to free up memory before measurement
            runtime.gc();
            // Measure memory usage before function execution
            long beforeUsedMemory = runtime.totalMemory() - runtime.freeMemory();
    		
        	distanceMap.clear();// Clear the content of previous execution
        	//euclideanDistanceMap.clear();
            // Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

            // Create thread pool for parallel execution
            ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

            // List to hold Future objects for each computation task
            List<Future<Double>> futures = new ArrayList<>();

            // Loop through the paraphrases and submit tasks to executor service
            for (int i = 1; i < testSuite.testSet.size(); i++) {
                TestCase<String, String> y = testSuite.testSet.get(i);
                String id_of_paraphrase = y.id;
                String paraphrase = y.input;
                
                // Log the input for debugging
                System.out.println("Submitting task for paraphrase ID: " + id_of_paraphrase + ", Text: " + paraphrase);

                // Submit task to executor service
                futures.add(executorService.submit(() -> {
                    try {
                        // Compute the distances
                        //double distance = SemanticSimilarityUsingRoberta(Task, paraphrase);
                    	//String dis = computeDistancesBetweenParaphrases(Task, paraphrase);
    				    //double distance = euclideanExtractor(dis);
                    	String orgTask = orgTaskExtractor(Task);
                        String paraTask = paraTaskExtractor(paraphrase);
                    	double distance = calculateLevenshteinDistanceWordLevel(orgTask, paraTask);
                    	
                        System.out.println("Computed similarity score for " + id_of_paraphrase + ": " + distance);
                        return distance;
                    } catch (Exception e) {
                        e.printStackTrace();
                        return null;
                    }
                }));
            }

            // Loop through futures to get results and store in HashMap
            for (int i = 0; i < futures.size(); i++) {
                Future<Double> future = futures.get(i);
                try {
                    Double distance = future.get(); // Blocking call to get result
                    if (distance != null) {
                        double euclidean_distance = distance;
                        // Store the results in the HashMap
                        distanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                        //euclideanDistanceMap.put(testSuite.testSet.get(i + 1).id, euclidean_distance);
                    } else {
                        // Handle case where computation failed
                        System.out.println("Failed to compute distance for paraphrase: " + (i + 1));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // Shutdown executor service
            executorService.shutdown();

            // Output the content of the HashMap (optional, for verification)
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                System.out.println("ID_of_Paraphrase: " + entry.getKey() + ", Euclidean_Distance: " + entry.getValue());
            }

            StringBuilder outputMessage = new StringBuilder();
         // Output the content of the HashMap
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                outputMessage.append("ID_of_Paraphrase: ").append(entry.getKey())
                             .append(", Euclidean_Distance: ").append(entry.getValue())
                             .append("\n");
            }

            // Display the list in a dialog box
            JOptionPane.showMessageDialog(null, outputMessage.toString(), "Euclidean Distances", JOptionPane.INFORMATION_MESSAGE);
            
            double minDistance = Double.POSITIVE_INFINITY; // For the lowest distance (highest similarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() < minDistance) { // Find the lowest Euclidean distance
                    minDistance = entry.getValue();
                    IdWithHighestSimilarity = entry.getKey();
                    highestSimilarityScore = entry.getValue(); // This is now the lowest distance (highest similarity)
                }
            }

            double maxDistance = Double.NEGATIVE_INFINITY; // For the maximum distance (highest dissimilarity)
            
            for (Map.Entry<String, Double> entry : distanceMap.entrySet()) {
                if (entry.getValue() > maxDistance) { // Find the maximum Euclidean distance
                    maxDistance = entry.getValue();
                    maxId = entry.getKey(); // Holding the ID with the maximum distance (highest dissimilarity)
                }
            }

            // End time measurement
            long endTime = System.currentTimeMillis();
            // Calculate and print the elapsed time
            elapsedTime = endTime - startTime;
            
            // Measure memory usage after function execution
            long afterUsedMemory = runtime.totalMemory() - runtime.freeMemory();
            // Calculate the memory used by the function
            long memoryUsed = afterUsedMemory - beforeUsedMemory;
            // Convert memory usage to megabytes (MB)
            memoryUsedInMB = memoryUsed / (1024.0 * 1024.0);
            
            createCsvFromHashMaps(distanceMap); // ID_of_Task,ID_of_Paraphrase,SimilarityScore,Neighbourhood,NumberOfWords
            saveElapsedTimeAndUsedMemory(memoryUsedInMB, elapsedTime);
            neighbourhoodMap.clear();
            numberOfWordsMap.clear();
        }
        
        public static void saveElapsedTimeAndUsedMemory(double memoryUsedInMB, long elapsedTime) {
        	// Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            
            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(ID_of_Task);
        	
        	String TimePath = folderPath.concat("\\").concat("ElapsedTime.txt");
            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                // Write the Time to the file
                writer2.write(Long.toString(elapsedTime)+ " milliseconds");
            } catch (IOException e) {
                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
            }
            
            String MemoryUsagePath = folderPath.concat("\\").concat("MemoryUsage.txt");
            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(MemoryUsagePath))) {
                // Write the Time to the file
                writer2.write(Double.toString(memoryUsedInMB)+ " MB");
            } catch (IOException e) {
                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
            }
        }
    	
    	// Method to execute Python script and parse Levenshtein distance
        public static double calculateLevenshteinDistanceWordLevel(String string1, String string2) throws Exception {
            double distance = 0.0;

            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python313\\python.exe"; // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\calculate_levenshtein_word_level.py"; // Update with the actual path to your Python script

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);
            
            // Add the two strings as command-line arguments
            command.add(string1);
            command.add(string2);

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Read the output from the Python script
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println("Python Output: " + line);
                    
                    // Split the string by ":" and trim whitespace
                    String[] parts = line.split(":");
                    if (parts.length >= 2) {
                        String distanceString = parts[1].trim(); // Get the second part and trim whitespace
                        try {
                            distance = Double.parseDouble(distanceString); // Convert to double (if distance is numeric)
                            System.out.println("Extracted Levenshtein distance: " + distance);
                        } catch (NumberFormatException e) {
                            System.err.println("Error parsing distance: " + distanceString);
                        }
                    } else {
                        System.err.println("Invalid format: " + line);
                    }
                }

                // Wait for the process to complete
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            
            return distance;
        }
    
    	
    	private static String orgTaskExtractor(String content) throws IOException {
        	String problemDescription = null;
            
            // Define the regex pattern to capture the problem description
            String regex = "Problem Description :\\s+(.*?)\\s+The programming language";

            // Create a Pattern object
            Pattern pattern = Pattern.compile(regex, Pattern.DOTALL);
            
            // Create a Matcher object
            Matcher matcher = pattern.matcher(content);

            // Find the matching substring
            if (matcher.find()) {
                problemDescription = matcher.group(1).trim();
                System.out.println("Extracted Problem Description:");
                System.out.println(problemDescription);
            } else {
                System.out.println("Problem Description not found in input text.");
            }
            return problemDescription;
        }
        
        private static String paraTaskExtractor(String content) throws IOException {
            
            String cleanedDescription = cleanDescriptionTwo(content);
            return cleanedDescription;
        }
        
        public static String cleanDescriptionTwo(String description) {
            // Regular expression to match leading numbers followed by a dot and a space
            String regex = "^[0-9]+\\.\\s*";
            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(description);
            
            // Replace leading numbers and dot
            String cleaned = matcher.replaceFirst("");

            // Remove "The programming language is Java." and everything after it
            regex = "\\s*The programming language is Java\\.\\s*.*?\\s*Problem Id is.*?$";
            pattern = Pattern.compile(regex, Pattern.DOTALL);
            matcher = pattern.matcher(cleaned);

            return matcher.replaceFirst("").trim();
        }
        
     // Method to execute Python script and parse ChrF score
        public static double calculateChrFScore(String reference, String candidate) throws Exception {
            double score = 0.0;
            
            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python312\\python.exe"; // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\calculate_chrf.py"; // Update with the actual path to your Python script

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);
            command.add(reference);  // Add reference sentence
            command.add(candidate);  // Add candidate sentence

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Use try-with-resources to ensure proper closing of BufferedReader
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        //System.out.println("Python Output: " + line);

                        // Extract ChrF score from the output
                        if (line.contains("ChrF Score:")) { // Match the exact output from the Python script
                            String scoreString = line.split(":")[1].trim(); // Get the score part and trim whitespace
                            try {
                                score = Double.parseDouble(scoreString); // Convert to double
                                System.out.println("Extracted ChrF score: " + score);
                            } catch (NumberFormatException e) {
                                System.err.println("Error parsing score: " + scoreString);
                            }
                        }
                    }
                }

                // Wait for the process to complete
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
    		return score;
        }
    	
     // Method to execute Python script and parse METEOR score
        public static double calculateMETEORScore(String reference, String candidate) throws Exception {
            double score = 0.0;
            
            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python312\\python.exe"; // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\calculate_meteor.py"; // Update with the actual path to your Python script

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);
            command.add(reference);  // Add reference sentence
            command.add(candidate);  // Add candidate sentence

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Use try-with-resources to ensure proper closing of BufferedReader
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        //System.out.println("Python Output: " + line);

                        // Extract METEOR score from the output
                        if (line.contains("METEOR Score:")) { // Match the exact output from the Python script
                            String scoreString = line.split(":")[1].trim(); // Get the score part and trim whitespace
                            try {
                                score = Double.parseDouble(scoreString); // Convert to double
                                System.out.println("Extracted METEOR score: " + score);
                            } catch (NumberFormatException e) {
                                System.err.println("Error parsing score: " + scoreString);
                            }
                        }
                    }
                }

                // Wait for the process to complete
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
    		return score;
        }
        
        public static double calculateROUGETwoScore(String candidate, String reference) throws Exception {

            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python312\\python.exe"; // Update with your Python interpreter path // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\calculate_rouge.py"; // Update with the actual path to your Python script

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);

            // Add reference and candidate as command line arguments
            command.add(reference);
            command.add(candidate);

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Read the output from the Python script
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    //System.out.println("Python Output: " + line);
                    // You can extract individual ROUGE scores here if needed
                    String substring = "fmeasure=";

                    if (line.contains(substring)) {
                        // Find the starting index of the substring
                        int startIndex = line.indexOf(substring);
                        
                        // Calculate the index that starts right after the substring
                        int afterIndex = startIndex + substring.length();
                        
                        // Now you can extract or work with the text after the substring
                        //System.out.println("Index after fmeasure= is: " + afterIndex);

                        // For example, extracting the part of the string after "fmeasure="
                        String afterSubstring = line.substring(afterIndex);
                        afterSubstring = afterSubstring.substring(0, afterSubstring.length() - 1);
                        //System.out.println("Text after fmeasure=: " + afterSubstring);
                        
                        if(line.contains("rouge2")) {
                        	System.out.println("Rouge2 = " + afterSubstring);
                        	return Double.valueOf(afterSubstring);
                        }
                        
                    }
                }

                // Wait for the process to complete
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
    		return 0;
        }
        
        public static double calculateROUGELScore(String candidate, String reference) throws Exception {

            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python312\\python.exe"; // Update with your Python interpreter path // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\calculate_rouge.py"; // Update with the actual path to your Python script

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);

            // Add reference and candidate as command line arguments
            command.add(reference);
            command.add(candidate);

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Read the output from the Python script
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    //System.out.println("Python Output: " + line);
                    // You can extract individual ROUGE scores here if needed
                    String substring = "fmeasure=";

                    if (line.contains(substring)) {
                        // Find the starting index of the substring
                        int startIndex = line.indexOf(substring);
                        
                        // Calculate the index that starts right after the substring
                        int afterIndex = startIndex + substring.length();
                        
                        // Now you can extract or work with the text after the substring
                        //System.out.println("Index after fmeasure= is: " + afterIndex);

                        // For example, extracting the part of the string after "fmeasure="
                        String afterSubstring = line.substring(afterIndex);
                        afterSubstring = afterSubstring.substring(0, afterSubstring.length() - 1);
                        //System.out.println("Text after fmeasure=: " + afterSubstring);
                        
                        if(line.contains("rougeL")) {
                        	System.out.println("RougeL = " + afterSubstring);
                        	return Double.valueOf(afterSubstring);
                        }                    
                    }
                }

                // Wait for the process to complete
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
    		return 0;
        }
        
        public static double calculateBLEUScoreTwo(String candidate, String refer) throws Exception {

        	List<String> references = new ArrayList<>();
            references.add(refer);
                         
            double score = 0.0;	
            // Absolute path to the Python interpreter
            String pythonInterpreterPath = "C:\\Users\\debal\\AppData\\Local\\Programs\\Python\\Python312\\python.exe"; // Update with your Python interpreter path

            // Absolute path to the Python script
            String pythonScriptPath = "C:\\Users\\debal\\Downloads\\calculate_bleu.py"; // Update with the actual path to your Python script

            // Command to execute the Python script
            List<String> command = new ArrayList<>();
            command.add(pythonInterpreterPath);
            command.add(pythonScriptPath);
            
            // Add references and candidate as command line arguments
            for (String reference : references) {
                command.add(reference);
            }
            command.add(candidate);

            try {
                // Build and start the process
                ProcessBuilder processBuilder = new ProcessBuilder(command);
                Process process = processBuilder.start();

                // Read the output from the Python script
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println("Python Output: " + line);
                    
                 // Split the string by ":" and trim whitespace
                    String[] parts = line.split(":");
                    if (parts.length >= 2) {
                        String scoreString = parts[1].trim(); // Get the second part and trim whitespace
                        try {
                            score = Double.parseDouble(scoreString); // Convert to double (if score is numeric)
                            score = score / 100;
                            System.out.println("Extracted BLEU score: " + score);
                        } catch (NumberFormatException e) {
                            System.err.println("Error parsing score: " + scoreString);
                        }
                    } else {
                        System.err.println("Invalid format: " + line);
                    }
                }

                // Wait for the process to complete
                int exitCode = process.waitFor();
                if (exitCode != 0) {
                    System.err.println("Error: Python script exited with code " + exitCode);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
    		return score;
        }
        
        //@Analyser
        public static void ParaphraseDistanceCalculatorAcrossAllMetrics() throws Exception {
        	// Retrieve the original problem (Task) and its ID
            TestCase<String, String> x = testSuite.testSet.get(0);
            String Task = x.input;
            String ID_of_Task = x.id;
            
            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(ID_of_Task);
            String outputFilePath = folderPath.concat("\\").concat("ParaphraseDistance.csv");
            
            // Ensure the folder path exists
            Path path = Paths.get(folderPath);
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // Prepare the CSV file writer
            try (FileWriter csvWriter = new FileWriter(outputFilePath)) {
                // Write CSV header
                //csvWriter.append("ID_of_Task,ID_of_Paraphrase,Cosine_Distance,Euclidean_Distance,Task,Paraphrase\n");
            	csvWriter.append("ID_of_Task,ID_of_Paraphrase,Paraphrase,CosineSimilarity,EuclideanDistance,SemanticSimilarity,BLEU,RougeN,RougeL,Meteor,ChrF\n");

                // Loop through the paraphrases
                for (int i = 1; i < testSuite.testSet.size(); i++) {
                    TestCase<String, String> y = testSuite.testSet.get(i);
                    String id_of_paraphrase = y.id;
                    String paraphrase = y.input;

                    // Compute the distances
                    String distance;
                    double semantic_similarity;
					distance = computeDistancesBetweenParaphrases(Task, paraphrase);
					semantic_similarity = SemanticSimilarityUsingRoberta(Task, paraphrase);
					String orgTask = orgTaskExtractor(Task);
                    String paraTask = paraTaskExtractor(paraphrase);
                	double chrf_distance = calculateChrFScore(orgTask, paraTask);
                	double meteor_distance = calculateMETEORScore(orgTask, paraTask);
                	double rougeL_distance = calculateROUGELScore(orgTask, paraTask);
                	double rougeN_distance = calculateROUGETwoScore(orgTask, paraTask);
                	double BLEU = calculateBLEUScoreTwo(orgTask, paraTask);
					
                    double cosine_distance = cosineExtractor(distance);
                    double euclidean_distance = euclideanExtractor(distance);

                 // Write the results to the CSV file
                    csvWriter.append(ID_of_Task).append(",")
                             .append(id_of_paraphrase).append(",")
                             .append(paraphrase.replace(",", " ").replace("\n", " ")).append(",")
                             .append(String.valueOf(cosine_distance)).append(",")
                             .append(String.valueOf(euclidean_distance)).append(",")
                             //.append(Task.replace(",", " ").replace("\n", " ")).append(",")                             
                             .append(String.valueOf(semantic_similarity)).append(",")
                             .append(String.valueOf(BLEU)).append(",")
                             .append(String.valueOf(rougeN_distance)).append(",")
                             .append(String.valueOf(rougeL_distance)).append(",")
                             .append(String.valueOf(meteor_distance)).append(",")
                             .append(String.valueOf(chrf_distance)).append("\n");
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
            
            sortedParaphrasesByEuclidean = fetchParaphrasesInOrder(outputFilePath);
            printHighestAndLowestEuclideanDistances(sortedParaphrasesByEuclidean);
        }
        
        @MakeSeed
        public void Dialogue() throws FileNotFoundException, IOException, InterruptedException {
        	long startTime = System.currentTimeMillis();
        	ManualModification();
        	String x = currentTestCase.input;
        	String selectedExecutor = null;
        	// Create a JComboBox for selecting the executor
            String[] executors = {"ChatGPT", "Falcon7B", "openCoPilot", "GeminiPro", "Llama2"};
            JComboBox<String> executorComboBox = new JComboBox<>(executors);

            // Show the dropdown dialog to the user
            int result = JOptionPane.showConfirmDialog(null, executorComboBox, "Select Executor",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

            if (result == JOptionPane.OK_OPTION) {
                selectedExecutor = (String) executorComboBox.getSelectedItem();
                long startModelExecutionTime = System.currentTimeMillis();
                
                if(selectedExecutor == "ChatGPT") {
                	ChatGPT(x);
                }else if(selectedExecutor == "Falcon7B"){
                	Falcon7B(x);
                }else if(selectedExecutor == "openCoPilot") {
                	openCoPilot(x);
                }else if(selectedExecutor == "Llama2") {
                	LLama2(x);
                }else if(selectedExecutor == "GeminiPro") {
                	GeminiPro(x);
                }else {
                	System.out.println("Not a valid executer");
                }
                
                long endModelExecutionTime = System.currentTimeMillis();
                long timeStampForExecution = endModelExecutionTime - startModelExecutionTime;
                int serialNum = numberOfAttempts + 1;
                String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
                folderPath = folderPath.concat(currentProblemID);
                String TimePathForExecution = folderPath.concat("\\").concat("ElapsedTimeForModelExecution_").concat(String.valueOf(serialNum)).concat(".txt");
                try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePathForExecution))) {
                    // Write the Time to the file
                    writer2.write(Long.toString(timeStampForExecution)+ " milliseconds");
                } catch (IOException e) {
                    System.out.println("An exception occurred while writing to the file: " + e.getMessage());
                }
            }
            
                try {
                EvosuiteTestCaseGenerator();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while generating Evosuite test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunner();
            	} catch (Exception e) {
                    System.out.println("An exception occurred while running Evosuite test cases: " + e.getMessage());
                }
            	try {
                DetectCompilingGivenCode();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseGeneratorOnGivenSolution();
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                EvosuiteTestCaseRunnerOnGivenSolutionForGivenSolution(); 
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
            	try {
                detectCompilingOfGivenSolutionGeneratedTestCasesOnGeneratedCode();// replacing given solution by generated code and compile, to run test cases generated on Given solution by Evosuite on generated code
            	}
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                EvosuiteTestCaseRunnerOnGeneratedCodeForGivenSolution();
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }        
                
                try {
                detectCompilingOfGeneratedSolutionGeneratedTestCasesOnGivenSolution(); ////
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }
                try {
                EvosuiteTestCaseRunnerOnGivenCodeForGeneratedSolution(); ////
                }
                catch (Exception e) {
                    System.out.println("An exception occurred while running test cases: " + e.getMessage());
                }                  
                //try {
                //	GeminiProTestCaseGenerator(Task);
                //}catch(IOException e) {
                //    System.out.println("An exception occurred while generating test cases: " + e.getMessage());
                //}
                //DetectCompiling();
                //PMDCodeAnalyzerForComplexityOnGeneratedCode();
                //PMDCodeAnalyzerForComplexityOnGivenSolution();    
                
                // Wait for 60 seconds before running the next test case
                try {
                Thread.sleep(60000); // 60 seconds = 60,000 milliseconds
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted while sleeping: " + e.getMessage());
                }
        	
            numberOfAttempts++;	    	
    		JOptionPane.showMessageDialog(null, "Number of attempts done: " + numberOfAttempts, "Information", JOptionPane.INFORMATION_MESSAGE);   
    		// Saving the task
            String folderPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\";
            folderPath = folderPath.concat(currentProblemID);
            String questionPath = folderPath.concat("\\").concat("task_").concat(String.valueOf(numberOfAttempts)).concat(".txt");

            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(questionPath))) {
                // Write the Task to the file
                writer2.write(x);
            } catch (IOException e) {
                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
            }
            String responsePath = folderPath.concat("\\").concat("response_").concat(String.valueOf(numberOfAttempts)).concat(".txt");

            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(responsePath))) {
                // Write the Task to the file
                writer2.write(outputOfCurrentTestCase);
            } catch (IOException e) {
                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
            }            
    		String attemptPath = folderPath.concat("\\").concat("NumberOfAttempts.txt");

            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(attemptPath))) {
                // Write the Task to the file
                writer2.write(String.valueOf(numberOfAttempts));
            } catch (IOException e) {
                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
            }
            long endTime = System.currentTimeMillis();
            long timeStamp = endTime - startTime;
            String TimePath = folderPath.concat("\\").concat("ElapsedTime_").concat(String.valueOf(numberOfAttempts)).concat(".txt");
            try (BufferedWriter writer2 = new BufferedWriter(new FileWriter(TimePath))) {
                // Write the Time to the file
                writer2.write(Long.toString(timeStamp)+ " milliseconds");
            } catch (IOException e) {
                System.out.println("An exception occurred while writing to the file: " + e.getMessage());
            }
        }
        
        public static String[] showCustomInputDialog(String[] inputFields) {
            JPanel panel = new JPanel(new GridLayout(inputFields.length, 2));

            // Create text fields and labels
            JTextField[] textFields = new JTextField[inputFields.length];
            for (int i = 0; i < inputFields.length; i++) {
                panel.add(new JLabel(inputFields[i]));
                textFields[i] = new JTextField();
                panel.add(textFields[i]);
            }

            int result = JOptionPane.showOptionDialog(
                    null,
                    panel,
                    "Custom Input",
                    JOptionPane.OK_CANCEL_OPTION,
                    JOptionPane.PLAIN_MESSAGE,
                    null,
                    null,
                    null
            );

            if (result == JOptionPane.OK_OPTION) {
                // User clicked OK, collect input values
                return Arrays.stream(textFields).map(JTextField::getText).toArray(String[]::new);
            } else {
                // User clicked Cancel or closed the dialog
                return null;
            }
        }
        
    
    //@MakeSeed
	public void DialogueWithChatGPT(){
    	
    	TestCase<String, String> tc;
    	String promptTwo = "";
		String programLanguage;
	    List<String> problemSections = new ArrayList<>();
	    String problemSection;
	    String moreSection;
	    String programLanguageTwo;
	    String enterProblemID;
	    
	    
		while (true) {
			tc = new TestCase<String, String>();
			problemSection = JOptionPane.showInputDialog("Enter a problem section: ");
			problemSections.add(problemSection);
			promptTwo = promptTwo + " " + problemSection;
			
			moreSection = JOptionPane.showInputDialog("Do you have more problem sections (yes/no)? ");
			if (moreSection.equals("no")) {
                break; // User does not want to add more sections.
            }
		}
		programLanguageTwo = JOptionPane.showInputDialog("Enter the program language: ");
		promptTwo = promptTwo + " The programming language is " + programLanguageTwo + ".";
		enterProblemID = currentTestCase.id;
		
		promptTwo = promptTwo + "." + " Problem Id is : " + enterProblemID + ".";
		
		String lastVersion = version;
                        
        String majorChanges = JOptionPane.showInputDialog("Are there major changes? (yes/no): ");

        if (majorChanges.equalsIgnoreCase("yes")) {
            version = incrementMajorVersion(lastVersion);
        } else {
            version = incrementMinorVersion(lastVersion);
        }        
              
		tc.input = promptTwo;
	    tc.feature = TestDataFeature.original;
	    tc.setType("ProgrammingProblem");
	    tc.id = enterProblemID;
	    
	    List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<TestCase<String, String>>();
        toBeRemovedTCs.add(currentTestCase);
        testSuite.removeAllTestCases(toBeRemovedTCs);
        
	    currentTestCase = tc;
	    testSuite.addTestCase(tc);	
		numberOfConversation++;	    	
		JOptionPane.showMessageDialog(null, "Number of attempts done: " + numberOfConversation, "Information", JOptionPane.INFORMATION_MESSAGE);
    }
	
	//@TestSetMetric
	public void AverageViolationsPerSampleForCognitiveComplexity() {
		String[] rootOptions = {
                "Reference Solutions", "Gemini Pro", "ChatGPT", "Codex", "Falcon"
        };

        String[] rootPaths = {
                "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiProGivenSolutions",
                "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiPro",
                "C:\\Users\\debal\\Downloads\\ChatGPT\\ChatGPT",
                "C:\\Users\\debal\\Downloads\\Codex\\Codex",
                "C:\\Users\\debal\\Downloads\\Falcon_new-20250303T133636Z-001\\Falcon_new"
        };

        String selectedOption = (String) JOptionPane.showInputDialog(
                null,
                "Select a root directory:",
                "Root Directory Selector",
                JOptionPane.PLAIN_MESSAGE,
                null,
                rootOptions,
                rootOptions[0]
        );

        if (selectedOption == null) {
            JOptionPane.showMessageDialog(null, "No selection made.");
            return;
        }

        int selectedIndex = Arrays.asList(rootOptions).indexOf(selectedOption);
        String rootDirectoryPath = rootPaths[selectedIndex];

        String complexityInput = JOptionPane.showInputDialog(null, "Enter Cognitive Complexity (e.g., 3):");
        if (complexityInput == null || complexityInput.isEmpty()) {
            JOptionPane.showMessageDialog(null, "No complexity entered.");
            return;
        }

        int targetComplexity;
        try {
            targetComplexity = Integer.parseInt(complexityInput.trim());
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid complexity value.");
            return;
        }

        // Run analysis
        String analysisResult = analyzeViolationsForCognitive(new File(rootDirectoryPath), targetComplexity);

        // Show only average violations per sample
        JOptionPane.showMessageDialog(null, analysisResult, "Violation Analysis", JOptionPane.INFORMATION_MESSAGE);
    }

    private static String analyzeViolationsForCognitive(File rootDirectory, int targetComplexity) {
        int sampleCount = 0;
        int totalViolations = 0;

        File[] mainFolders = rootDirectory.listFiles(File::isDirectory);
        if (mainFolders == null) return "No folders found in: " + rootDirectory;

        for (File folder : mainFolders) {
            File[] subFolders = folder.listFiles(File::isDirectory);
            if (subFolders != null) {
                for (File subFolder : subFolders) {
                    int complexity = getCognitiveComplexity(new File(subFolder, "ComplexitiesOfGivenSolution.txt"));
                    if (complexity != targetComplexity) continue;

                    sampleCount++;
                    totalViolations += countViolations(new File(subFolder, "PMDViolationAnalysis.txt"));
                    totalViolations += countViolations(new File(subFolder, "CheckstyleViolationAnalyzerByGoogle.txt"));
                    totalViolations += countViolations(new File(subFolder, "CheckstyleViolationAnalyzerBySun.txt"));
                }
            }
        }

        if (sampleCount == 0) return "No samples found with cyclomatic complexity " + targetComplexity;

        double averageViolationsPerSample = (double) totalViolations / (sampleCount * 10);
        return String.format("Cyclomatic Complexity: %d\nAverage Violations per Sample: %.2f", targetComplexity, averageViolationsPerSample);
    }

    private static int getCognitiveComplexity(File complexityFile) {
        if (!complexityFile.exists()) return -1;
        try (Scanner scanner = new Scanner(complexityFile)) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (line.startsWith("Cognitive complexity:") || line.startsWith("Highest cognitive complexity:")) {
                    return Integer.parseInt(line.split(":")[1].trim());
                }
            }
        } catch (Exception e) {
            System.err.println("Error reading: " + complexityFile.getName());
        }
        return -1;
    }
    
    
    //@TestSetMetric
	public void AverageViolationsPerSampleForLinesOfCode() {
		String[] rootOptions = {
                "Reference Solutions", "Gemini Pro", "ChatGPT", "Codex", "Falcon"
        };

        String[] rootPaths = {
                "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiProGivenSolutions",
                "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiPro",
                "C:\\Users\\debal\\Downloads\\ChatGPT\\ChatGPT",
                "C:\\Users\\debal\\Downloads\\Codex\\Codex",
                "C:\\Users\\debal\\Downloads\\Falcon_new-20250303T133636Z-001\\Falcon_new"
        };

        String selectedOption = (String) JOptionPane.showInputDialog(
                null,
                "Select a root directory:",
                "Root Directory Selector",
                JOptionPane.PLAIN_MESSAGE,
                null,
                rootOptions,
                rootOptions[0]
        );

        if (selectedOption == null) {
            JOptionPane.showMessageDialog(null, "No selection made.");
            return;
        }

        int selectedIndex = Arrays.asList(rootOptions).indexOf(selectedOption);
        String rootDirectoryPath = rootPaths[selectedIndex];

        String complexityInput = JOptionPane.showInputDialog(null, "Enter Lines Of Code (e.g., 50):");
        if (complexityInput == null || complexityInput.isEmpty()) {
            JOptionPane.showMessageDialog(null, "No complexity entered.");
            return;
        }

        int targetComplexity;
        try {
            targetComplexity = Integer.parseInt(complexityInput.trim());
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid complexity value.");
            return;
        }

        // Run analysis
        String analysisResult = analyzeViolationsForLOC(new File(rootDirectoryPath), targetComplexity);

        // Show only average violations per sample
        JOptionPane.showMessageDialog(null, analysisResult, "Violation Analysis", JOptionPane.INFORMATION_MESSAGE);
    }

    private static String analyzeViolationsForLOC(File rootDirectory, int targetComplexity) {
        int sampleCount = 0;
        int totalViolations = 0;

        File[] mainFolders = rootDirectory.listFiles(File::isDirectory);
        if (mainFolders == null) return "No folders found in: " + rootDirectory;

        for (File folder : mainFolders) {
            File[] subFolders = folder.listFiles(File::isDirectory);
            if (subFolders != null) {
                for (File subFolder : subFolders) {
                    int complexity = getLOCComplexity(new File(subFolder, "ComplexitiesOfGivenSolution.txt"));
                    if (complexity != targetComplexity) continue;

                    sampleCount++;
                    totalViolations += countViolations(new File(subFolder, "PMDViolationAnalysis.txt"));
                    totalViolations += countViolations(new File(subFolder, "CheckstyleViolationAnalyzerByGoogle.txt"));
                    totalViolations += countViolations(new File(subFolder, "CheckstyleViolationAnalyzerBySun.txt"));
                }
            }
        }

        if (sampleCount == 0) return "No samples found with cyclomatic complexity " + targetComplexity;

        double averageViolationsPerSample = (double) totalViolations / (sampleCount * 10);
        return String.format("Cyclomatic Complexity: %d\nAverage Violations per Sample: %.2f", targetComplexity, averageViolationsPerSample);
    }

    private static int getLOCComplexity(File complexityFile) {
	    if (!complexityFile.exists()) return -1;
	    try (Scanner scanner = new Scanner(complexityFile)) {
	        while (scanner.hasNextLine()) {
	            String line = scanner.nextLine();
	            if (line.startsWith("Lines of Code (LOC):")) {
	                int loc = Integer.parseInt(line.split(":")[1].trim());

	                // Categorize LOC into ranges
	                if (loc >= 1 && loc <= 50) return 50; // LOC range 1-50
	                if (loc >= 51 && loc <= 100) return 100; // LOC range 51-100
	                if (loc >= 101 && loc <= 150) return 150; // LOC range 101-150
	                if (loc >= 151 && loc <= 200) return 200; // LOC range 151-200
	                if (loc >= 201 && loc <= 250) return 250; // LOC range 201-250
	                // Add more ranges as needed
	                return (loc / 50) * 50 + 50; // General case for values above 250
	            }
	        }
	    } catch (Exception e) {
	        System.err.println("Error reading complexity file: " + complexityFile.getName());
	    }
	    return -1;
	}

        
    //@TestSetMetric
	public void AverageViolationsPerSampleForCyclomaticComplexity() {
		String[] rootOptions = {
                "Reference Solutions", "Gemini Pro", "ChatGPT", "Codex", "Falcon"
        };

        String[] rootPaths = {
                "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiProGivenSolutions",
                "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiPro",
                "C:\\Users\\debal\\Downloads\\ChatGPT\\ChatGPT",
                "C:\\Users\\debal\\Downloads\\Codex\\Codex",
                "C:\\Users\\debal\\Downloads\\Falcon_new-20250303T133636Z-001\\Falcon_new"
        };

        String selectedOption = (String) JOptionPane.showInputDialog(
                null,
                "Select a root directory:",
                "Root Directory Selector",
                JOptionPane.PLAIN_MESSAGE,
                null,
                rootOptions,
                rootOptions[0]
        );

        if (selectedOption == null) {
            JOptionPane.showMessageDialog(null, "No selection made.");
            return;
        }

        int selectedIndex = Arrays.asList(rootOptions).indexOf(selectedOption);
        String rootDirectoryPath = rootPaths[selectedIndex];

        String complexityInput = JOptionPane.showInputDialog(null, "Enter Cyclomatic Complexity (e.g., 3):");
        if (complexityInput == null || complexityInput.isEmpty()) {
            JOptionPane.showMessageDialog(null, "No complexity entered.");
            return;
        }

        int targetComplexity;
        try {
            targetComplexity = Integer.parseInt(complexityInput.trim());
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid complexity value.");
            return;
        }

        // Run analysis
        String analysisResult = analyzeViolations(new File(rootDirectoryPath), targetComplexity);

        // Show only average violations per sample
        JOptionPane.showMessageDialog(null, analysisResult, "Violation Analysis", JOptionPane.INFORMATION_MESSAGE);
    }

    private static String analyzeViolations(File rootDirectory, int targetComplexity) {
        int sampleCount = 0;
        int totalViolations = 0;

        File[] mainFolders = rootDirectory.listFiles(File::isDirectory);
        if (mainFolders == null) return "No folders found in: " + rootDirectory;

        for (File folder : mainFolders) {
            File[] subFolders = folder.listFiles(File::isDirectory);
            if (subFolders != null) {
                for (File subFolder : subFolders) {
                    int complexity = getCyclomaticComplexity(new File(subFolder, "ComplexitiesOfGivenSolution.txt"));
                    if (complexity != targetComplexity) continue;

                    sampleCount++;
                    totalViolations += countViolations(new File(subFolder, "PMDViolationAnalysis.txt"));
                    totalViolations += countViolations(new File(subFolder, "CheckstyleViolationAnalyzerByGoogle.txt"));
                    totalViolations += countViolations(new File(subFolder, "CheckstyleViolationAnalyzerBySun.txt"));
                }
            }
        }

        if (sampleCount == 0) return "No samples found with cyclomatic complexity " + targetComplexity;

        double averageViolationsPerSample = (double) totalViolations / (sampleCount * 10);
        return String.format("Cyclomatic Complexity: %d\nAverage Violations per Sample: %.2f", targetComplexity, averageViolationsPerSample);
    }

    private static int getCyclomaticComplexity(File complexityFile) {
        if (!complexityFile.exists()) return -1;
        try (Scanner scanner = new Scanner(complexityFile)) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (line.startsWith("Cyclomatic complexity:") || line.startsWith("Highest cyclomatic complexity")) {
                    return Integer.parseInt(line.split(":")[1].trim());
                }
            }
        } catch (Exception e) {
            System.err.println("Error reading: " + complexityFile.getName());
        }
        return -1;
    }

    private static int countViolations(File file) {
        if (!file.exists()) return 0;
        int count = 0;
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            br.readLine(); // skip total violations
            br.readLine(); // skip header
            String line;
            while ((line = br.readLine()) != null) {
                String[] parts = line.split(":", 3);
                if (parts.length == 3) {
                    count += Integer.parseInt(parts[2].trim());
                }
            }
        } catch (Exception e) {
            System.err.println("Error reading file: " + file.getName());
        }
        return count;
    }	
	
	@TestSetMetric
	public void PercentageOfSmellySamples() {
		String[] rootOptions = {
	            "Reference Solutions",
	            "Gemini Pro",
	            "ChatGPT",
	            "Codex",
	            "Falcon"
	        };

	        String[] rootPaths = {
	        	"C:\\Users\\debal\\Downloads\\Falcon_new-20250303T133636Z-001\\Falcon_new",
	            "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiProGivenSolutions",
	            "C:\\Users\\debal\\Downloads\\ChatGPT\\ChatGPT",     
	            "C:\\Users\\debal\\Downloads\\Codex\\Codex",   
	            "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiPro"
	        };

	        String selectedOption = (String) JOptionPane.showInputDialog(
	                null,
	                "Select a root directory:",
	                "Root Directory Selector",
	                JOptionPane.PLAIN_MESSAGE,
	                null,
	                rootOptions,
	                rootOptions[0]
	        );

	        if (selectedOption != null) {
	            int selectedIndex = java.util.Arrays.asList(rootOptions).indexOf(selectedOption);
	            String selectedPath = rootPaths[selectedIndex];

	            //JOptionPane.showMessageDialog(null, "You selected: " + selectedPath);
	            File root = new File(selectedPath);
	            if (!root.isDirectory()) {
	                System.out.println("Invalid root directory.");
	                return;
	            }

	            traverseFolders(root);

	            System.out.println("Total subfolders with PMD file: " + totalSubfoldersWithPMD);
	            System.out.println("Subfolders with >5 PMD violations: " + foldersWithMoreThan5Violations);

	            if (totalSubfoldersWithPMD > 0) {
	                double percentage = (foldersWithMoreThan5Violations * 100.0) / totalSubfoldersWithPMD;
	                System.out.printf("Percentage of smelly subfolders: %.2f%%\n", percentage);
	                JOptionPane.showMessageDialog(null, "Percentage of smelly subfolders: " + percentage);
	            } else {
	                System.out.println("No PMD files found in subfolders.");
	            }
	        } else {
	            System.out.println("No selection made.");
	        }
	        foldersWithMoreThan5Violations = 0;
	        totalSubfoldersWithPMD = 0;
	    }
	    
	    private static void traverseFolders(File folder) {
	        File[] files = folder.listFiles();
	        if (files == null) return;

	        boolean foundPMDFile = false;

	        for (File file : files) {
	            if (file.isFile() && file.getName().equals(TARGET_FILE_NAME)) {
	                foundPMDFile = true;
	                totalSubfoldersWithPMD++;
	                int violationCount = extractViolations(file);
	                if (violationCount > 4) {
	                    foldersWithMoreThan5Violations++;
	                }
	            } else if (file.isDirectory()) {
	                traverseFolders(file);  // Recursive call
	            }
	        }
	    }

	    private static int extractViolations(File pmdFile) {
	        try (BufferedReader reader = new BufferedReader(new FileReader(pmdFile))) {
	            String firstLine = reader.readLine();
	            if (firstLine != null && firstLine.startsWith("Total Violations:")) {
	                String[] parts = firstLine.split(":");
	                if (parts.length == 2) {
	                    return Integer.parseInt(parts[1].trim());
	                }
	            }
	        } catch (IOException e) {
	            System.out.println("Failed to read: " + pmdFile.getAbsolutePath());
	            e.printStackTrace();
	        }
	        return 0;
	    }
	    
	    
	//@TestSetMetric
	public void BaselineExceedingViolationsForTopics() {
		    // GUI for selecting root directory
	        String[] rootOptions = {
	                //"Reference Solutions",
	                "Gemini Pro",
	                "ChatGPT",
	                "Codex",
	                "Falcon"
	        };

	        String[] rootPaths = {
	                "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiProGivenSolutions",
	                //"C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiPro",
	                "C:\\Users\\debal\\Downloads\\ChatGPT\\ChatGPT",
	                "C:\\Users\\debal\\Downloads\\Codex\\Codex",
	                "C:\\Users\\debal\\Downloads\\Falcon_new-20250303T133636Z-001\\Falcon_new"
	        };

	        String selectedOption = (String) JOptionPane.showInputDialog(
	                null,
	                "Select a root directory:",
	                "Root Directory Selector",
	                JOptionPane.PLAIN_MESSAGE,
	                null,
	                rootOptions,
	                rootOptions[0]
	        );

	        if (selectedOption == null) {
	            JOptionPane.showMessageDialog(null, "No selection made.");
	            return;
	        }

	        int selectedIndex = Arrays.asList(rootOptions).indexOf(selectedOption);
	        String selectedPath = rootPaths[selectedIndex];
	        String csvFile = selectedPath + File.separator + "FilteredPositiveRelativeDifference.csv";

	        // Map violation types to smell categories
	        Map<String, String> violationToSmell = getSmellMapping();
	        Map<String, Map<String, List<Double>>> topicToSmellValues = new HashMap<>();

	        // Read CSV
	        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {
	            br.readLine(); // skip header
	            String line;
	            while ((line = br.readLine()) != null) {
	                String[] parts = line.split(",");
	                if (parts.length < 3) continue;

	                String topic = parts[0].trim();
	                String violation = parts[1].trim();
	                double diff = Double.parseDouble(parts[2].trim());

	                String smell = violationToSmell.get(violation);
	                if (smell != null) {
	                    topicToSmellValues
	                            .computeIfAbsent(topic, k -> new HashMap<>())
	                            .computeIfAbsent(smell, k -> new ArrayList<>())
	                            .add(diff);
	                }
	            }
	        } catch (IOException e) {
	            JOptionPane.showMessageDialog(null, "Error reading CSV: " + e.getMessage());
	            return;
	        }

	        // Ask for topic
	        String inputTopic = JOptionPane.showInputDialog(null, "Enter topic name:");
	        if (inputTopic == null || !topicToSmellValues.containsKey(inputTopic)) {
	            JOptionPane.showMessageDialog(null, "Topic not found.");
	            return;
	        }

	        // Compute and display
	        StringBuilder result = new StringBuilder("Smell Category Percentages for " + inputTopic + ":\n\n");
	        Map<String, List<Double>> smellData = topicToSmellValues.get(inputTopic);
	        for (Map.Entry<String, List<Double>> entry : smellData.entrySet()) {
	            double sum = 0.0;
	            for (double val : entry.getValue()) sum += val;
	            double avg = (sum / entry.getValue().size()) * 100;
	            result.append(String.format("%s: %.2f%%\n", entry.getKey(), avg));
	        }

	        JTextArea textArea = new JTextArea(result.toString());
	        textArea.setEditable(false);
	        JScrollPane scrollPane = new JScrollPane(textArea);
	        scrollPane.setPreferredSize(new java.awt.Dimension(600, 400));
	        JOptionPane.showMessageDialog(null, scrollPane, "Smell Analysis Result", JOptionPane.INFORMATION_MESSAGE);
	    }
	
	//@TestSetMetric
	public void BaselineNonExceedingViolationsForTopics() {
		    // GUI for selecting root directory
	        String[] rootOptions = {
	                //"Reference Solutions",
	                "Gemini Pro",
	                "ChatGPT",
	                "Codex",
	                "Falcon"
	        };

	        String[] rootPaths = {
	                "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiProGivenSolutions",
	                //"C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\GeminiPro",
	                "C:\\Users\\debal\\Downloads\\ChatGPT\\ChatGPT",
	                "C:\\Users\\debal\\Downloads\\Codex\\Codex",
	                "C:\\Users\\debal\\Downloads\\Falcon_new-20250303T133636Z-001\\Falcon_new"
	        };

	        String selectedOption = (String) JOptionPane.showInputDialog(
	                null,
	                "Select a root directory:",
	                "Root Directory Selector",
	                JOptionPane.PLAIN_MESSAGE,
	                null,
	                rootOptions,
	                rootOptions[0]
	        );

	        if (selectedOption == null) {
	            JOptionPane.showMessageDialog(null, "No selection made.");
	            return;
	        }

	        int selectedIndex = Arrays.asList(rootOptions).indexOf(selectedOption);
	        String selectedPath = rootPaths[selectedIndex];
	        String csvFile = selectedPath + File.separator + "FilteredNegativeRelativeDifference.csv";

	        // Map violation types to smell categories
	        Map<String, String> violationToSmell = getSmellMapping();
	        Map<String, Map<String, List<Double>>> topicToSmellValues = new HashMap<>();

	        // Read CSV
	        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {
	            br.readLine(); // skip header
	            String line;
	            while ((line = br.readLine()) != null) {
	                String[] parts = line.split(",");
	                if (parts.length < 3) continue;

	                String topic = parts[0].trim();
	                String violation = parts[1].trim();
	                double diff = Double.parseDouble(parts[2].trim());

	                String smell = violationToSmell.get(violation);
	                if (smell != null) {
	                    topicToSmellValues
	                            .computeIfAbsent(topic, k -> new HashMap<>())
	                            .computeIfAbsent(smell, k -> new ArrayList<>())
	                            .add(diff);
	                }
	            }
	        } catch (IOException e) {
	            JOptionPane.showMessageDialog(null, "Error reading CSV: " + e.getMessage());
	            return;
	        }

	        // Ask for topic
	        String inputTopic = JOptionPane.showInputDialog(null, "Enter topic name:");
	        if (inputTopic == null || !topicToSmellValues.containsKey(inputTopic)) {
	            JOptionPane.showMessageDialog(null, "Topic not found.");
	            return;
	        }

	        // Compute and display
	        StringBuilder result = new StringBuilder("Smell Category Percentages for " + inputTopic + ":\n\n");
	        Map<String, List<Double>> smellData = topicToSmellValues.get(inputTopic);
	        for (Map.Entry<String, List<Double>> entry : smellData.entrySet()) {
	            double sum = 0.0;
	            for (double val : entry.getValue()) sum += val;
	            double avg = (sum / entry.getValue().size()) * 100;
	            result.append(String.format("%s: %.2f%%\n", entry.getKey(), avg));
	        }

	        JTextArea textArea = new JTextArea(result.toString());
	        textArea.setEditable(false);
	        JScrollPane scrollPane = new JScrollPane(textArea);
	        scrollPane.setPreferredSize(new java.awt.Dimension(600, 400));
	        JOptionPane.showMessageDialog(null, scrollPane, "Smell Analysis Result", JOptionPane.INFORMATION_MESSAGE);
	    }

	    private static Map<String, String> getSmellMapping() {
	    	// Step 1: Define the mapping of Violation Types to Smell Categories
	        Map<String, String> violationToSmell = new HashMap<>();
	        
	        // Implementation Smells
	        violationToSmell.put("MissingSwitchDefault", "Missing Default Case");
	        violationToSmell.put("LocalVariableNamingConvention", "Inconsistent Naming Convention");
	        violationToSmell.put("FormalParameterNamingConvention", "Inconsistent Naming Convention");
	        violationToSmell.put("MethodNamingConvention", "Inconsistent Naming Convention");
	        violationToSmell.put("ClassNamingConvention", "Inconsistent Naming Convention");
	        violationToSmell.put("SimplifyBooleanExpression", "Complex Expression");
	        violationToSmell.put("CompareObjectsWithEquals", "Complex Expression");
	        violationToSmell.put("RedundantImport", "Duplicate Entity");
	        violationToSmell.put("PMD-CPD", "Duplicate Entity");
	        violationToSmell.put("VariableDeclarationUsageDistance", "Misplaced Attributes");
	        violationToSmell.put("DeclarationOrder", "Misplaced Attributes");
	        violationToSmell.put("Indentation", "Improper Alignment");
	        violationToSmell.put("FileTabCharacter", "Improper Alignment");
	        violationToSmell.put("TodoComment", "Incomplete Tasks");
	        violationToSmell.put("LineLength", "Long Statement");
	        violationToSmell.put("MethodLength", "Long Method");
	        violationToSmell.put("ExcessiveParameterList", "Long Parameter List");
	        violationToSmell.put("EmptyControlStatement", "Incomplete Conditional");
	        //violationToSmell.put("NeedBraces", "Incomplete Conditional");
	        violationToSmell.put("EmptyCatchBlock", "Empty Catch Block");
	        violationToSmell.put("MagicNumber", "Magic Number");
	        violationToSmell.put("UnusedLocalVariables", "Dead Code");
	        violationToSmell.put("UnusedPrivateFields", "Dead Code");
	        violationToSmell.put("UnusedImports", "Dead Code");
	        violationToSmell.put("RedundantModifier", "Redundant Modifier");
	        violationToSmell.put("CloseResource", "Wrong Resource Handling");
	        violationToSmell.put("AvoidFileStream", "Wrong Resource Handling");
	        violationToSmell.put("CommentRequired", "Incomplete Documentation");
	        violationToSmell.put("CommentSize", "Incomplete Documentation");
	        violationToSmell.put("CommentContent", "Incomplete Documentation");
	        violationToSmell.put("JavadocMethod", "Incomplete Documentation");
	        violationToSmell.put("JavadocType", "Incomplete Documentation");
	        violationToSmell.put("MissingJavadocPackage", "Incomplete Documentation");
	        violationToSmell.put("JavadocVariable", "Incomplete Documentation");
	        violationToSmell.put("EmptyBlock", "Empty Block");
	        violationToSmell.put("AvoidInstantiatingObjectsInLoops", "Unnecessary Memory Allocation");
	        
	        // Design Smells
	        violationToSmell.put("GodClass", "God Class");
	        violationToSmell.put("DataClass", "Data Class");
	        violationToSmell.put("ExcessiveClassLength", "Large Class");
	        violationToSmell.put("TooManyMethods", "Large Class");
	        violationToSmell.put("TooManyFields", "Large Class");
	        violationToSmell.put("LawOfDemeter", "Law of Demeter");
	        violationToSmell.put("CouplingBetweenObjects", "High Coupling");
	        violationToSmell.put("ClassFanOutComplexity", "High Coupling");
	        violationToSmell.put("VisibilityModifier", "Deficient Encapsulation");
	        violationToSmell.put("ExcessivePublicCount", "Deficient Encapsulation");
	        violationToSmell.put("FinalParameters", "Leaky Encapsulation");
	        violationToSmell.put("FinalClass", "Leaky Encapsulation");
	        violationToSmell.put("HiddenField", "Leaky Encapsulation");
	        violationToSmell.put("UseUtilityClass", "Utility Class");
	        violationToSmell.put("HideUtilityClassConstructor", "Utility Class");
	        violationToSmell.put("CyclomaticComplexity", "Cyclomatic Complexity");
	        violationToSmell.put("CognitiveComplexity", "Cognitive Complexity");
	        //violationToSmell.put("AvoidInstantiatingObjectsInLoops", "Unnecessary Memory Allocation");
	        

	        return violationToSmell;
	    }
	    
	    @Analyser
	    public static void ProcessAllViolations() {
	        // Step 0: Ask user for Java file path
	        String javaFilePath = JOptionPane.showInputDialog("Enter the full path of the Java file to process:");
	        
	        if (javaFilePath == null || javaFilePath.trim().isEmpty()) {
	            System.out.println("No file path provided. Exiting.");
	            return;
	        }

	        File javaFile = new File(javaFilePath);
	        if (!javaFile.exists()) {
	            System.out.println("File not found: " + javaFilePath);
	            return;
	        }

	        String folderPath = javaFile.getParent(); // automatically use parent directory

	        // Step 1: Run Checkstyle & PMD analysis
	        String smellOne = null;
	        String smellTwo = null;
	        String smellThree = null;
	        String smellFour = null;

	        try {
	            smellOne = CheckstyleCodeViolationDetectionByGoogle(javaFilePath);
	        } catch (IOException e) {
	            e.printStackTrace();
	        }

	        try {
	            smellTwo = CheckstyleCodeViolationDetectionBySun(javaFilePath);
	        } catch (IOException e) {
	            e.printStackTrace();
	        }

	        try {
	            smellThree = PMDCodeViolationDetection(javaFilePath);
	        } catch (IOException e) {
	            e.printStackTrace();
	        }
	        
	        try {
	            smellFour = DesigniteCodeSmellDetection(javaFilePath);
	        } catch (IOException e) {
	            e.printStackTrace();
	        }

	        // Combine all raw smells
	        String smell = (smellOne == null ? "" : smellOne) + "\n\n" +
	                       (smellTwo == null ? "" : smellTwo) + "\n\n" +
	                       (smellThree == null ? "" : smellThree) + "\n\n" +
	                       (smellFour == null ? "" : smellFour);

	        // Step 2: Process Checkstyle & PMD files for the folder
	        ProcessCheckstyleGoogleFile(folderPath);
	        ProcessCheckstyleSunFile(folderPath);
	        ProcessPMDFile(folderPath);
	        ProcessDesigniteJavaFile(folderPath);

	        // Step 3: Extract final combined smells
	        String smellGenerated = DisplayViolations(folderPath); 

	        // Step 4: Save to file
	        String violationsFilePath = folderPath + "\\ViolationsGenerated.txt";
	        try (BufferedWriter writer = new BufferedWriter(new FileWriter(violationsFilePath))) {
	            writer.write(smellGenerated);
	        } catch (IOException e) {
	            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
	        }

	        // Step 5: Run ViolationExtractor on saved file
	        smellGenerated = ViolationExtractor(violationsFilePath);

	        // Step 6: Compute average rule violation
	        //double violation = AverageRuleViolationTwo(folderPath);
	        double violation = AverageRuleViolation(smellGenerated);
	        violation = Math.round(violation * 10000.0) / 10000.0;
	        
	        smellGenerated = smellGenerated + "\n\nAverage Rule Violation: " + violation;
	        // Step 7: Save to file
	        String violationsFilePathTwo = folderPath + "\\ViolationsGeneratedTwo.txt";
	        try (BufferedWriter writer = new BufferedWriter(new FileWriter(violationsFilePathTwo))) {
	            writer.write(smellGenerated);
	        } catch (IOException e) {
	            System.out.println("An exception occurred while writing to the file: " + e.getMessage());
	        }
	        

	        // Optional: Print results
	        System.out.println("Combined Smells:\n" + smell);
	        System.out.println("Extracted Smells:\n" + smellGenerated);
	        System.out.println("Average Rule Violation: " + violation);
	        
	     // Optional: Show results in a dialog box instead of printing to console
	        String outputMessage = "Combined Smells:\n" + smell
	                             + "\n\nExtracted Smells:\n" + smellGenerated
	                             + "\n\nAverage Rule Violation: " + violation;

	        JOptionPane.showMessageDialog(null, outputMessage, "Violation Analysis Results", JOptionPane.INFORMATION_MESSAGE);

	    }
	    
	    public static String ViolationExtractor(String filePath) {
	        File file = new File(filePath);
	        Map<String, Integer> violationMap = new HashMap<>();

	        Pattern checkstylePattern = Pattern.compile(".*\\[(.*?)\\]:\\s*(\\d+)$");
	        Pattern pmdPattern = Pattern.compile("^(.*?):.*?:\\s*(\\d+)$"); // PMD: name: message: count
	        Pattern designitePattern = Pattern.compile("^(.*?):\\s*(\\d+)$"); // Designite: name: count

	        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
	            String line;

	            while ((line = reader.readLine()) != null) {
	                Matcher csMatcher = checkstylePattern.matcher(line);
	                Matcher pmdMatcher = pmdPattern.matcher(line);
	                Matcher djMatcher = designitePattern.matcher(line);

	                if (csMatcher.matches()) {
	                    String violationName = csMatcher.group(1).trim();
	                    int count = Integer.parseInt(csMatcher.group(2).trim());
	                    violationMap.merge(violationName, count, Math::max);

	                } else if (pmdMatcher.matches()) {
	                    String violationName = pmdMatcher.group(1).trim();
	                    int count = Integer.parseInt(pmdMatcher.group(2).trim());
	                    violationMap.merge(violationName, count, Math::max);

	                } else if (djMatcher.matches() && !line.startsWith("Total")) {
	                    String violationName = djMatcher.group(1).trim();
	                    int count = Integer.parseInt(djMatcher.group(2).trim());
	                    violationMap.merge(violationName, count, Math::max);
	                }
	            }

	        } catch (IOException e) {
	            System.err.println(" Error reading file: " + file.getAbsolutePath());
	            e.printStackTrace();
	            return "Error reading file.";
	        }

	        if (violationMap.isEmpty()) {
	            return " No violations found in the file.";
	        } else {
	            StringBuilder result = new StringBuilder("Violations detected:\n");
	            for (Map.Entry<String, Integer> entry : violationMap.entrySet()) {
	                result.append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
	            }
	            return result.toString();
	        }
	    }

	    
	    public static String ViolationExtractorTwo(String filePath) {
	   	    File file = new File(filePath);
	   	    Map<String, Integer> violationMap = new HashMap<>();

	   	    Pattern checkstylePattern = Pattern.compile(".*\\[(.*?)\\]:\\s*(\\d+)$");
	   	    Pattern pmdPattern = Pattern.compile("^(.*?):.*?:\\s*(\\d+)$"); // PMD: name: message: count

	   	    try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
	   	        String line;

	   	        while ((line = reader.readLine()) != null) {
	   	            Matcher csMatcher = checkstylePattern.matcher(line);
	   	            Matcher pmdMatcher = pmdPattern.matcher(line);

	   	            if (csMatcher.matches()) {
	   	                String violationName = csMatcher.group(1).trim();
	   	                int count = Integer.parseInt(csMatcher.group(2).trim());
	   	                violationMap.merge(violationName, count, Math::max);
	   	            } else if (pmdMatcher.matches()) {
	   	                String violationName = pmdMatcher.group(1).trim();
	   	                int count = Integer.parseInt(pmdMatcher.group(2).trim());
	   	                violationMap.merge(violationName, count, Math::max);
	   	            }
	   	        }

	   	    } catch (IOException e) {
	   	        System.err.println(" Error reading file: " + file.getAbsolutePath());
	   	        e.printStackTrace();
	   	        return "Error reading file.";
	   	    }

	   	    if (violationMap.isEmpty()) {
	   	        return " No violations found in the file.";
	   	    } else {
	   	        StringBuilder result = new StringBuilder("Violations detected:\n");
	   	        for (Map.Entry<String, Integer> entry : violationMap.entrySet()) {
	   	            result.append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
	   	        }
	   	        return result.toString();
	   	    }
	   	}

	    @Analyser
	    public static String DesigniteCodeSmellDetection(String file) throws IOException {
	        // Path to the Designite JAR
	        String designiteJarPath = "C:\\Users\\debal\\Downloads\\DesigniteJava.jar";
	        String tempProjectDir = "C:\\Users\\debal\\TempDesigniteProject";

	        File javaFile = new File(file);
	        String parentDirectoryPath = javaFile.getParent();

	        // Output directory inside the same folder as the Java file
	        String outputDirPath = parentDirectoryPath + File.separator + "Designite";

	        try {
	            // Step 1: Prepare temp directory
	            File tempDir = new File(tempProjectDir);
	            if (tempDir.exists()) deleteDirectory(tempDir);
	            tempDir.mkdirs();

	            // Step 2: Copy the Java file into the temp project
	            Path copiedPath = Paths.get(tempDir.getAbsolutePath(), javaFile.getName());
	            Files.copy(javaFile.toPath(), copiedPath, StandardCopyOption.REPLACE_EXISTING);

	            // Step 3: Build the command to execute Designite
	            List<String> command = new ArrayList<>();
	            command.add("C:\\Program Files\\Java\\jdk-21\\bin\\java");
	            command.add("-jar");
	            command.add(designiteJarPath);
	            command.add("-i");
	            command.add(tempProjectDir);
	            command.add("-o");
	            command.add(outputDirPath);

	            // Step 4: Run Designite with timeout
	            ProcessBuilder processBuilder = new ProcessBuilder(command);
	            processBuilder.redirectErrorStream(true);
	            Process process = processBuilder.start();

	            var executor = Executors.newSingleThreadExecutor();
	            var future = executor.submit(() -> {
	                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
	                    StringBuilder consoleOutput = new StringBuilder();
	                    String line;
	                    while ((line = reader.readLine()) != null) {
	                        consoleOutput.append(line).append(System.lineSeparator());
	                        System.out.println(line);
	                    }
	                    return consoleOutput.toString();
	                } catch (IOException e) {
	                    e.printStackTrace();
	                    return "";
	                }
	            });

	            // Step 5: Wait for process or timeout
	            String result = "";
	            if (!process.waitFor(5, TimeUnit.MINUTES)) {
	                process.destroy();
	                System.err.println("Timeout reached. Skipping file: " + javaFile.getName());
	            } else {
	                int exitCode = process.exitValue();
	                if (exitCode == 0) {
	                    System.out.println("Designite completed successfully for file: " + javaFile.getName());
	                } else {
	                    System.err.println("Designite encountered an error for file: " + javaFile.getName());
	                }
	                result = future.get(); // Capture console output
	            }

	            executor.shutdown();

	            // Step 6: Return summary (could also parse CSVs)
	            File designiteCsv = new File(outputDirPath, "designCodeSmells.csv");
	            if (designiteCsv.exists()) {
	                return Files.readString(designiteCsv.toPath()); // return CSV content
	            } else {
	                return "No Designite output found.";
	            }

	        } catch (Exception e) {
	            System.err.println("Error processing file: " + javaFile.getAbsolutePath());
	            e.printStackTrace();
	            return "Error occurred.";
	        }
	    }
	    
	    private static void deleteDirectory(File dir) {
	        File[] contents = dir.listFiles();
	        if (contents != null) {
	            for (File file : contents) {
	                deleteDirectory(file);
	            }
	        }
	        dir.delete();
	    } 
	    
	    public static void ProcessDesigniteJavaFile(String filePath) {
	    	String folderPath = filePath.concat("\\Designite");
	        File designiteFolder = new File(folderPath);

	        Map<String, Integer> smellCounts = extractDesigniteViolations(designiteFolder);

	        if (smellCounts.isEmpty()) {
	            System.out.println("No code smells found or files are missing.");
	        } else {
	            // Save summary to file
	            String summaryFilePath = new File(filePath, "DesigniteViolationAnalyzer.txt").getAbsolutePath();
	            try (FileWriter writer = new FileWriter(summaryFilePath)) {
	                int totalSmells = smellCounts.values().stream().mapToInt(Integer::intValue).sum();
	                writer.write("Total Violations: " + totalSmells + System.lineSeparator());
	                writer.write("Violations by Category:" + System.lineSeparator());
	                for (Map.Entry<String, Integer> entry : smellCounts.entrySet()) {
	                    writer.write(entry.getKey() + ": " + entry.getValue() + System.lineSeparator());
	                }
	                System.out.println("Analysis saved to: " + summaryFilePath);
	            } catch (IOException e) {
	                System.err.println("Error writing summary file: " + e.getMessage());
	            }
	        }
	    }

	    private static Map<String, Integer> extractDesigniteViolations(File designiteFolder) {
	        Map<String, Integer> smellCounts = new HashMap<>();

	        if (designiteFolder == null || !designiteFolder.exists() || !designiteFolder.isDirectory()) {
	            System.out.println(" Designite folder not found or invalid: " + designiteFolder);
	            return smellCounts;
	        }

	        File[] designiteFiles = {
	            new File(designiteFolder, "designCodeSmells.csv"),
	            new File(designiteFolder, "implementationCodeSmells.csv")
	        };

	        for (File file : designiteFiles) {
	            System.out.println("Looking for: " + file.getAbsolutePath());
	            if (!file.exists()) {
	                System.out.println(" File not found: " + file.getName());
	                continue;
	            }

	            try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
	                String line;
	                boolean isFirstLine = true;

	                while ((line = reader.readLine()) != null) {
	                    if (isFirstLine) {
	                        isFirstLine = false; // skip header
	                        continue;
	                    }

	                    String[] parts = line.split(","); // adjust if Designite uses tabs
	                    if (parts.length >= 4) {
	                        String codeSmell = parts[3].trim();
	                        smellCounts.put(codeSmell, smellCounts.getOrDefault(codeSmell, 0) + 1);
	                    }
	                }

	            } catch (IOException e) {
	                System.err.println(" Error reading Designite file: " + file.getAbsolutePath());
	                e.printStackTrace();
	            }
	        }

	        return smellCounts;
	    }
	    
	    @Analyser
	    public static String CheckstyleCodeViolationDetectionByGoogle(String file) throws IOException {
			// Path to the Checkstyle JAR and configuration file
	        String checkstyleJarPath = "C:\\Users\\debal\\Downloads\\CheckStyle\\checkstyle-10.21.1-all.jar";
	        String checkstyleConfigPath = "C:\\Users\\debal\\Downloads\\CheckStyle\\google_checks.xml";
			File javaFile = new File(file);
			// Determine the directory of the current Java file
	        String parentDirectoryPath = javaFile.getParent();

	        // Construct the output file path (outputCheckStyle.txt in the same directory)
	        String outputFilePath = parentDirectoryPath + File.separator + "outputCheckStyleGoogleChecks.txt";

	        // Build the command to execute Checkstyle
	        List<String> command = new ArrayList<>();
	        command.add("C:\\Program Files\\Java\\jdk-21\\bin\\java");
	        command.add("-jar");
	        command.add(checkstyleJarPath);
	        command.add("-c");
	        command.add(checkstyleConfigPath);
	        command.add("-o");
	        command.add(outputFilePath);
	        command.add(javaFile.getAbsolutePath());        
	        
	        // Run Checkstyle with a timeout
	        try {
	            ProcessBuilder processBuilder = new ProcessBuilder(command);
	            Process process = processBuilder.start();

	            // Use an ExecutorService to handle timeout
	            var executor = Executors.newSingleThreadExecutor();
	            var future = executor.submit(() -> {
	                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
	                    String line;
	                    while ((line = reader.readLine()) != null) {
	                        System.out.println(line);                        
	                    }
	                } catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
	            });

	            // Wait for process to complete or timeout
	            if (!process.waitFor(2, TimeUnit.MINUTES)) {
	                // Destroy process if it times out
	                process.destroy();
	                System.err.println("Timeout reached. Skipping file: " + javaFile.getName());
	            } else {
	                int exitCode = process.exitValue();
	                if (exitCode == 0) {
	                    System.out.println("Checkstyle completed successfully for file: " + javaFile.getName());
	                } else {
	                    System.err.println("Checkstyle encountered an error for file: " + javaFile.getName());
	                }
	            }

	            // Shut down the executor
	            executor.shutdown();
	        } catch (Exception e) {
	            System.err.println("Error processing file: " + javaFile.getAbsolutePath());
	            e.printStackTrace();
	        }
	        return Files.readString(Paths.get(outputFilePath));
	    }
		
	    @Analyser
		public static String CheckstyleCodeViolationDetectionBySun(String file) throws IOException {
			// Path to the Checkstyle JAR and configuration file
			String checkstyleJarPath = "C:\\Users\\debal\\Downloads\\CheckStyle\\checkstyle-10.21.1-all.jar";
		    String checkstyleConfigPath = "C:\\Users\\debal\\Downloads\\CheckStyle\\sun_checks.xml";
			File javaFile = new File(file);
			// Determine the directory of the current Java file
	        String parentDirectoryPath = javaFile.getParent();

	        // Construct the output file path (outputCheckStyle.txt in the same directory)
	        String outputFilePath = parentDirectoryPath + File.separator + "outputCheckStyleSunChecks.txt";

	        // Build the command to execute Checkstyle
	        List<String> command = new ArrayList<>();
	        command.add("C:\\Program Files\\Java\\jdk-21\\bin\\java");
	        command.add("-jar");
	        command.add(checkstyleJarPath);
	        command.add("-c");
	        command.add(checkstyleConfigPath);
	        command.add("-o");
	        command.add(outputFilePath);
	        command.add(javaFile.getAbsolutePath());
	        
	        
	        // Run Checkstyle with a timeout
	        try {
	            ProcessBuilder processBuilder = new ProcessBuilder(command);
	            Process process = processBuilder.start();

	            // Use an ExecutorService to handle timeout
	            var executor = Executors.newSingleThreadExecutor();
	            var future = executor.submit(() -> {
	                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
	                    String line;
	                    while ((line = reader.readLine()) != null) {
	                        System.out.println(line);                        
	                    }
	                } catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
	            });

	            // Wait for process to complete or timeout
	            if (!process.waitFor(2, TimeUnit.MINUTES)) {
	                // Destroy process if it times out
	                process.destroy();
	                System.err.println("Timeout reached. Skipping file: " + javaFile.getName());
	            } else {
	                int exitCode = process.exitValue();
	                if (exitCode == 0) {
	                    System.out.println("Checkstyle completed successfully for file: " + javaFile.getName());
	                } else {
	                    System.err.println("Checkstyle encountered an error for file: " + javaFile.getName());
	                }
	            }

	            // Shut down the executor
	            executor.shutdown();
	        } catch (Exception e) {
	            System.err.println("Error processing file: " + javaFile.getAbsolutePath());
	            e.printStackTrace();
	        }
	        return Files.readString(Paths.get(outputFilePath));
	    }
		
		public static void ProcessCheckstyleGoogleFile(String filePath) {
			filePath = filePath.concat("//outputCheckStyleGoogleChecks.txt");
	        Map<String, Integer> violationCategories = new HashMap<>();
	        Map<String, String> violationDescriptions = new LinkedHashMap<>();
	        int totalViolations = 0;

	        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
	            String line;
	            while ((line = br.readLine()) != null) {
	                if (line.contains("[WARN]")) {
	                    String violationCategory = extractViolationCategory(line);
	                    String[] parts = line.split(":");
	                    String violationDescription = parts[parts.length - 1].trim();
	                    if (violationCategory != null) {
	                        violationCategories.put(violationCategory, violationCategories.getOrDefault(violationCategory, 0) + 1);
	                        violationDescriptions.putIfAbsent(violationCategory, violationDescription);
	                        totalViolations++;
	                    }
	                }
	            }

	            String outputFilePath = new File(filePath).getParent() + File.separator + "CheckstyleViolationAnalyzerByGoogle.txt";
	            try (FileWriter writer = new FileWriter(outputFilePath)) {
	                writer.write("Total Violations: " + totalViolations + System.lineSeparator());
	                writer.write("Violations by Category:" + System.lineSeparator());
	                for (Map.Entry<String, Integer> entry : violationCategories.entrySet()) {
	                    String rule = entry.getKey();
	                    String description = violationDescriptions.get(rule);
	                    writer.write(rule + (description.isEmpty() ? "" : ": " + description) + ": " + entry.getValue() + System.lineSeparator());
	                }
	                System.out.println("Analysis saved to: " + outputFilePath);
	            }

	        } catch (IOException e) {
	            System.err.println("Error reading or writing files: " + e.getMessage());
	        }
	    }

	    public static String extractViolationCategory(String line) {
	        int startIndex = line.lastIndexOf('[');
	        int endIndex = line.lastIndexOf(']');
	        if (startIndex != -1 && endIndex != -1 && startIndex < endIndex) {
	            return line.substring(startIndex + 1, endIndex).trim();
	        }
	        return null;
	    }
	    
	    public static void ProcessCheckstyleSunFile(String filePath) {
	    	filePath = filePath.concat("//outputCheckStyleSunChecks.txt");
	        // Map to store violation categories and their counts
	        Map<String, Integer> violationCategories = new HashMap<>();
	        Map<String, String> violationDescriptions = new LinkedHashMap<>();
	        int totalViolations = 0;

	        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
	            String line;

	            // Read the file line by line
	            while ((line = br.readLine()) != null) {
	                // Check if the line contains a violation
	                if (line.contains("[ERROR]")) {
	                    // Extract the violation category (the part inside the square brackets)
	                    String violationCategory = extractViolationCategorySun(line);
	                    String[] parts = line.split(":");
	                    String violationDescription = parts[parts.length - 1].trim();
	                    if (violationCategory != null) {
	                        // Increment the violation count for this category
	                        violationCategories.put(violationCategory, violationCategories.getOrDefault(violationCategory, 0) + 1);
	                        violationDescriptions.putIfAbsent(violationCategory, violationDescription);
	                        totalViolations++;
	                    }
	                }
	            }

	            // Prepare the output file path
	            File checkstyleOutputFile = new File(filePath);
	            String outputFilePath = checkstyleOutputFile.getParent() + File.separator + "CheckstyleViolationAnalyzerBySun.txt";
	            // Write results to the output file
	            try (FileWriter writer = new FileWriter(outputFilePath)) {
	                writer.write("Total Violations: " + totalViolations + System.lineSeparator());
	                writer.write("Violations by Category:" + System.lineSeparator());
	                for (Map.Entry<String, Integer> entry : violationCategories.entrySet()) {
	                    String ruleName = entry.getKey();
	                    String description = violationDescriptions.get(ruleName);
	                    writer.write(ruleName + (description.isEmpty() ? "" : ": " + description) + ": " + entry.getValue() + System.lineSeparator());
	                }
	                System.out.println("Analysis saved to: " + outputFilePath);
	            } catch (IOException e) {
	                System.err.println("Error writing the file: " + e.getMessage());
	            }

	            // Print the results
	            System.out.println("Total Violations: " + totalViolations);
	            System.out.println("Violations by Category:");
	            for (Map.Entry<String, Integer> entry : violationCategories.entrySet()) {
	                String ruleName = entry.getKey();
	                String description = violationDescriptions.get(ruleName);
	                System.out.println(ruleName + (description.isEmpty() ? "" : ": " + description) + ": " + entry.getValue());
	            }
	            
	        } catch (IOException e) {
	            e.printStackTrace();
	        }       

	    }
	    
	    // Method to extract the violation category from a line
	    public static String extractViolationCategorySun(String line) {
	        // Find the position of the last square bracket, which indicates the end of the category
	        int startIndex = line.lastIndexOf('[');
	        int endIndex = line.lastIndexOf(']');

	        if (startIndex != -1 && endIndex != -1 && startIndex < endIndex) {
	            // Extract the category which is between the square brackets
	            return line.substring(startIndex + 1, endIndex).trim();
	        }
	        return null; // Return null if no category is found
	    }
	    
	    private static void ProcessPMDFile(String file) {
	    	file = file.concat("//outputPMD_ALL.txt");
	    	File pmdOutputFile = new File(file);
	        Map<String, String> violationDescriptions = new LinkedHashMap<>();
	        Map<String, Integer> ruleViolationCount = new HashMap<>();
	        int totalViolations = 0;

	        try (BufferedReader reader = new BufferedReader(new FileReader(pmdOutputFile))) {
	            String line;

	            while ((line = reader.readLine()) != null) {
	                // Extract the rule name and description using the text after the last colon
	                String[] parts = line.split(":");
	                if (parts.length >= 4) {
	                    String ruleName = parts[3].trim(); // Rule name is the fourth part
	                    String description = parts.length >= 5 ? parts[4].trim() : "";
	                    
	                    // If this is the first occurrence, store the description
	                    violationDescriptions.putIfAbsent(ruleName, description);

	                    // Count occurrences of the rule
	                    ruleViolationCount.put(ruleName, ruleViolationCount.getOrDefault(ruleName, 0) + 1);
	                    totalViolations++;
	                }
	            }
	        } catch (IOException e) {
	            System.err.println("Error reading the file: " + e.getMessage());
	            return;
	        }

	        // Prepare the output file path
	        String outputFilePath = pmdOutputFile.getParent() + File.separator + "PMDViolationAnalysis.txt";

	        // Write results to the output file
	        try (FileWriter writer = new FileWriter(outputFilePath)) {
	            writer.write("Total Violations: " + totalViolations + System.lineSeparator());
	            writer.write("Violations by Category:" + System.lineSeparator());
	            for (Map.Entry<String, Integer> entry : ruleViolationCount.entrySet()) {
	                String ruleName = entry.getKey();
	                String description = violationDescriptions.get(ruleName);
	                writer.write(ruleName + (description.isEmpty() ? "" : ": " + description) + ": " + entry.getValue() + System.lineSeparator());
	            }
	            System.out.println("Analysis saved to: " + outputFilePath);
	        } catch (IOException e) {
	            System.err.println("Error writing the file: " + e.getMessage());
	        }

	        // Print the results
	        System.out.println("Total Violations: " + totalViolations);
	        System.out.println("Violations by Category:");
	        for (Map.Entry<String, Integer> entry : ruleViolationCount.entrySet()) {
	            String ruleName = entry.getKey();
	            String description = violationDescriptions.get(ruleName);
	            System.out.println(ruleName + (description.isEmpty() ? "" : ": " + description) + ": " + entry.getValue());
	        }
	    }
		
	    public static String DisplayViolations(String folderPath) {
	    	File directory = new File(folderPath);

	        if (!directory.exists() || !directory.isDirectory()) {
	            JOptionPane.showMessageDialog(null, "Invalid directory path provided.");
	            return folderPath;
	        }

	        // Specific filenames to read
	        String[] targetFiles = {
	            "CheckstyleViolationAnalyzerByGoogle.txt",
	            "CheckstyleViolationAnalyzerBySun.txt",
	            "PMDViolationAnalysis.txt",
	            "DesigniteViolationAnalyzer.txt"
	        };

	        StringBuilder message = new StringBuilder();

	        for (String fileName : targetFiles) {
	            File file = new File(directory, fileName);
	            message.append(fileName).append(":\n");

	            if (file.exists()) {
	                try {
	                    String content = Files.readString(file.toPath());
	                    message.append(content).append("\n\n");
	                    //message.append(content);
	                } catch (IOException e) {
	                    message.append("[Error reading file: ").append(e.getMessage()).append("]\n\n");
	                }
	            } else {
	                message.append("[File not found]\n\n");
	            }
	        }

	        // Show content in a scrollable text area
	        //JTextArea textArea = new JTextArea(message.toString());
	        //textArea.setLineWrap(true);
	        //textArea.setWrapStyleWord(true);
	        //textArea.setEditable(false);
	        //JScrollPane scrollPane = new JScrollPane(textArea);
	        //scrollPane.setPreferredSize(new java.awt.Dimension(600, 400));

	        //JOptionPane.showMessageDialog(null, scrollPane, "Violation Reports", JOptionPane.INFORMATION_MESSAGE);
	        
	        return message.toString();    
	    }
	    
	    public static double AverageRuleViolation(String violationsText) {
	        // Normalization map: different names  unified name
	        Map<String, String> normalizationMap = new HashMap<>();
	        normalizationMap.put("SimplifyBooleanReturns", "SimplifyBooleanReturn");
	        normalizationMap.put("MethodNamingConventions", "MethodName");
	        normalizationMap.put("LocalVariableName", "LocalVariableNamingConventions");
	        normalizationMap.put("MethodLength", "LongMethod");
	        
	        // Store the max count for each unique rule
	        Map<String, Integer> ruleMaxCount = new HashMap<>();

	        try (BufferedReader reader = new BufferedReader(new StringReader(violationsText))) {
	            String line;
	            while ((line = reader.readLine()) != null) {
	                if (line.trim().isEmpty() || line.startsWith("Violations detected")) {
	                    continue;
	                }

	                String[] parts = line.split(":");
	                if (parts.length == 2) {
	                    String rawRule = parts[0].trim();
	                    int count = Integer.parseInt(parts[1].trim());

	                    // Normalize rule name if mapping exists
	                    String normalizedRule = normalizationMap.getOrDefault(rawRule, rawRule);

	                    // Keep the highest count if duplicate found
	                    ruleMaxCount.merge(normalizedRule, count, Math::max);
	                }
	            }
	        } catch (IOException e) {
	            e.printStackTrace();
	        }

	        if (ruleMaxCount.isEmpty()) {
	            return 0.0;
	        }

	        // Sum up counts and compute average
	        int totalViolations = ruleMaxCount.values().stream().mapToInt(Integer::intValue).sum();
	        double average = (double) totalViolations / ruleMaxCount.size();

	        // Round to 4 decimals
	        return Math.round(average * 10000.0) / 10000.0;
	    }

	    
	    public static double AverageRuleViolationTwo(String folderPath) {
	        File directory = new File(folderPath);

	        if (!directory.exists() || !directory.isDirectory()) {
	            JOptionPane.showMessageDialog(null, "Invalid directory path provided.");
	            //return folderPath;
	        }

	        String[] targetFiles = {
	            "CheckstyleViolationAnalyzerByGoogle.txt",
	            "CheckstyleViolationAnalyzerBySun.txt",
	            "PMDViolationAnalysis.txt",
	            "DesigniteViolationAnalyzer.txt"
	        };

	        int totalViolations = 0;
	        int ruleCount = 0;

	        StringBuilder message = new StringBuilder();

	        for (String fileName : targetFiles) {
	            File file = new File(directory, fileName);

	            if (file.exists()) {
	                try {
	                    String content = Files.readString(file.toPath());
	                    BufferedReader reader = new BufferedReader(new StringReader(content));
	                    String line;
	                    while ((line = reader.readLine()) != null) {
	                        if (!line.startsWith("Total Violations:")) {
	                            Matcher matcher = Pattern.compile(": (\\d+)").matcher(line);
	                            if (matcher.find()) {
	                                totalViolations += Integer.parseInt(matcher.group(1));
	                                ruleCount++;
	                            }
	                        }
	                    }
	                    } catch (IOException e) {
	                    message.append("[Error reading file: ").append(e.getMessage()).append("]\n\n");
	                }
	            } else {
	                message.append(fileName).append(": [File not found]\n\n");
	            }
	        }

	        
	            double averageViolations = (double) totalViolations / ruleCount;
	                    

	        return averageViolations;
	    }
	    
	    @Analyser
		public static String PMDCodeViolationDetection(String file) throws IOException {
			File javaFile = new File(file);
			// Determine the directory of the current Java file
	        String parentDirectoryPath = javaFile.getParent();

	        // Construct the output file path (output.txt in the same directory)
	        String outputFilePath = parentDirectoryPath + File.separator + "outputPMD_ALL.txt";
	        String outputFilePathTwo = parentDirectoryPath + File.separator + "outputPMD_ALLNumberOfViolations.txt";
	        StringBuilder output = new StringBuilder();

	        // Path to the PMD ruleset (quickstart.xml)
	        String rulesetPath = "rulesets/java/quickstart.xml";
	        String commentsCheckingPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\CommentRequired.xml";
	        String OptimizableToArrayCallPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_OptimizableToArrayCall.xml";
	        String BigIntegerInstantiationPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_BigIntegerInstantiation.xml";
	        String UseStringBufferLengthPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_UseStringBufferLength.xml";
	        String UseStringBufferForStringAppendsPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_UseStringBufferForStringAppends.xml";
	        String UselessStringValueOfPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_UselessStringValueOf.xml";
	        String UseIOStreamsWithApacheCommonsFileItemPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_UseIOStreamsWithApacheCommonsFileItem.xml";
	        String UseIndexOfCharPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_UseIndexOfChar.xml";
	        String UseArraysAsListPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_UseArraysAsList.xml";
	        String UseArrayListInsteadOfVectorPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_UseArrayListInsteadOfVector.xml";
	        String TooFewBranchesForASwitchStatementPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_TooFewBranchesForASwitchStatement.xml";
	        String StringToStringPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_StringToString.xml";
	        String Performance_StringInstantiationPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_StringInstantiation.xml";
	        String InsufficientStringBufferDeclarationPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_InsufficientStringBufferDeclaration.xml";
	        String InefficientStringBufferingPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_InefficientStringBuffering.xml";
	        String InefficientEmptyStringCheckPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_InefficientEmptyStringCheck.xml";
	        String ConsecutiveLiteralAppendsPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_ConsecutiveLiteralAppends.xml";
	        String ConsecutiveAppendsShouldReusePath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_ConsecutiveAppendsShouldReuse.xml";
	        String AvoidInstantiatingObjectsInLoopsPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_AvoidInstantiatingObjectsInLoops.xml";
	        String Performance_AvoidFileStreamPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_AvoidFileStream.xml";
	        String AvoidCalendarDateCreationPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_AvoidCalendarDateCreation.xml";
	        String AvoidArrayLoopsPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_AvoidArrayLoops.xml";
	        String AppendCharacterWithCharPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_AppendCharacterWithChar.xml";
	        String AddEmptyStringPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\Performance_AddEmptyString.xml";
	        String CommentContentPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\CommentContent.xml";
	        String CommentSizePath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\CommentSize.xml";
	        String AtLeastOneConstructorPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\AtLeastOneConstructor.xml";
	        String cyclomaticPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\cyclomaticUpperbound.xml";
	        String cognitivePath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\cognitiveUpperbound.xml";
	        String NPathComplexityPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\NPathComplexity.xml";
	        String InsecureCryptoIvPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\InsecureCryptoIv.xml";
	        String HardCodedCryptoKeyPath = "C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\HardCodedCryptoKey.xml";
	        
	        

	        // Build the command to execute PMD
	        //String command = "cmd /c cd C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin && " +
	        //                 "\"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\pmd.bat\" " +
	        //                 "check -d \"" + javaFile.getAbsolutePath() + "\" " +
	        //                 "-R \"" + commentsCheckingPath + "," + rulesetPath + "\" " +
	        //                 "-f text -r output.txt";
	        
	     // Build the command to execute PMD
	     // Build the command to execute PMD
	        String command = "cmd /c cd C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin && " +
	                         "\"C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\pmd.bat\" " +
	                         "check -d \"" + javaFile.getAbsolutePath() + "\" " +
	                         "-R \"" + commentsCheckingPath + "," + 
	                                rulesetPath + "," + 
	                                OptimizableToArrayCallPath + "," + 
	                                BigIntegerInstantiationPath + "," + 
	                                UseStringBufferLengthPath + "," + 
	                                UseStringBufferForStringAppendsPath + "," + 
	                                UselessStringValueOfPath + "," + 
	                                UseIOStreamsWithApacheCommonsFileItemPath + "," + 
	                                UseIndexOfCharPath + "," + 
	                                UseArraysAsListPath + "," + 
	                                UseArrayListInsteadOfVectorPath + "," + 
	                                TooFewBranchesForASwitchStatementPath + "," + 
	                                StringToStringPath + "," + 
	                                Performance_StringInstantiationPath + "," + 
	                                InsufficientStringBufferDeclarationPath + "," + 
	                                InefficientStringBufferingPath + "," + 
	                                InefficientEmptyStringCheckPath + "," + 
	                                ConsecutiveLiteralAppendsPath + "," + 
	                                ConsecutiveAppendsShouldReusePath + "," + 
	                                AvoidInstantiatingObjectsInLoopsPath + "," + 
	                                Performance_AvoidFileStreamPath + "," + 
	                                AvoidCalendarDateCreationPath + "," + 
	                                AvoidArrayLoopsPath + "," + 
	                                AppendCharacterWithCharPath + "," + 
	                                AddEmptyStringPath + "," + 
	                                CommentContentPath + "," + 
	                                CommentSizePath + "," + 
	                                AtLeastOneConstructorPath + "," + 
	                                cyclomaticPath + "," + 
	                                cognitivePath + "," + 
	                                NPathComplexityPath + "," + 
	                                InsecureCryptoIvPath + "," + 
	                                HardCodedCryptoKeyPath + "\" " +
	                         "-f text -r output.txt";



	        // Run PMD and handle the output
	        try {
	            // Execute the command
	            Process process = Runtime.getRuntime().exec(command);

	            // Read and print the PMD output
	            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
	            String line;
	            //StringBuilder output = new StringBuilder();
	            while ((line = reader.readLine()) != null) {
	                System.out.println(line);
	                output.append(line).append("\n");
	            }
	            
	            // Copying number of violations
	            writeOutputToFile(output.toString(), outputFilePathTwo);

	            // Copy the PMD output from default location to the target directory
	            copyFileContent("C:\\Users\\debal\\Downloads\\pmd-dist-7.0.0-rc4-bin\\pmd-bin-7.0.0-rc4\\bin\\output.txt", outputFilePath);

	        } catch (IOException e) {
	            System.err.println("Error processing file: " + javaFile.getAbsolutePath());
	            e.printStackTrace();
	        }
	        return Files.readString(Paths.get(outputFilePath));

	    }
		
		private static void writeOutputToFile(String output, String filePath) {
	        // Write the PMD output to the specified file
	        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
	            writer.write(output);
	        } catch (IOException e) {
	            e.printStackTrace();
	        }
	    }

	    private static void copyFileContent(String sourceFilePath, String destinationFilePath) {
	        try (BufferedReader reader = new BufferedReader(new FileReader(sourceFilePath));
	             BufferedWriter writer = new BufferedWriter(new FileWriter(destinationFilePath))) {

	            String line;
	            while ((line = reader.readLine()) != null) {
	                writer.write(line);
	                writer.newLine(); // Add a newline after each line
	            }
	            
	            System.out.println("Data copied from " + sourceFilePath + " to " + destinationFilePath);
	        } catch (IOException e) {
	            e.printStackTrace();
	        }
	    }
	    
	    
	    
		    private static Map<String, String> getSmellMappingTwo() {
		    	// Step 1: Define the mapping of Violation Types to Smell Categories
		        Map<String, String> violationToSmell = new HashMap<>();
		        
		     // Implementation Smell
		        violationToSmell.put("MissingSwitchDefault", "Implementation Smell");
		        violationToSmell.put("LocalVariableNamingConvention", "Implementation Smell");
		        violationToSmell.put("FormalParameterNamingConvention", "Implementation Smell");
		        violationToSmell.put("MethodNamingConvention", "Implementation Smell");
		        violationToSmell.put("ClassNamingConvention", "Implementation Smell");
		        violationToSmell.put("SimplifyBooleanExpression", "Implementation Smell");
		        violationToSmell.put("CompareObjectsWithEquals", "Implementation Smell");
		        violationToSmell.put("RedundantImport", "Implementation Smell");
		        violationToSmell.put("PMD-CPD", "Implementation Smell");
		        violationToSmell.put("VariableDeclarationUsageDistance", "Implementation Smell");
		        violationToSmell.put("DeclarationOrder", "Implementation Smell");
		        violationToSmell.put("Indentation", "Implementation Smell");
		        violationToSmell.put("FileTabCharacter", "Implementation Smell");
		        violationToSmell.put("TodoComment", "Implementation Smell");
		        violationToSmell.put("LineLength", "Implementation Smell");
		        violationToSmell.put("MethodLength", "Implementation Smell");
		        violationToSmell.put("ExcessiveParameterList", "Implementation Smell");
		        violationToSmell.put("EmptyControlStatement", "Implementation Smell");
		        //violationToSmell.put("NeedBraces", "Implementation Smell");
		        violationToSmell.put("EmptyCatchBlock", "Implementation Smell");
		        violationToSmell.put("MagicNumber", "Implementation Smell");
		        violationToSmell.put("UnusedLocalVariables", "Implementation Smell");
		        violationToSmell.put("UnusedPrivateFields", "Implementation Smell");
		        violationToSmell.put("UnusedImports", "Implementation Smell");
		        violationToSmell.put("RedundantModifier", "Implementation Smell");
		        violationToSmell.put("CloseResource", "Implementation Smell");
		        violationToSmell.put("AvoidFileStream", "Implementation Smell");
		        violationToSmell.put("CommentRequired", "Implementation Smell");
		        violationToSmell.put("CommentSize", "Implementation Smell");
		        violationToSmell.put("CommentContent", "Implementation Smell");
		        violationToSmell.put("JavadocMethod", "Implementation Smell");
		        violationToSmell.put("JavadocType", "Implementation Smell");
		        violationToSmell.put("MissingJavadocPackage", "Implementation Smell");
		        violationToSmell.put("JavadocVariable", "Implementation Smell");
		        violationToSmell.put("EmptyBlock", "Implementation Smell");
		        violationToSmell.put("AvoidInstantiatingObjectsInLoops", "Implementation Smell");

		        // Design Smell
		        violationToSmell.put("GodClass", "Design Smell");
		        violationToSmell.put("DataClass", "Design Smell");
		        violationToSmell.put("ExcessiveClassLength", "Design Smell");
		        violationToSmell.put("TooManyMethods", "Design Smell");
		        violationToSmell.put("TooManyFields", "Design Smell");
		        violationToSmell.put("LawOfDemeter", "Design Smell");
		        violationToSmell.put("CouplingBetweenObjects", "Design Smell");
		        violationToSmell.put("ClassFanOutComplexity", "Design Smell");
		        violationToSmell.put("VisibilityModifier", "Design Smell");
		        violationToSmell.put("ExcessivePublicCount", "Design Smell");
		        violationToSmell.put("FinalParameters", "Design Smell");
		        violationToSmell.put("FinalClass", "Design Smell");
		        violationToSmell.put("HiddenField", "Design Smell");
		        violationToSmell.put("UseUtilityClass", "Design Smell");
		        violationToSmell.put("HideUtilityClassConstructor", "Design Smell");
		        violationToSmell.put("CyclomaticComplexity", "Design Smell");
		        violationToSmell.put("CognitiveComplexity", "Design Smell");
		        

		        return violationToSmell;
		    }
	
		    @TestSetMetric
		    public double ViolationsPerSolution() {		    	
		    	String rootDirectoryPath = JOptionPane.showInputDialog("Enter the full path of the Java file to process:");		    	
		        File rootDir = new File(rootDirectoryPath);
		        if (!rootDir.exists() || !rootDir.isDirectory()) {
		            System.err.println(" Root directory not found or invalid.");
		            return 0.0;
		        }

		        // Normalization map for rule name variations
		        Map<String, String> normalizationMap = new HashMap<>();
		        normalizationMap.put("SimplifyBooleanReturns", "SimplifyBooleanReturn");
		        normalizationMap.put("MethodNamingConventions", "MethodName");
		        normalizationMap.put("LocalVariableName", "LocalVariableNamingConventions");
		        normalizationMap.put("MethodLength", "LongMethod");

		        double totalViolationsAcrossSamples = 0.0;
		        int sampleCount = 0;

		        for (File folder : rootDir.listFiles(File::isDirectory)) {
		            File violationFile = new File(folder, "ViolationSummary.txt");
		            if (!violationFile.exists()) continue;

		            Map<String, Integer> ruleCounts = new HashMap<>();
		            try (BufferedReader reader = new BufferedReader(new FileReader(violationFile))) {
		                String line;
		                while ((line = reader.readLine()) != null) {
		                    if (line.startsWith("Total Violations") || line.startsWith("Violations by Category"))
		                        continue;

		                    String[] parts = line.split(": Number of occurrences:");
		                    if (parts.length == 2) {
		                        String rule = parts[0].trim();
		                        int count = Integer.parseInt(parts[1].trim());
		                        String normalizedRule = normalizationMap.getOrDefault(rule, rule);

		                        // Keep the highest count if same rule appears twice
		                        ruleCounts.put(normalizedRule, Math.max(ruleCounts.getOrDefault(normalizedRule, 0), count));
		                    }
		                }
		            } catch (IOException e) {
		                System.err.println(" Error reading " + violationFile.getAbsolutePath() + ": " + e.getMessage());
		                continue;
		            }

		            // Sum violations for this sample
		            int totalViolationsInSample = ruleCounts.values().stream().mapToInt(Integer::intValue).sum();
		            totalViolationsAcrossSamples += totalViolationsInSample;
		            sampleCount++;
		        }		        
		        
		        double VS = Math.round((totalViolationsAcrossSamples / sampleCount) * 100.0) / 100.0;
		        String outputMessage = "ViolationsPerSample: " + VS;
		        JOptionPane.showMessageDialog(null, outputMessage, "Violation Analysis Results", JOptionPane.INFORMATION_MESSAGE);
		        
		        if (sampleCount == 0) return 0.0;
		        return Math.round((totalViolationsAcrossSamples / sampleCount) * 100.0) / 100.0;
		    }
		    
		    @TestSetMetric
		    public double BaselineViolationsPerSolution() {		    	
		    	String rootDirectoryPath = JOptionPane.showInputDialog("Enter the full path of the Java file to process:");		    	
		        File rootDir = new File(rootDirectoryPath);
		        if (!rootDir.exists() || !rootDir.isDirectory()) {
		            System.err.println(" Root directory not found or invalid.");
		            return 0.0;
		        }

		        // Normalization map for rule name variations
		        Map<String, String> normalizationMap = new HashMap<>();
		        normalizationMap.put("SimplifyBooleanReturns", "SimplifyBooleanReturn");
		        normalizationMap.put("MethodNamingConventions", "MethodName");
		        normalizationMap.put("LocalVariableName", "LocalVariableNamingConventions");
		        normalizationMap.put("MethodLength", "LongMethod");

		        double totalViolationsAcrossSamples = 0.0;
		        int sampleCount = 0;

		        for (File folder : rootDir.listFiles(File::isDirectory)) {
		            File violationFile = new File(folder, "ViolationSummary.txt");
		            if (!violationFile.exists()) continue;

		            Map<String, Integer> ruleCounts = new HashMap<>();
		            try (BufferedReader reader = new BufferedReader(new FileReader(violationFile))) {
		                String line;
		                while ((line = reader.readLine()) != null) {
		                    if (line.startsWith("Total Violations") || line.startsWith("Violations by Category"))
		                        continue;

		                    String[] parts = line.split(": Number of occurrences:");
		                    if (parts.length == 2) {
		                        String rule = parts[0].trim();
		                        int count = Integer.parseInt(parts[1].trim());
		                        String normalizedRule = normalizationMap.getOrDefault(rule, rule);

		                        // Keep the highest count if same rule appears twice
		                        ruleCounts.put(normalizedRule, Math.max(ruleCounts.getOrDefault(normalizedRule, 0), count));
		                    }
		                }
		            } catch (IOException e) {
		                System.err.println(" Error reading " + violationFile.getAbsolutePath() + ": " + e.getMessage());
		                continue;
		            }

		            // Sum violations for this sample
		            int totalViolationsInSample = ruleCounts.values().stream().mapToInt(Integer::intValue).sum();
		            totalViolationsAcrossSamples += totalViolationsInSample;
		            sampleCount++;
		        }		        
		        
		        double VS = Math.round((totalViolationsAcrossSamples / sampleCount) * 100.0) / 100.0;
		        String outputMessage = "ViolationsPerSample: " + VS;
		        JOptionPane.showMessageDialog(null, outputMessage, "Violation Analysis Results", JOptionPane.INFORMATION_MESSAGE);
		        
		        if (sampleCount == 0) return 0.0;
		        return Math.round((totalViolationsAcrossSamples / sampleCount) * 100.0) / 100.0;
		    }

		    
		    @TestSetMetric
		    public double AverageRuleViolation() {
		    	String rootDirectoryPath = JOptionPane.showInputDialog("Enter the full path of the Java file to process:");
		        Map<String, String> normalizationMap = new HashMap<>();
		        normalizationMap.put("SimplifyBooleanReturns", "SimplifyBooleanReturn");
		        normalizationMap.put("MethodNamingConventions", "MethodName");
		        normalizationMap.put("LocalVariableName", "LocalVariableNamingConventions");
		        normalizationMap.put("MethodLength", "LongMethod");

		        File rootDir = new File(rootDirectoryPath);
		        if (!rootDir.exists() || !rootDir.isDirectory()) {
		            JOptionPane.showMessageDialog(null, "Invalid root directory: " + rootDirectoryPath);
		            return 0.0;
		        }

		        List<Double> averagesPerSolution = new ArrayList<>();

		        for (File solutionFolder : rootDir.listFiles(File::isDirectory)) {
		            File violationFile = new File(solutionFolder, "ViolationSummary.txt");
		            if (!violationFile.exists()) continue;

		            Map<String, Integer> ruleMaxCount = new HashMap<>();

		            try (BufferedReader reader = new BufferedReader(new FileReader(violationFile))) {
		                String line;
		                while ((line = reader.readLine()) != null) {
		                    if (line.trim().isEmpty() || line.startsWith("Total Violations") || line.startsWith("Violations by Category")) {
		                        continue;
		                    }

		                    String[] parts = line.split(":");
		                    if (parts.length >= 2) {
		                        String rawRule = parts[0].trim();
		                        String countPart = parts[parts.length - 1].trim(); // take last part for count
		                        int count = Integer.parseInt(countPart.replaceAll("[^0-9]", "")); // remove non-numeric chars

		                        String normalizedRule = normalizationMap.getOrDefault(rawRule, rawRule);
		                        ruleMaxCount.merge(normalizedRule, count, Math::max);
		                    }
		                }
		            } catch (IOException e) {
		                e.printStackTrace();
		            }

		            if (!ruleMaxCount.isEmpty()) {
		                int totalViolations = ruleMaxCount.values().stream().mapToInt(Integer::intValue).sum();
		                double average = (double) totalViolations / ruleMaxCount.size();
		                averagesPerSolution.add(average);
		            }
		        }

		        if (averagesPerSolution.isEmpty()) return 0.0;
		        
		        double meanAverage = averagesPerSolution.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
		        double VS = Math.round(meanAverage * 10000.0) / 10000.0; // round to 4 decimals	        
		        String outputMessage = "AverageRuleViolation: " + VS;
		        JOptionPane.showMessageDialog(null, outputMessage, "Violation Analysis Results", JOptionPane.INFORMATION_MESSAGE);

		        meanAverage = averagesPerSolution.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
		        return Math.round(meanAverage * 10000.0) / 10000.0; // round to 4 decimals
		    }

		    
		    @TestSetMetric
		    public double IncreaseRateToBaseline() {
		    	String baselineDirPath = JOptionPane.showInputDialog("Enter the full path of the Java file to process:");
		    	String anotherDirPath = JOptionPane.showInputDialog("Enter the full path of the Java file to process:");
		    	
		        int baselineTotal = calculateTotalViolations(baselineDirPath);
		        int anotherTotal = calculateTotalViolations(anotherDirPath);

		        if (baselineTotal == 0) {
		            JOptionPane.showMessageDialog(null, "Baseline violations are 0, cannot compute increase rate.");
		            return 0.0;
		        }

		        double increaseRate = (double) (anotherTotal - baselineTotal) / baselineTotal;
		        increaseRate = Math.round(increaseRate * 10000.0) / 10000.0; // round to 4 decimals

		        String message = "Baseline Total Violations: " + baselineTotal + "\n" +
		                         "Another Total Violations: " + anotherTotal + "\n" +
		                         "Increase Rate: " + increaseRate;

		        JOptionPane.showMessageDialog(null, message, "Increase Rate Analysis", JOptionPane.INFORMATION_MESSAGE);

		        return increaseRate;
		    }

		    // helper method: sum violations across a root directory
		    private static int calculateTotalViolations(String rootDirectoryPath) {
		        Map<String, String> normalizationMap = new HashMap<>();
		        normalizationMap.put("SimplifyBooleanReturns", "SimplifyBooleanReturn");
		        normalizationMap.put("MethodNamingConventions", "MethodName");
		        normalizationMap.put("LocalVariableName", "LocalVariableNamingConventions");
		        normalizationMap.put("MethodLength", "LongMethod");

		        int totalViolations = 0;

		        File rootDir = new File(rootDirectoryPath);
		        if (!rootDir.exists() || !rootDir.isDirectory()) {
		            JOptionPane.showMessageDialog(null, "Invalid directory: " + rootDirectoryPath);
		            return 0;
		        }

		        for (File solutionFolder : rootDir.listFiles(File::isDirectory)) {
		            File violationFile = new File(solutionFolder, "ViolationSummary.txt");
		            if (!violationFile.exists()) continue;

		            Map<String, Integer> ruleMaxCount = new HashMap<>();

		            try (BufferedReader reader = new BufferedReader(new FileReader(violationFile))) {
		                String line;
		                while ((line = reader.readLine()) != null) {
		                    if (line.trim().isEmpty() || line.startsWith("Total Violations") || line.startsWith("Violations by Category")) {
		                        continue;
		                    }

		                    String[] parts = line.split(":");
		                    if (parts.length >= 2) {
		                        String rawRule = parts[0].trim();
		                        String countPart = parts[parts.length - 1].trim();
		                        int count = Integer.parseInt(countPart.replaceAll("[^0-9]", ""));

		                        String normalizedRule = normalizationMap.getOrDefault(rawRule, rawRule);
		                        ruleMaxCount.merge(normalizedRule, count, Math::max);
		                    }
		                }
		            } catch (IOException e) {
		                e.printStackTrace();
		            }

		            totalViolations += ruleMaxCount.values().stream().mapToInt(Integer::intValue).sum();
		        }

		        return totalViolations;
		    }

	
	//@TestSetMetric
	public double IterationRate() {
		double iterationRate = 0;
        String mainDirectoryPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\Usability";
        
        File mainDirectory = new File(mainDirectoryPath);

        // Check if the main directory exists and is actually a directory
        if (!mainDirectory.exists() || !mainDirectory.isDirectory()) {
            System.out.println("Invalid directory path.");
            //return;
        }

        int totalAttempts = 0;
        int folderCount = 0;

        // Loop through each folder in the main directory
        for (File folder : mainDirectory.listFiles()) {
            if (folder.isDirectory()) {
                File attemptsFile = new File(folder, "NumberOfAttempts.txt");

                // Check if the file exists
                if (attemptsFile.exists()) {
                    try (Scanner scanner = new Scanner(attemptsFile)) {
                        // Read the number of attempts from the file
                        if (scanner.hasNextInt()) {
                            int attempts = scanner.nextInt();
                            totalAttempts += attempts;
                            folderCount++;
                        }
                    } catch (FileNotFoundException e) {
                        System.out.println("Error: Could not find file " + attemptsFile.getPath());
                    }
                } else {
                    System.out.println("Warning: NumberOfAttempts.txt not found in " + folder.getPath());
                }
            }
        }

        // Calculate the iteration rate
        if (folderCount > 0) {
            iterationRate = (double) totalAttempts / folderCount;
            System.out.printf("The iteration rate is: %.2f\n", iterationRate);
            JOptionPane.showMessageDialog(null, String.format("The iteration rate is: %.2f", iterationRate));
        } else {
            System.out.println("No valid folders found with attempts data.");
            JOptionPane.showMessageDialog(null, "No valid folders found with attempts data.");
        }
        return iterationRate;
	}
	
	//@TestSetMetric
	public double PromptRefinementRate() {
		double promptRefinementRate = 0;
        String mainDirectoryPath = "C:\\Users\\debal\\OneDrive\\Desktop\\PhD folder\\ChatGPT_generated_programs\\Usability";
        
        File mainDirectory = new File(mainDirectoryPath);

        // Check if the main directory exists and is actually a directory
        if (!mainDirectory.exists() || !mainDirectory.isDirectory()) {
            JOptionPane.showMessageDialog(null, "Invalid directory path.");
            //return;
        }

        int totalCasesRequiringRePrompts = 0;
        int folderCount = 0;

        // Loop through each folder in the main directory
        for (File folder : mainDirectory.listFiles()) {
            if (folder.isDirectory()) {
                File attemptsFile = new File(folder, "NumberOfAttempts.txt");

                // Check if the file exists
                if (attemptsFile.exists()) {
                    try (Scanner scanner = new Scanner(attemptsFile)) {
                        // Read the number of attempts from the file
                        if (scanner.hasNextInt()) {
                            int attempts = scanner.nextInt();
                            folderCount++;

                            // Check if this case required re-prompts
                            if (attempts > 1) {
                                totalCasesRequiringRePrompts++;
                            }
                        }
                    } catch (FileNotFoundException e) {
                        JOptionPane.showMessageDialog(null, "Error: Could not find file " + attemptsFile.getPath());
                    }
                } else {
                    JOptionPane.showMessageDialog(null, "Warning: NumberOfAttempts.txt not found in " + folder.getPath());
                }
            }
        }

        // Calculate the prompt refinement rate and display it in a dialog box
        if (folderCount > 0) {
            promptRefinementRate = (double) totalCasesRequiringRePrompts / folderCount;
            JOptionPane.showMessageDialog(null, String.format("The prompt refinement rate is: %.2f", promptRefinementRate));
        } else {
            JOptionPane.showMessageDialog(null, "No valid folders found with attempts data.");
        }
        return promptRefinementRate;
	}
	
	@TestSetFilter
    public static void shuffleAllTestCases() {
        if (!testSuite.testSet.isEmpty()) {
            // Shuffle the entire test set
            Collections.shuffle(testSuite.testSet);
        }
    }
	
	@TestSetFilter
	public static void keepRandomTestCases() {
	    // Create a JTextField for user input
	    JTextField countInput = new JTextField();

	    // Prompt the user to enter the number of test cases to keep
	    Object[] message = {
	            "Enter the number of test cases to retain:", countInput
	    };

	    int option = JOptionPane.showConfirmDialog(null, message, "Retain Random Test Cases", JOptionPane.OK_CANCEL_OPTION);

	    if (option == JOptionPane.OK_OPTION) {
	        try {
	            int numToKeep = Integer.parseInt(countInput.getText().trim());

	            if (numToKeep <= 0) {
	                JOptionPane.showMessageDialog(null, "Please enter a positive number.");
	                return;
	            }

	            List<TestCase<String, String>> testCases = new ArrayList<>(testSuite.testSet);

	            if (numToKeep >= testCases.size()) {
	                JOptionPane.showMessageDialog(null, "The number of test cases to keep is greater than or equal to the total test cases. Keeping all test cases.");
	                return;
	            }

	            // Shuffle the test cases randomly
	            Collections.shuffle(testCases);

	            // Select the first `numToKeep` test cases
	            Set<TestCase<String, String>> toKeep = new HashSet<>(testCases.subList(0, numToKeep));

	            // Identify test cases to remove
	            List<TestCase<String, String>> toBeRemovedTCs = new ArrayList<>();
	            for (TestCase<String, String> testCase : testSuite.testSet) {
	                if (!toKeep.contains(testCase)) {
	                    toBeRemovedTCs.add(testCase);
	                }
	            }

	            // Remove all test cases that are not selected
	            testSuite.removeAllTestCases(toBeRemovedTCs);

	            System.out.println("Test suite updated. Retained " + numToKeep + " random test cases.");
	        } catch (NumberFormatException e) {
	            JOptionPane.showMessageDialog(null, "Invalid input. Please enter a valid number.");
	        }
	    }
	}

                
    public static void main(String args[]) throws IOException {
    	TestSystemForCodeSmellDetection obj = new TestSystemForCodeSmellDetection();    	
    }
}